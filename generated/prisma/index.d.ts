
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model CompanySettings
 * 
 */
export type CompanySettings = $Result.DefaultSelection<Prisma.$CompanySettingsPayload>
/**
 * Model Client
 * 
 */
export type Client = $Result.DefaultSelection<Prisma.$ClientPayload>
/**
 * Model Quote
 * 
 */
export type Quote = $Result.DefaultSelection<Prisma.$QuotePayload>
/**
 * Model QuoteItem
 * 
 */
export type QuoteItem = $Result.DefaultSelection<Prisma.$QuoteItemPayload>
/**
 * Model QuoteVersion
 * 
 */
export type QuoteVersion = $Result.DefaultSelection<Prisma.$QuoteVersionPayload>
/**
 * Model QuoteVersionItem
 * 
 */
export type QuoteVersionItem = $Result.DefaultSelection<Prisma.$QuoteVersionItemPayload>
/**
 * Model QuotePublicLink
 * 
 */
export type QuotePublicLink = $Result.DefaultSelection<Prisma.$QuotePublicLinkPayload>
/**
 * Model QuotePdf
 * 
 */
export type QuotePdf = $Result.DefaultSelection<Prisma.$QuotePdfPayload>
/**
 * Model QuoteAcceptance
 * 
 */
export type QuoteAcceptance = $Result.DefaultSelection<Prisma.$QuoteAcceptancePayload>
/**
 * Model PriceBookItem
 * 
 */
export type PriceBookItem = $Result.DefaultSelection<Prisma.$PriceBookItemPayload>
/**
 * Model TemplateSection
 * 
 */
export type TemplateSection = $Result.DefaultSelection<Prisma.$TemplateSectionPayload>
/**
 * Model TemplateSectionItem
 * 
 */
export type TemplateSectionItem = $Result.DefaultSelection<Prisma.$TemplateSectionItemPayload>
/**
 * Model Variation
 * 
 */
export type Variation = $Result.DefaultSelection<Prisma.$VariationPayload>
/**
 * Model VariationItem
 * 
 */
export type VariationItem = $Result.DefaultSelection<Prisma.$VariationItemPayload>
/**
 * Model VariationApproval
 * 
 */
export type VariationApproval = $Result.DefaultSelection<Prisma.$VariationApprovalPayload>
/**
 * Model VariationPublicLink
 * 
 */
export type VariationPublicLink = $Result.DefaultSelection<Prisma.$VariationPublicLinkPayload>
/**
 * Model VariationPdf
 * 
 */
export type VariationPdf = $Result.DefaultSelection<Prisma.$VariationPdfPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const QuoteStatus: {
  DRAFT: 'DRAFT',
  SENT: 'SENT',
  ACCEPTED: 'ACCEPTED',
  DECLINED: 'DECLINED'
};

export type QuoteStatus = (typeof QuoteStatus)[keyof typeof QuoteStatus]


export const VatMode: {
  NONE: 'NONE',
  STANDARD: 'STANDARD'
};

export type VatMode = (typeof VatMode)[keyof typeof VatMode]


export const DepositType: {
  NONE: 'NONE',
  AMOUNT: 'AMOUNT',
  PERCENT: 'PERCENT'
};

export type DepositType = (typeof DepositType)[keyof typeof DepositType]


export const ItemRowType: {
  SECTION_HEADER: 'SECTION_HEADER',
  LINE_ITEM: 'LINE_ITEM'
};

export type ItemRowType = (typeof ItemRowType)[keyof typeof ItemRowType]


export const CalcType: {
  SELL_ONLY: 'SELL_ONLY',
  UNIT_RATE: 'UNIT_RATE',
  LABOUR_HOURS: 'LABOUR_HOURS',
  ALLOWANCE: 'ALLOWANCE'
};

export type CalcType = (typeof CalcType)[keyof typeof CalcType]


export const VariationStatus: {
  DRAFT: 'DRAFT',
  SENT: 'SENT',
  APPROVED: 'APPROVED',
  DECLINED: 'DECLINED'
};

export type VariationStatus = (typeof VariationStatus)[keyof typeof VariationStatus]


export const VariationPdfStage: {
  DRAFT: 'DRAFT',
  SENT: 'SENT',
  APPROVED: 'APPROVED',
  DECLINED: 'DECLINED'
};

export type VariationPdfStage = (typeof VariationPdfStage)[keyof typeof VariationPdfStage]

}

export type QuoteStatus = $Enums.QuoteStatus

export const QuoteStatus: typeof $Enums.QuoteStatus

export type VatMode = $Enums.VatMode

export const VatMode: typeof $Enums.VatMode

export type DepositType = $Enums.DepositType

export const DepositType: typeof $Enums.DepositType

export type ItemRowType = $Enums.ItemRowType

export const ItemRowType: typeof $Enums.ItemRowType

export type CalcType = $Enums.CalcType

export const CalcType: typeof $Enums.CalcType

export type VariationStatus = $Enums.VariationStatus

export const VariationStatus: typeof $Enums.VariationStatus

export type VariationPdfStage = $Enums.VariationPdfStage

export const VariationPdfStage: typeof $Enums.VariationPdfStage

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more CompanySettings
 * const companySettings = await prisma.companySettings.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more CompanySettings
   * const companySettings = await prisma.companySettings.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.companySettings`: Exposes CRUD operations for the **CompanySettings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CompanySettings
    * const companySettings = await prisma.companySettings.findMany()
    * ```
    */
  get companySettings(): Prisma.CompanySettingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.client`: Exposes CRUD operations for the **Client** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clients
    * const clients = await prisma.client.findMany()
    * ```
    */
  get client(): Prisma.ClientDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.quote`: Exposes CRUD operations for the **Quote** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Quotes
    * const quotes = await prisma.quote.findMany()
    * ```
    */
  get quote(): Prisma.QuoteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.quoteItem`: Exposes CRUD operations for the **QuoteItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuoteItems
    * const quoteItems = await prisma.quoteItem.findMany()
    * ```
    */
  get quoteItem(): Prisma.QuoteItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.quoteVersion`: Exposes CRUD operations for the **QuoteVersion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuoteVersions
    * const quoteVersions = await prisma.quoteVersion.findMany()
    * ```
    */
  get quoteVersion(): Prisma.QuoteVersionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.quoteVersionItem`: Exposes CRUD operations for the **QuoteVersionItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuoteVersionItems
    * const quoteVersionItems = await prisma.quoteVersionItem.findMany()
    * ```
    */
  get quoteVersionItem(): Prisma.QuoteVersionItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.quotePublicLink`: Exposes CRUD operations for the **QuotePublicLink** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuotePublicLinks
    * const quotePublicLinks = await prisma.quotePublicLink.findMany()
    * ```
    */
  get quotePublicLink(): Prisma.QuotePublicLinkDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.quotePdf`: Exposes CRUD operations for the **QuotePdf** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuotePdfs
    * const quotePdfs = await prisma.quotePdf.findMany()
    * ```
    */
  get quotePdf(): Prisma.QuotePdfDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.quoteAcceptance`: Exposes CRUD operations for the **QuoteAcceptance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuoteAcceptances
    * const quoteAcceptances = await prisma.quoteAcceptance.findMany()
    * ```
    */
  get quoteAcceptance(): Prisma.QuoteAcceptanceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.priceBookItem`: Exposes CRUD operations for the **PriceBookItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PriceBookItems
    * const priceBookItems = await prisma.priceBookItem.findMany()
    * ```
    */
  get priceBookItem(): Prisma.PriceBookItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.templateSection`: Exposes CRUD operations for the **TemplateSection** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TemplateSections
    * const templateSections = await prisma.templateSection.findMany()
    * ```
    */
  get templateSection(): Prisma.TemplateSectionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.templateSectionItem`: Exposes CRUD operations for the **TemplateSectionItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TemplateSectionItems
    * const templateSectionItems = await prisma.templateSectionItem.findMany()
    * ```
    */
  get templateSectionItem(): Prisma.TemplateSectionItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.variation`: Exposes CRUD operations for the **Variation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Variations
    * const variations = await prisma.variation.findMany()
    * ```
    */
  get variation(): Prisma.VariationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.variationItem`: Exposes CRUD operations for the **VariationItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VariationItems
    * const variationItems = await prisma.variationItem.findMany()
    * ```
    */
  get variationItem(): Prisma.VariationItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.variationApproval`: Exposes CRUD operations for the **VariationApproval** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VariationApprovals
    * const variationApprovals = await prisma.variationApproval.findMany()
    * ```
    */
  get variationApproval(): Prisma.VariationApprovalDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.variationPublicLink`: Exposes CRUD operations for the **VariationPublicLink** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VariationPublicLinks
    * const variationPublicLinks = await prisma.variationPublicLink.findMany()
    * ```
    */
  get variationPublicLink(): Prisma.VariationPublicLinkDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.variationPdf`: Exposes CRUD operations for the **VariationPdf** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VariationPdfs
    * const variationPdfs = await prisma.variationPdf.findMany()
    * ```
    */
  get variationPdf(): Prisma.VariationPdfDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.19.2
   * Query Engine version: c2990dca591cba766e3b7ef5d9e8a84796e47ab7
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    CompanySettings: 'CompanySettings',
    Client: 'Client',
    Quote: 'Quote',
    QuoteItem: 'QuoteItem',
    QuoteVersion: 'QuoteVersion',
    QuoteVersionItem: 'QuoteVersionItem',
    QuotePublicLink: 'QuotePublicLink',
    QuotePdf: 'QuotePdf',
    QuoteAcceptance: 'QuoteAcceptance',
    PriceBookItem: 'PriceBookItem',
    TemplateSection: 'TemplateSection',
    TemplateSectionItem: 'TemplateSectionItem',
    Variation: 'Variation',
    VariationItem: 'VariationItem',
    VariationApproval: 'VariationApproval',
    VariationPublicLink: 'VariationPublicLink',
    VariationPdf: 'VariationPdf'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "companySettings" | "client" | "quote" | "quoteItem" | "quoteVersion" | "quoteVersionItem" | "quotePublicLink" | "quotePdf" | "quoteAcceptance" | "priceBookItem" | "templateSection" | "templateSectionItem" | "variation" | "variationItem" | "variationApproval" | "variationPublicLink" | "variationPdf"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      CompanySettings: {
        payload: Prisma.$CompanySettingsPayload<ExtArgs>
        fields: Prisma.CompanySettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompanySettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanySettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompanySettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanySettingsPayload>
          }
          findFirst: {
            args: Prisma.CompanySettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanySettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompanySettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanySettingsPayload>
          }
          findMany: {
            args: Prisma.CompanySettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanySettingsPayload>[]
          }
          create: {
            args: Prisma.CompanySettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanySettingsPayload>
          }
          createMany: {
            args: Prisma.CompanySettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CompanySettingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanySettingsPayload>[]
          }
          delete: {
            args: Prisma.CompanySettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanySettingsPayload>
          }
          update: {
            args: Prisma.CompanySettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanySettingsPayload>
          }
          deleteMany: {
            args: Prisma.CompanySettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CompanySettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CompanySettingsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanySettingsPayload>[]
          }
          upsert: {
            args: Prisma.CompanySettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanySettingsPayload>
          }
          aggregate: {
            args: Prisma.CompanySettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompanySettings>
          }
          groupBy: {
            args: Prisma.CompanySettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompanySettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompanySettingsCountArgs<ExtArgs>
            result: $Utils.Optional<CompanySettingsCountAggregateOutputType> | number
          }
        }
      }
      Client: {
        payload: Prisma.$ClientPayload<ExtArgs>
        fields: Prisma.ClientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClientFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClientFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          findFirst: {
            args: Prisma.ClientFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClientFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          findMany: {
            args: Prisma.ClientFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>[]
          }
          create: {
            args: Prisma.ClientCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          createMany: {
            args: Prisma.ClientCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClientCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>[]
          }
          delete: {
            args: Prisma.ClientDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          update: {
            args: Prisma.ClientUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          deleteMany: {
            args: Prisma.ClientDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClientUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClientUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>[]
          }
          upsert: {
            args: Prisma.ClientUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          aggregate: {
            args: Prisma.ClientAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClient>
          }
          groupBy: {
            args: Prisma.ClientGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClientGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClientCountArgs<ExtArgs>
            result: $Utils.Optional<ClientCountAggregateOutputType> | number
          }
        }
      }
      Quote: {
        payload: Prisma.$QuotePayload<ExtArgs>
        fields: Prisma.QuoteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuoteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuoteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePayload>
          }
          findFirst: {
            args: Prisma.QuoteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuoteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePayload>
          }
          findMany: {
            args: Prisma.QuoteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePayload>[]
          }
          create: {
            args: Prisma.QuoteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePayload>
          }
          createMany: {
            args: Prisma.QuoteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuoteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePayload>[]
          }
          delete: {
            args: Prisma.QuoteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePayload>
          }
          update: {
            args: Prisma.QuoteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePayload>
          }
          deleteMany: {
            args: Prisma.QuoteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuoteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QuoteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePayload>[]
          }
          upsert: {
            args: Prisma.QuoteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePayload>
          }
          aggregate: {
            args: Prisma.QuoteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuote>
          }
          groupBy: {
            args: Prisma.QuoteGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuoteGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuoteCountArgs<ExtArgs>
            result: $Utils.Optional<QuoteCountAggregateOutputType> | number
          }
        }
      }
      QuoteItem: {
        payload: Prisma.$QuoteItemPayload<ExtArgs>
        fields: Prisma.QuoteItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuoteItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuoteItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteItemPayload>
          }
          findFirst: {
            args: Prisma.QuoteItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuoteItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteItemPayload>
          }
          findMany: {
            args: Prisma.QuoteItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteItemPayload>[]
          }
          create: {
            args: Prisma.QuoteItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteItemPayload>
          }
          createMany: {
            args: Prisma.QuoteItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuoteItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteItemPayload>[]
          }
          delete: {
            args: Prisma.QuoteItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteItemPayload>
          }
          update: {
            args: Prisma.QuoteItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteItemPayload>
          }
          deleteMany: {
            args: Prisma.QuoteItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuoteItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QuoteItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteItemPayload>[]
          }
          upsert: {
            args: Prisma.QuoteItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteItemPayload>
          }
          aggregate: {
            args: Prisma.QuoteItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuoteItem>
          }
          groupBy: {
            args: Prisma.QuoteItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuoteItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuoteItemCountArgs<ExtArgs>
            result: $Utils.Optional<QuoteItemCountAggregateOutputType> | number
          }
        }
      }
      QuoteVersion: {
        payload: Prisma.$QuoteVersionPayload<ExtArgs>
        fields: Prisma.QuoteVersionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuoteVersionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteVersionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuoteVersionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteVersionPayload>
          }
          findFirst: {
            args: Prisma.QuoteVersionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteVersionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuoteVersionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteVersionPayload>
          }
          findMany: {
            args: Prisma.QuoteVersionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteVersionPayload>[]
          }
          create: {
            args: Prisma.QuoteVersionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteVersionPayload>
          }
          createMany: {
            args: Prisma.QuoteVersionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuoteVersionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteVersionPayload>[]
          }
          delete: {
            args: Prisma.QuoteVersionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteVersionPayload>
          }
          update: {
            args: Prisma.QuoteVersionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteVersionPayload>
          }
          deleteMany: {
            args: Prisma.QuoteVersionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuoteVersionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QuoteVersionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteVersionPayload>[]
          }
          upsert: {
            args: Prisma.QuoteVersionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteVersionPayload>
          }
          aggregate: {
            args: Prisma.QuoteVersionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuoteVersion>
          }
          groupBy: {
            args: Prisma.QuoteVersionGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuoteVersionGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuoteVersionCountArgs<ExtArgs>
            result: $Utils.Optional<QuoteVersionCountAggregateOutputType> | number
          }
        }
      }
      QuoteVersionItem: {
        payload: Prisma.$QuoteVersionItemPayload<ExtArgs>
        fields: Prisma.QuoteVersionItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuoteVersionItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteVersionItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuoteVersionItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteVersionItemPayload>
          }
          findFirst: {
            args: Prisma.QuoteVersionItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteVersionItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuoteVersionItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteVersionItemPayload>
          }
          findMany: {
            args: Prisma.QuoteVersionItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteVersionItemPayload>[]
          }
          create: {
            args: Prisma.QuoteVersionItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteVersionItemPayload>
          }
          createMany: {
            args: Prisma.QuoteVersionItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuoteVersionItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteVersionItemPayload>[]
          }
          delete: {
            args: Prisma.QuoteVersionItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteVersionItemPayload>
          }
          update: {
            args: Prisma.QuoteVersionItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteVersionItemPayload>
          }
          deleteMany: {
            args: Prisma.QuoteVersionItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuoteVersionItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QuoteVersionItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteVersionItemPayload>[]
          }
          upsert: {
            args: Prisma.QuoteVersionItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteVersionItemPayload>
          }
          aggregate: {
            args: Prisma.QuoteVersionItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuoteVersionItem>
          }
          groupBy: {
            args: Prisma.QuoteVersionItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuoteVersionItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuoteVersionItemCountArgs<ExtArgs>
            result: $Utils.Optional<QuoteVersionItemCountAggregateOutputType> | number
          }
        }
      }
      QuotePublicLink: {
        payload: Prisma.$QuotePublicLinkPayload<ExtArgs>
        fields: Prisma.QuotePublicLinkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuotePublicLinkFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePublicLinkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuotePublicLinkFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePublicLinkPayload>
          }
          findFirst: {
            args: Prisma.QuotePublicLinkFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePublicLinkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuotePublicLinkFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePublicLinkPayload>
          }
          findMany: {
            args: Prisma.QuotePublicLinkFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePublicLinkPayload>[]
          }
          create: {
            args: Prisma.QuotePublicLinkCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePublicLinkPayload>
          }
          createMany: {
            args: Prisma.QuotePublicLinkCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuotePublicLinkCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePublicLinkPayload>[]
          }
          delete: {
            args: Prisma.QuotePublicLinkDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePublicLinkPayload>
          }
          update: {
            args: Prisma.QuotePublicLinkUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePublicLinkPayload>
          }
          deleteMany: {
            args: Prisma.QuotePublicLinkDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuotePublicLinkUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QuotePublicLinkUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePublicLinkPayload>[]
          }
          upsert: {
            args: Prisma.QuotePublicLinkUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePublicLinkPayload>
          }
          aggregate: {
            args: Prisma.QuotePublicLinkAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuotePublicLink>
          }
          groupBy: {
            args: Prisma.QuotePublicLinkGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuotePublicLinkGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuotePublicLinkCountArgs<ExtArgs>
            result: $Utils.Optional<QuotePublicLinkCountAggregateOutputType> | number
          }
        }
      }
      QuotePdf: {
        payload: Prisma.$QuotePdfPayload<ExtArgs>
        fields: Prisma.QuotePdfFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuotePdfFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePdfPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuotePdfFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePdfPayload>
          }
          findFirst: {
            args: Prisma.QuotePdfFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePdfPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuotePdfFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePdfPayload>
          }
          findMany: {
            args: Prisma.QuotePdfFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePdfPayload>[]
          }
          create: {
            args: Prisma.QuotePdfCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePdfPayload>
          }
          createMany: {
            args: Prisma.QuotePdfCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuotePdfCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePdfPayload>[]
          }
          delete: {
            args: Prisma.QuotePdfDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePdfPayload>
          }
          update: {
            args: Prisma.QuotePdfUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePdfPayload>
          }
          deleteMany: {
            args: Prisma.QuotePdfDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuotePdfUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QuotePdfUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePdfPayload>[]
          }
          upsert: {
            args: Prisma.QuotePdfUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuotePdfPayload>
          }
          aggregate: {
            args: Prisma.QuotePdfAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuotePdf>
          }
          groupBy: {
            args: Prisma.QuotePdfGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuotePdfGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuotePdfCountArgs<ExtArgs>
            result: $Utils.Optional<QuotePdfCountAggregateOutputType> | number
          }
        }
      }
      QuoteAcceptance: {
        payload: Prisma.$QuoteAcceptancePayload<ExtArgs>
        fields: Prisma.QuoteAcceptanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuoteAcceptanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteAcceptancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuoteAcceptanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteAcceptancePayload>
          }
          findFirst: {
            args: Prisma.QuoteAcceptanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteAcceptancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuoteAcceptanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteAcceptancePayload>
          }
          findMany: {
            args: Prisma.QuoteAcceptanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteAcceptancePayload>[]
          }
          create: {
            args: Prisma.QuoteAcceptanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteAcceptancePayload>
          }
          createMany: {
            args: Prisma.QuoteAcceptanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuoteAcceptanceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteAcceptancePayload>[]
          }
          delete: {
            args: Prisma.QuoteAcceptanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteAcceptancePayload>
          }
          update: {
            args: Prisma.QuoteAcceptanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteAcceptancePayload>
          }
          deleteMany: {
            args: Prisma.QuoteAcceptanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuoteAcceptanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QuoteAcceptanceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteAcceptancePayload>[]
          }
          upsert: {
            args: Prisma.QuoteAcceptanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuoteAcceptancePayload>
          }
          aggregate: {
            args: Prisma.QuoteAcceptanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuoteAcceptance>
          }
          groupBy: {
            args: Prisma.QuoteAcceptanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuoteAcceptanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuoteAcceptanceCountArgs<ExtArgs>
            result: $Utils.Optional<QuoteAcceptanceCountAggregateOutputType> | number
          }
        }
      }
      PriceBookItem: {
        payload: Prisma.$PriceBookItemPayload<ExtArgs>
        fields: Prisma.PriceBookItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PriceBookItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceBookItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PriceBookItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceBookItemPayload>
          }
          findFirst: {
            args: Prisma.PriceBookItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceBookItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PriceBookItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceBookItemPayload>
          }
          findMany: {
            args: Prisma.PriceBookItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceBookItemPayload>[]
          }
          create: {
            args: Prisma.PriceBookItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceBookItemPayload>
          }
          createMany: {
            args: Prisma.PriceBookItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PriceBookItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceBookItemPayload>[]
          }
          delete: {
            args: Prisma.PriceBookItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceBookItemPayload>
          }
          update: {
            args: Prisma.PriceBookItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceBookItemPayload>
          }
          deleteMany: {
            args: Prisma.PriceBookItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PriceBookItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PriceBookItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceBookItemPayload>[]
          }
          upsert: {
            args: Prisma.PriceBookItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceBookItemPayload>
          }
          aggregate: {
            args: Prisma.PriceBookItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePriceBookItem>
          }
          groupBy: {
            args: Prisma.PriceBookItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<PriceBookItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.PriceBookItemCountArgs<ExtArgs>
            result: $Utils.Optional<PriceBookItemCountAggregateOutputType> | number
          }
        }
      }
      TemplateSection: {
        payload: Prisma.$TemplateSectionPayload<ExtArgs>
        fields: Prisma.TemplateSectionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TemplateSectionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateSectionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TemplateSectionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateSectionPayload>
          }
          findFirst: {
            args: Prisma.TemplateSectionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateSectionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TemplateSectionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateSectionPayload>
          }
          findMany: {
            args: Prisma.TemplateSectionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateSectionPayload>[]
          }
          create: {
            args: Prisma.TemplateSectionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateSectionPayload>
          }
          createMany: {
            args: Prisma.TemplateSectionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TemplateSectionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateSectionPayload>[]
          }
          delete: {
            args: Prisma.TemplateSectionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateSectionPayload>
          }
          update: {
            args: Prisma.TemplateSectionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateSectionPayload>
          }
          deleteMany: {
            args: Prisma.TemplateSectionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TemplateSectionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TemplateSectionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateSectionPayload>[]
          }
          upsert: {
            args: Prisma.TemplateSectionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateSectionPayload>
          }
          aggregate: {
            args: Prisma.TemplateSectionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTemplateSection>
          }
          groupBy: {
            args: Prisma.TemplateSectionGroupByArgs<ExtArgs>
            result: $Utils.Optional<TemplateSectionGroupByOutputType>[]
          }
          count: {
            args: Prisma.TemplateSectionCountArgs<ExtArgs>
            result: $Utils.Optional<TemplateSectionCountAggregateOutputType> | number
          }
        }
      }
      TemplateSectionItem: {
        payload: Prisma.$TemplateSectionItemPayload<ExtArgs>
        fields: Prisma.TemplateSectionItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TemplateSectionItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateSectionItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TemplateSectionItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateSectionItemPayload>
          }
          findFirst: {
            args: Prisma.TemplateSectionItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateSectionItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TemplateSectionItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateSectionItemPayload>
          }
          findMany: {
            args: Prisma.TemplateSectionItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateSectionItemPayload>[]
          }
          create: {
            args: Prisma.TemplateSectionItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateSectionItemPayload>
          }
          createMany: {
            args: Prisma.TemplateSectionItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TemplateSectionItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateSectionItemPayload>[]
          }
          delete: {
            args: Prisma.TemplateSectionItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateSectionItemPayload>
          }
          update: {
            args: Prisma.TemplateSectionItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateSectionItemPayload>
          }
          deleteMany: {
            args: Prisma.TemplateSectionItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TemplateSectionItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TemplateSectionItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateSectionItemPayload>[]
          }
          upsert: {
            args: Prisma.TemplateSectionItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplateSectionItemPayload>
          }
          aggregate: {
            args: Prisma.TemplateSectionItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTemplateSectionItem>
          }
          groupBy: {
            args: Prisma.TemplateSectionItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<TemplateSectionItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.TemplateSectionItemCountArgs<ExtArgs>
            result: $Utils.Optional<TemplateSectionItemCountAggregateOutputType> | number
          }
        }
      }
      Variation: {
        payload: Prisma.$VariationPayload<ExtArgs>
        fields: Prisma.VariationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VariationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VariationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariationPayload>
          }
          findFirst: {
            args: Prisma.VariationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VariationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariationPayload>
          }
          findMany: {
            args: Prisma.VariationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariationPayload>[]
          }
          create: {
            args: Prisma.VariationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariationPayload>
          }
          createMany: {
            args: Prisma.VariationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VariationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariationPayload>[]
          }
          delete: {
            args: Prisma.VariationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariationPayload>
          }
          update: {
            args: Prisma.VariationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariationPayload>
          }
          deleteMany: {
            args: Prisma.VariationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VariationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VariationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariationPayload>[]
          }
          upsert: {
            args: Prisma.VariationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariationPayload>
          }
          aggregate: {
            args: Prisma.VariationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVariation>
          }
          groupBy: {
            args: Prisma.VariationGroupByArgs<ExtArgs>
            result: $Utils.Optional<VariationGroupByOutputType>[]
          }
          count: {
            args: Prisma.VariationCountArgs<ExtArgs>
            result: $Utils.Optional<VariationCountAggregateOutputType> | number
          }
        }
      }
      VariationItem: {
        payload: Prisma.$VariationItemPayload<ExtArgs>
        fields: Prisma.VariationItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VariationItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariationItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VariationItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariationItemPayload>
          }
          findFirst: {
            args: Prisma.VariationItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariationItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VariationItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariationItemPayload>
          }
          findMany: {
            args: Prisma.VariationItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariationItemPayload>[]
          }
          create: {
            args: Prisma.VariationItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariationItemPayload>
          }
          createMany: {
            args: Prisma.VariationItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VariationItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariationItemPayload>[]
          }
          delete: {
            args: Prisma.VariationItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariationItemPayload>
          }
          update: {
            args: Prisma.VariationItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariationItemPayload>
          }
          deleteMany: {
            args: Prisma.VariationItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VariationItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VariationItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariationItemPayload>[]
          }
          upsert: {
            args: Prisma.VariationItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariationItemPayload>
          }
          aggregate: {
            args: Prisma.VariationItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVariationItem>
          }
          groupBy: {
            args: Prisma.VariationItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<VariationItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.VariationItemCountArgs<ExtArgs>
            result: $Utils.Optional<VariationItemCountAggregateOutputType> | number
          }
        }
      }
      VariationApproval: {
        payload: Prisma.$VariationApprovalPayload<ExtArgs>
        fields: Prisma.VariationApprovalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VariationApprovalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariationApprovalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VariationApprovalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariationApprovalPayload>
          }
          findFirst: {
            args: Prisma.VariationApprovalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariationApprovalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VariationApprovalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariationApprovalPayload>
          }
          findMany: {
            args: Prisma.VariationApprovalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariationApprovalPayload>[]
          }
          create: {
            args: Prisma.VariationApprovalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariationApprovalPayload>
          }
          createMany: {
            args: Prisma.VariationApprovalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VariationApprovalCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariationApprovalPayload>[]
          }
          delete: {
            args: Prisma.VariationApprovalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariationApprovalPayload>
          }
          update: {
            args: Prisma.VariationApprovalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariationApprovalPayload>
          }
          deleteMany: {
            args: Prisma.VariationApprovalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VariationApprovalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VariationApprovalUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariationApprovalPayload>[]
          }
          upsert: {
            args: Prisma.VariationApprovalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariationApprovalPayload>
          }
          aggregate: {
            args: Prisma.VariationApprovalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVariationApproval>
          }
          groupBy: {
            args: Prisma.VariationApprovalGroupByArgs<ExtArgs>
            result: $Utils.Optional<VariationApprovalGroupByOutputType>[]
          }
          count: {
            args: Prisma.VariationApprovalCountArgs<ExtArgs>
            result: $Utils.Optional<VariationApprovalCountAggregateOutputType> | number
          }
        }
      }
      VariationPublicLink: {
        payload: Prisma.$VariationPublicLinkPayload<ExtArgs>
        fields: Prisma.VariationPublicLinkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VariationPublicLinkFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariationPublicLinkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VariationPublicLinkFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariationPublicLinkPayload>
          }
          findFirst: {
            args: Prisma.VariationPublicLinkFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariationPublicLinkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VariationPublicLinkFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariationPublicLinkPayload>
          }
          findMany: {
            args: Prisma.VariationPublicLinkFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariationPublicLinkPayload>[]
          }
          create: {
            args: Prisma.VariationPublicLinkCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariationPublicLinkPayload>
          }
          createMany: {
            args: Prisma.VariationPublicLinkCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VariationPublicLinkCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariationPublicLinkPayload>[]
          }
          delete: {
            args: Prisma.VariationPublicLinkDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariationPublicLinkPayload>
          }
          update: {
            args: Prisma.VariationPublicLinkUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariationPublicLinkPayload>
          }
          deleteMany: {
            args: Prisma.VariationPublicLinkDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VariationPublicLinkUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VariationPublicLinkUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariationPublicLinkPayload>[]
          }
          upsert: {
            args: Prisma.VariationPublicLinkUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariationPublicLinkPayload>
          }
          aggregate: {
            args: Prisma.VariationPublicLinkAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVariationPublicLink>
          }
          groupBy: {
            args: Prisma.VariationPublicLinkGroupByArgs<ExtArgs>
            result: $Utils.Optional<VariationPublicLinkGroupByOutputType>[]
          }
          count: {
            args: Prisma.VariationPublicLinkCountArgs<ExtArgs>
            result: $Utils.Optional<VariationPublicLinkCountAggregateOutputType> | number
          }
        }
      }
      VariationPdf: {
        payload: Prisma.$VariationPdfPayload<ExtArgs>
        fields: Prisma.VariationPdfFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VariationPdfFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariationPdfPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VariationPdfFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariationPdfPayload>
          }
          findFirst: {
            args: Prisma.VariationPdfFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariationPdfPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VariationPdfFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariationPdfPayload>
          }
          findMany: {
            args: Prisma.VariationPdfFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariationPdfPayload>[]
          }
          create: {
            args: Prisma.VariationPdfCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariationPdfPayload>
          }
          createMany: {
            args: Prisma.VariationPdfCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VariationPdfCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariationPdfPayload>[]
          }
          delete: {
            args: Prisma.VariationPdfDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariationPdfPayload>
          }
          update: {
            args: Prisma.VariationPdfUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariationPdfPayload>
          }
          deleteMany: {
            args: Prisma.VariationPdfDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VariationPdfUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VariationPdfUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariationPdfPayload>[]
          }
          upsert: {
            args: Prisma.VariationPdfUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariationPdfPayload>
          }
          aggregate: {
            args: Prisma.VariationPdfAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVariationPdf>
          }
          groupBy: {
            args: Prisma.VariationPdfGroupByArgs<ExtArgs>
            result: $Utils.Optional<VariationPdfGroupByOutputType>[]
          }
          count: {
            args: Prisma.VariationPdfCountArgs<ExtArgs>
            result: $Utils.Optional<VariationPdfCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    companySettings?: CompanySettingsOmit
    client?: ClientOmit
    quote?: QuoteOmit
    quoteItem?: QuoteItemOmit
    quoteVersion?: QuoteVersionOmit
    quoteVersionItem?: QuoteVersionItemOmit
    quotePublicLink?: QuotePublicLinkOmit
    quotePdf?: QuotePdfOmit
    quoteAcceptance?: QuoteAcceptanceOmit
    priceBookItem?: PriceBookItemOmit
    templateSection?: TemplateSectionOmit
    templateSectionItem?: TemplateSectionItemOmit
    variation?: VariationOmit
    variationItem?: VariationItemOmit
    variationApproval?: VariationApprovalOmit
    variationPublicLink?: VariationPublicLinkOmit
    variationPdf?: VariationPdfOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type ClientCountOutputType
   */

  export type ClientCountOutputType = {
    quotes: number
  }

  export type ClientCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quotes?: boolean | ClientCountOutputTypeCountQuotesArgs
  }

  // Custom InputTypes
  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientCountOutputType
     */
    select?: ClientCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountQuotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuoteWhereInput
  }


  /**
   * Count Type QuoteCountOutputType
   */

  export type QuoteCountOutputType = {
    items: number
    publicLinks: number
    pdfs: number
    variations: number
    versions: number
  }

  export type QuoteCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | QuoteCountOutputTypeCountItemsArgs
    publicLinks?: boolean | QuoteCountOutputTypeCountPublicLinksArgs
    pdfs?: boolean | QuoteCountOutputTypeCountPdfsArgs
    variations?: boolean | QuoteCountOutputTypeCountVariationsArgs
    versions?: boolean | QuoteCountOutputTypeCountVersionsArgs
  }

  // Custom InputTypes
  /**
   * QuoteCountOutputType without action
   */
  export type QuoteCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteCountOutputType
     */
    select?: QuoteCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * QuoteCountOutputType without action
   */
  export type QuoteCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuoteItemWhereInput
  }

  /**
   * QuoteCountOutputType without action
   */
  export type QuoteCountOutputTypeCountPublicLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuotePublicLinkWhereInput
  }

  /**
   * QuoteCountOutputType without action
   */
  export type QuoteCountOutputTypeCountPdfsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuotePdfWhereInput
  }

  /**
   * QuoteCountOutputType without action
   */
  export type QuoteCountOutputTypeCountVariationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VariationWhereInput
  }

  /**
   * QuoteCountOutputType without action
   */
  export type QuoteCountOutputTypeCountVersionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuoteVersionWhereInput
  }


  /**
   * Count Type QuoteItemCountOutputType
   */

  export type QuoteItemCountOutputType = {
    children: number
  }

  export type QuoteItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    children?: boolean | QuoteItemCountOutputTypeCountChildrenArgs
  }

  // Custom InputTypes
  /**
   * QuoteItemCountOutputType without action
   */
  export type QuoteItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteItemCountOutputType
     */
    select?: QuoteItemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * QuoteItemCountOutputType without action
   */
  export type QuoteItemCountOutputTypeCountChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuoteItemWhereInput
  }


  /**
   * Count Type QuoteVersionCountOutputType
   */

  export type QuoteVersionCountOutputType = {
    items: number
  }

  export type QuoteVersionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | QuoteVersionCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * QuoteVersionCountOutputType without action
   */
  export type QuoteVersionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteVersionCountOutputType
     */
    select?: QuoteVersionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * QuoteVersionCountOutputType without action
   */
  export type QuoteVersionCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuoteVersionItemWhereInput
  }


  /**
   * Count Type QuoteVersionItemCountOutputType
   */

  export type QuoteVersionItemCountOutputType = {
    children: number
  }

  export type QuoteVersionItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    children?: boolean | QuoteVersionItemCountOutputTypeCountChildrenArgs
  }

  // Custom InputTypes
  /**
   * QuoteVersionItemCountOutputType without action
   */
  export type QuoteVersionItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteVersionItemCountOutputType
     */
    select?: QuoteVersionItemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * QuoteVersionItemCountOutputType without action
   */
  export type QuoteVersionItemCountOutputTypeCountChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuoteVersionItemWhereInput
  }


  /**
   * Count Type TemplateSectionCountOutputType
   */

  export type TemplateSectionCountOutputType = {
    items: number
  }

  export type TemplateSectionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | TemplateSectionCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * TemplateSectionCountOutputType without action
   */
  export type TemplateSectionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateSectionCountOutputType
     */
    select?: TemplateSectionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TemplateSectionCountOutputType without action
   */
  export type TemplateSectionCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TemplateSectionItemWhereInput
  }


  /**
   * Count Type VariationCountOutputType
   */

  export type VariationCountOutputType = {
    publicLinks: number
    items: number
    pdfs: number
  }

  export type VariationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    publicLinks?: boolean | VariationCountOutputTypeCountPublicLinksArgs
    items?: boolean | VariationCountOutputTypeCountItemsArgs
    pdfs?: boolean | VariationCountOutputTypeCountPdfsArgs
  }

  // Custom InputTypes
  /**
   * VariationCountOutputType without action
   */
  export type VariationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariationCountOutputType
     */
    select?: VariationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VariationCountOutputType without action
   */
  export type VariationCountOutputTypeCountPublicLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VariationPublicLinkWhereInput
  }

  /**
   * VariationCountOutputType without action
   */
  export type VariationCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VariationItemWhereInput
  }

  /**
   * VariationCountOutputType without action
   */
  export type VariationCountOutputTypeCountPdfsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VariationPdfWhereInput
  }


  /**
   * Count Type VariationItemCountOutputType
   */

  export type VariationItemCountOutputType = {
    children: number
  }

  export type VariationItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    children?: boolean | VariationItemCountOutputTypeCountChildrenArgs
  }

  // Custom InputTypes
  /**
   * VariationItemCountOutputType without action
   */
  export type VariationItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariationItemCountOutputType
     */
    select?: VariationItemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VariationItemCountOutputType without action
   */
  export type VariationItemCountOutputTypeCountChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VariationItemWhereInput
  }


  /**
   * Models
   */

  /**
   * Model CompanySettings
   */

  export type AggregateCompanySettings = {
    _count: CompanySettingsCountAggregateOutputType | null
    _avg: CompanySettingsAvgAggregateOutputType | null
    _sum: CompanySettingsSumAggregateOutputType | null
    _min: CompanySettingsMinAggregateOutputType | null
    _max: CompanySettingsMaxAggregateOutputType | null
  }

  export type CompanySettingsAvgAggregateOutputType = {
    defaultVatRateBps: number | null
  }

  export type CompanySettingsSumAggregateOutputType = {
    defaultVatRateBps: number | null
  }

  export type CompanySettingsMinAggregateOutputType = {
    id: string | null
    orgId: string | null
    companyName: string | null
    logoUrl: string | null
    addressLine1: string | null
    addressLine2: string | null
    city: string | null
    postcode: string | null
    country: string | null
    phone: string | null
    email: string | null
    website: string | null
    defaultVatMode: $Enums.VatMode | null
    defaultVatRateBps: number | null
    defaultGrouping: string | null
    defaultShowQtyToClient: boolean | null
    defaultShowUnitRatesToClient: boolean | null
    createdByUserId: string | null
    updatedByUserId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CompanySettingsMaxAggregateOutputType = {
    id: string | null
    orgId: string | null
    companyName: string | null
    logoUrl: string | null
    addressLine1: string | null
    addressLine2: string | null
    city: string | null
    postcode: string | null
    country: string | null
    phone: string | null
    email: string | null
    website: string | null
    defaultVatMode: $Enums.VatMode | null
    defaultVatRateBps: number | null
    defaultGrouping: string | null
    defaultShowQtyToClient: boolean | null
    defaultShowUnitRatesToClient: boolean | null
    createdByUserId: string | null
    updatedByUserId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CompanySettingsCountAggregateOutputType = {
    id: number
    orgId: number
    companyName: number
    logoUrl: number
    addressLine1: number
    addressLine2: number
    city: number
    postcode: number
    country: number
    phone: number
    email: number
    website: number
    defaultVatMode: number
    defaultVatRateBps: number
    defaultGrouping: number
    defaultShowQtyToClient: number
    defaultShowUnitRatesToClient: number
    defaultTermsJson: number
    defaultScopeOverviewJson: number
    createdByUserId: number
    updatedByUserId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CompanySettingsAvgAggregateInputType = {
    defaultVatRateBps?: true
  }

  export type CompanySettingsSumAggregateInputType = {
    defaultVatRateBps?: true
  }

  export type CompanySettingsMinAggregateInputType = {
    id?: true
    orgId?: true
    companyName?: true
    logoUrl?: true
    addressLine1?: true
    addressLine2?: true
    city?: true
    postcode?: true
    country?: true
    phone?: true
    email?: true
    website?: true
    defaultVatMode?: true
    defaultVatRateBps?: true
    defaultGrouping?: true
    defaultShowQtyToClient?: true
    defaultShowUnitRatesToClient?: true
    createdByUserId?: true
    updatedByUserId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CompanySettingsMaxAggregateInputType = {
    id?: true
    orgId?: true
    companyName?: true
    logoUrl?: true
    addressLine1?: true
    addressLine2?: true
    city?: true
    postcode?: true
    country?: true
    phone?: true
    email?: true
    website?: true
    defaultVatMode?: true
    defaultVatRateBps?: true
    defaultGrouping?: true
    defaultShowQtyToClient?: true
    defaultShowUnitRatesToClient?: true
    createdByUserId?: true
    updatedByUserId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CompanySettingsCountAggregateInputType = {
    id?: true
    orgId?: true
    companyName?: true
    logoUrl?: true
    addressLine1?: true
    addressLine2?: true
    city?: true
    postcode?: true
    country?: true
    phone?: true
    email?: true
    website?: true
    defaultVatMode?: true
    defaultVatRateBps?: true
    defaultGrouping?: true
    defaultShowQtyToClient?: true
    defaultShowUnitRatesToClient?: true
    defaultTermsJson?: true
    defaultScopeOverviewJson?: true
    createdByUserId?: true
    updatedByUserId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CompanySettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompanySettings to aggregate.
     */
    where?: CompanySettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanySettings to fetch.
     */
    orderBy?: CompanySettingsOrderByWithRelationInput | CompanySettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompanySettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanySettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanySettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CompanySettings
    **/
    _count?: true | CompanySettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CompanySettingsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CompanySettingsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanySettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanySettingsMaxAggregateInputType
  }

  export type GetCompanySettingsAggregateType<T extends CompanySettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateCompanySettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompanySettings[P]>
      : GetScalarType<T[P], AggregateCompanySettings[P]>
  }




  export type CompanySettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanySettingsWhereInput
    orderBy?: CompanySettingsOrderByWithAggregationInput | CompanySettingsOrderByWithAggregationInput[]
    by: CompanySettingsScalarFieldEnum[] | CompanySettingsScalarFieldEnum
    having?: CompanySettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanySettingsCountAggregateInputType | true
    _avg?: CompanySettingsAvgAggregateInputType
    _sum?: CompanySettingsSumAggregateInputType
    _min?: CompanySettingsMinAggregateInputType
    _max?: CompanySettingsMaxAggregateInputType
  }

  export type CompanySettingsGroupByOutputType = {
    id: string
    orgId: string
    companyName: string
    logoUrl: string | null
    addressLine1: string | null
    addressLine2: string | null
    city: string | null
    postcode: string | null
    country: string | null
    phone: string | null
    email: string | null
    website: string | null
    defaultVatMode: $Enums.VatMode
    defaultVatRateBps: number
    defaultGrouping: string
    defaultShowQtyToClient: boolean
    defaultShowUnitRatesToClient: boolean
    defaultTermsJson: JsonValue | null
    defaultScopeOverviewJson: JsonValue | null
    createdByUserId: string | null
    updatedByUserId: string | null
    createdAt: Date
    updatedAt: Date
    _count: CompanySettingsCountAggregateOutputType | null
    _avg: CompanySettingsAvgAggregateOutputType | null
    _sum: CompanySettingsSumAggregateOutputType | null
    _min: CompanySettingsMinAggregateOutputType | null
    _max: CompanySettingsMaxAggregateOutputType | null
  }

  type GetCompanySettingsGroupByPayload<T extends CompanySettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompanySettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanySettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanySettingsGroupByOutputType[P]>
            : GetScalarType<T[P], CompanySettingsGroupByOutputType[P]>
        }
      >
    >


  export type CompanySettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    companyName?: boolean
    logoUrl?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    city?: boolean
    postcode?: boolean
    country?: boolean
    phone?: boolean
    email?: boolean
    website?: boolean
    defaultVatMode?: boolean
    defaultVatRateBps?: boolean
    defaultGrouping?: boolean
    defaultShowQtyToClient?: boolean
    defaultShowUnitRatesToClient?: boolean
    defaultTermsJson?: boolean
    defaultScopeOverviewJson?: boolean
    createdByUserId?: boolean
    updatedByUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["companySettings"]>

  export type CompanySettingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    companyName?: boolean
    logoUrl?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    city?: boolean
    postcode?: boolean
    country?: boolean
    phone?: boolean
    email?: boolean
    website?: boolean
    defaultVatMode?: boolean
    defaultVatRateBps?: boolean
    defaultGrouping?: boolean
    defaultShowQtyToClient?: boolean
    defaultShowUnitRatesToClient?: boolean
    defaultTermsJson?: boolean
    defaultScopeOverviewJson?: boolean
    createdByUserId?: boolean
    updatedByUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["companySettings"]>

  export type CompanySettingsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    companyName?: boolean
    logoUrl?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    city?: boolean
    postcode?: boolean
    country?: boolean
    phone?: boolean
    email?: boolean
    website?: boolean
    defaultVatMode?: boolean
    defaultVatRateBps?: boolean
    defaultGrouping?: boolean
    defaultShowQtyToClient?: boolean
    defaultShowUnitRatesToClient?: boolean
    defaultTermsJson?: boolean
    defaultScopeOverviewJson?: boolean
    createdByUserId?: boolean
    updatedByUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["companySettings"]>

  export type CompanySettingsSelectScalar = {
    id?: boolean
    orgId?: boolean
    companyName?: boolean
    logoUrl?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    city?: boolean
    postcode?: boolean
    country?: boolean
    phone?: boolean
    email?: boolean
    website?: boolean
    defaultVatMode?: boolean
    defaultVatRateBps?: boolean
    defaultGrouping?: boolean
    defaultShowQtyToClient?: boolean
    defaultShowUnitRatesToClient?: boolean
    defaultTermsJson?: boolean
    defaultScopeOverviewJson?: boolean
    createdByUserId?: boolean
    updatedByUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CompanySettingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orgId" | "companyName" | "logoUrl" | "addressLine1" | "addressLine2" | "city" | "postcode" | "country" | "phone" | "email" | "website" | "defaultVatMode" | "defaultVatRateBps" | "defaultGrouping" | "defaultShowQtyToClient" | "defaultShowUnitRatesToClient" | "defaultTermsJson" | "defaultScopeOverviewJson" | "createdByUserId" | "updatedByUserId" | "createdAt" | "updatedAt", ExtArgs["result"]["companySettings"]>

  export type $CompanySettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CompanySettings"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orgId: string
      companyName: string
      logoUrl: string | null
      addressLine1: string | null
      addressLine2: string | null
      city: string | null
      postcode: string | null
      country: string | null
      phone: string | null
      email: string | null
      website: string | null
      defaultVatMode: $Enums.VatMode
      defaultVatRateBps: number
      defaultGrouping: string
      defaultShowQtyToClient: boolean
      defaultShowUnitRatesToClient: boolean
      defaultTermsJson: Prisma.JsonValue | null
      defaultScopeOverviewJson: Prisma.JsonValue | null
      createdByUserId: string | null
      updatedByUserId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["companySettings"]>
    composites: {}
  }

  type CompanySettingsGetPayload<S extends boolean | null | undefined | CompanySettingsDefaultArgs> = $Result.GetResult<Prisma.$CompanySettingsPayload, S>

  type CompanySettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CompanySettingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CompanySettingsCountAggregateInputType | true
    }

  export interface CompanySettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CompanySettings'], meta: { name: 'CompanySettings' } }
    /**
     * Find zero or one CompanySettings that matches the filter.
     * @param {CompanySettingsFindUniqueArgs} args - Arguments to find a CompanySettings
     * @example
     * // Get one CompanySettings
     * const companySettings = await prisma.companySettings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompanySettingsFindUniqueArgs>(args: SelectSubset<T, CompanySettingsFindUniqueArgs<ExtArgs>>): Prisma__CompanySettingsClient<$Result.GetResult<Prisma.$CompanySettingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CompanySettings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CompanySettingsFindUniqueOrThrowArgs} args - Arguments to find a CompanySettings
     * @example
     * // Get one CompanySettings
     * const companySettings = await prisma.companySettings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompanySettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, CompanySettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CompanySettingsClient<$Result.GetResult<Prisma.$CompanySettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CompanySettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanySettingsFindFirstArgs} args - Arguments to find a CompanySettings
     * @example
     * // Get one CompanySettings
     * const companySettings = await prisma.companySettings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompanySettingsFindFirstArgs>(args?: SelectSubset<T, CompanySettingsFindFirstArgs<ExtArgs>>): Prisma__CompanySettingsClient<$Result.GetResult<Prisma.$CompanySettingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CompanySettings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanySettingsFindFirstOrThrowArgs} args - Arguments to find a CompanySettings
     * @example
     * // Get one CompanySettings
     * const companySettings = await prisma.companySettings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompanySettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, CompanySettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__CompanySettingsClient<$Result.GetResult<Prisma.$CompanySettingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CompanySettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanySettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CompanySettings
     * const companySettings = await prisma.companySettings.findMany()
     * 
     * // Get first 10 CompanySettings
     * const companySettings = await prisma.companySettings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companySettingsWithIdOnly = await prisma.companySettings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CompanySettingsFindManyArgs>(args?: SelectSubset<T, CompanySettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanySettingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CompanySettings.
     * @param {CompanySettingsCreateArgs} args - Arguments to create a CompanySettings.
     * @example
     * // Create one CompanySettings
     * const CompanySettings = await prisma.companySettings.create({
     *   data: {
     *     // ... data to create a CompanySettings
     *   }
     * })
     * 
     */
    create<T extends CompanySettingsCreateArgs>(args: SelectSubset<T, CompanySettingsCreateArgs<ExtArgs>>): Prisma__CompanySettingsClient<$Result.GetResult<Prisma.$CompanySettingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CompanySettings.
     * @param {CompanySettingsCreateManyArgs} args - Arguments to create many CompanySettings.
     * @example
     * // Create many CompanySettings
     * const companySettings = await prisma.companySettings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CompanySettingsCreateManyArgs>(args?: SelectSubset<T, CompanySettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CompanySettings and returns the data saved in the database.
     * @param {CompanySettingsCreateManyAndReturnArgs} args - Arguments to create many CompanySettings.
     * @example
     * // Create many CompanySettings
     * const companySettings = await prisma.companySettings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CompanySettings and only return the `id`
     * const companySettingsWithIdOnly = await prisma.companySettings.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CompanySettingsCreateManyAndReturnArgs>(args?: SelectSubset<T, CompanySettingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanySettingsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CompanySettings.
     * @param {CompanySettingsDeleteArgs} args - Arguments to delete one CompanySettings.
     * @example
     * // Delete one CompanySettings
     * const CompanySettings = await prisma.companySettings.delete({
     *   where: {
     *     // ... filter to delete one CompanySettings
     *   }
     * })
     * 
     */
    delete<T extends CompanySettingsDeleteArgs>(args: SelectSubset<T, CompanySettingsDeleteArgs<ExtArgs>>): Prisma__CompanySettingsClient<$Result.GetResult<Prisma.$CompanySettingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CompanySettings.
     * @param {CompanySettingsUpdateArgs} args - Arguments to update one CompanySettings.
     * @example
     * // Update one CompanySettings
     * const companySettings = await prisma.companySettings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CompanySettingsUpdateArgs>(args: SelectSubset<T, CompanySettingsUpdateArgs<ExtArgs>>): Prisma__CompanySettingsClient<$Result.GetResult<Prisma.$CompanySettingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CompanySettings.
     * @param {CompanySettingsDeleteManyArgs} args - Arguments to filter CompanySettings to delete.
     * @example
     * // Delete a few CompanySettings
     * const { count } = await prisma.companySettings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CompanySettingsDeleteManyArgs>(args?: SelectSubset<T, CompanySettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CompanySettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanySettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CompanySettings
     * const companySettings = await prisma.companySettings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CompanySettingsUpdateManyArgs>(args: SelectSubset<T, CompanySettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CompanySettings and returns the data updated in the database.
     * @param {CompanySettingsUpdateManyAndReturnArgs} args - Arguments to update many CompanySettings.
     * @example
     * // Update many CompanySettings
     * const companySettings = await prisma.companySettings.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CompanySettings and only return the `id`
     * const companySettingsWithIdOnly = await prisma.companySettings.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CompanySettingsUpdateManyAndReturnArgs>(args: SelectSubset<T, CompanySettingsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanySettingsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CompanySettings.
     * @param {CompanySettingsUpsertArgs} args - Arguments to update or create a CompanySettings.
     * @example
     * // Update or create a CompanySettings
     * const companySettings = await prisma.companySettings.upsert({
     *   create: {
     *     // ... data to create a CompanySettings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CompanySettings we want to update
     *   }
     * })
     */
    upsert<T extends CompanySettingsUpsertArgs>(args: SelectSubset<T, CompanySettingsUpsertArgs<ExtArgs>>): Prisma__CompanySettingsClient<$Result.GetResult<Prisma.$CompanySettingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CompanySettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanySettingsCountArgs} args - Arguments to filter CompanySettings to count.
     * @example
     * // Count the number of CompanySettings
     * const count = await prisma.companySettings.count({
     *   where: {
     *     // ... the filter for the CompanySettings we want to count
     *   }
     * })
    **/
    count<T extends CompanySettingsCountArgs>(
      args?: Subset<T, CompanySettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanySettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CompanySettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanySettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanySettingsAggregateArgs>(args: Subset<T, CompanySettingsAggregateArgs>): Prisma.PrismaPromise<GetCompanySettingsAggregateType<T>>

    /**
     * Group by CompanySettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanySettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompanySettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompanySettingsGroupByArgs['orderBy'] }
        : { orderBy?: CompanySettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompanySettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanySettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CompanySettings model
   */
  readonly fields: CompanySettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CompanySettings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompanySettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CompanySettings model
   */
  interface CompanySettingsFieldRefs {
    readonly id: FieldRef<"CompanySettings", 'String'>
    readonly orgId: FieldRef<"CompanySettings", 'String'>
    readonly companyName: FieldRef<"CompanySettings", 'String'>
    readonly logoUrl: FieldRef<"CompanySettings", 'String'>
    readonly addressLine1: FieldRef<"CompanySettings", 'String'>
    readonly addressLine2: FieldRef<"CompanySettings", 'String'>
    readonly city: FieldRef<"CompanySettings", 'String'>
    readonly postcode: FieldRef<"CompanySettings", 'String'>
    readonly country: FieldRef<"CompanySettings", 'String'>
    readonly phone: FieldRef<"CompanySettings", 'String'>
    readonly email: FieldRef<"CompanySettings", 'String'>
    readonly website: FieldRef<"CompanySettings", 'String'>
    readonly defaultVatMode: FieldRef<"CompanySettings", 'VatMode'>
    readonly defaultVatRateBps: FieldRef<"CompanySettings", 'Int'>
    readonly defaultGrouping: FieldRef<"CompanySettings", 'String'>
    readonly defaultShowQtyToClient: FieldRef<"CompanySettings", 'Boolean'>
    readonly defaultShowUnitRatesToClient: FieldRef<"CompanySettings", 'Boolean'>
    readonly defaultTermsJson: FieldRef<"CompanySettings", 'Json'>
    readonly defaultScopeOverviewJson: FieldRef<"CompanySettings", 'Json'>
    readonly createdByUserId: FieldRef<"CompanySettings", 'String'>
    readonly updatedByUserId: FieldRef<"CompanySettings", 'String'>
    readonly createdAt: FieldRef<"CompanySettings", 'DateTime'>
    readonly updatedAt: FieldRef<"CompanySettings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CompanySettings findUnique
   */
  export type CompanySettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanySettings
     */
    select?: CompanySettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanySettings
     */
    omit?: CompanySettingsOmit<ExtArgs> | null
    /**
     * Filter, which CompanySettings to fetch.
     */
    where: CompanySettingsWhereUniqueInput
  }

  /**
   * CompanySettings findUniqueOrThrow
   */
  export type CompanySettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanySettings
     */
    select?: CompanySettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanySettings
     */
    omit?: CompanySettingsOmit<ExtArgs> | null
    /**
     * Filter, which CompanySettings to fetch.
     */
    where: CompanySettingsWhereUniqueInput
  }

  /**
   * CompanySettings findFirst
   */
  export type CompanySettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanySettings
     */
    select?: CompanySettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanySettings
     */
    omit?: CompanySettingsOmit<ExtArgs> | null
    /**
     * Filter, which CompanySettings to fetch.
     */
    where?: CompanySettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanySettings to fetch.
     */
    orderBy?: CompanySettingsOrderByWithRelationInput | CompanySettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompanySettings.
     */
    cursor?: CompanySettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanySettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanySettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompanySettings.
     */
    distinct?: CompanySettingsScalarFieldEnum | CompanySettingsScalarFieldEnum[]
  }

  /**
   * CompanySettings findFirstOrThrow
   */
  export type CompanySettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanySettings
     */
    select?: CompanySettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanySettings
     */
    omit?: CompanySettingsOmit<ExtArgs> | null
    /**
     * Filter, which CompanySettings to fetch.
     */
    where?: CompanySettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanySettings to fetch.
     */
    orderBy?: CompanySettingsOrderByWithRelationInput | CompanySettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompanySettings.
     */
    cursor?: CompanySettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanySettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanySettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompanySettings.
     */
    distinct?: CompanySettingsScalarFieldEnum | CompanySettingsScalarFieldEnum[]
  }

  /**
   * CompanySettings findMany
   */
  export type CompanySettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanySettings
     */
    select?: CompanySettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanySettings
     */
    omit?: CompanySettingsOmit<ExtArgs> | null
    /**
     * Filter, which CompanySettings to fetch.
     */
    where?: CompanySettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanySettings to fetch.
     */
    orderBy?: CompanySettingsOrderByWithRelationInput | CompanySettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CompanySettings.
     */
    cursor?: CompanySettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanySettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanySettings.
     */
    skip?: number
    distinct?: CompanySettingsScalarFieldEnum | CompanySettingsScalarFieldEnum[]
  }

  /**
   * CompanySettings create
   */
  export type CompanySettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanySettings
     */
    select?: CompanySettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanySettings
     */
    omit?: CompanySettingsOmit<ExtArgs> | null
    /**
     * The data needed to create a CompanySettings.
     */
    data: XOR<CompanySettingsCreateInput, CompanySettingsUncheckedCreateInput>
  }

  /**
   * CompanySettings createMany
   */
  export type CompanySettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CompanySettings.
     */
    data: CompanySettingsCreateManyInput | CompanySettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CompanySettings createManyAndReturn
   */
  export type CompanySettingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanySettings
     */
    select?: CompanySettingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CompanySettings
     */
    omit?: CompanySettingsOmit<ExtArgs> | null
    /**
     * The data used to create many CompanySettings.
     */
    data: CompanySettingsCreateManyInput | CompanySettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CompanySettings update
   */
  export type CompanySettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanySettings
     */
    select?: CompanySettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanySettings
     */
    omit?: CompanySettingsOmit<ExtArgs> | null
    /**
     * The data needed to update a CompanySettings.
     */
    data: XOR<CompanySettingsUpdateInput, CompanySettingsUncheckedUpdateInput>
    /**
     * Choose, which CompanySettings to update.
     */
    where: CompanySettingsWhereUniqueInput
  }

  /**
   * CompanySettings updateMany
   */
  export type CompanySettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CompanySettings.
     */
    data: XOR<CompanySettingsUpdateManyMutationInput, CompanySettingsUncheckedUpdateManyInput>
    /**
     * Filter which CompanySettings to update
     */
    where?: CompanySettingsWhereInput
    /**
     * Limit how many CompanySettings to update.
     */
    limit?: number
  }

  /**
   * CompanySettings updateManyAndReturn
   */
  export type CompanySettingsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanySettings
     */
    select?: CompanySettingsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CompanySettings
     */
    omit?: CompanySettingsOmit<ExtArgs> | null
    /**
     * The data used to update CompanySettings.
     */
    data: XOR<CompanySettingsUpdateManyMutationInput, CompanySettingsUncheckedUpdateManyInput>
    /**
     * Filter which CompanySettings to update
     */
    where?: CompanySettingsWhereInput
    /**
     * Limit how many CompanySettings to update.
     */
    limit?: number
  }

  /**
   * CompanySettings upsert
   */
  export type CompanySettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanySettings
     */
    select?: CompanySettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanySettings
     */
    omit?: CompanySettingsOmit<ExtArgs> | null
    /**
     * The filter to search for the CompanySettings to update in case it exists.
     */
    where: CompanySettingsWhereUniqueInput
    /**
     * In case the CompanySettings found by the `where` argument doesn't exist, create a new CompanySettings with this data.
     */
    create: XOR<CompanySettingsCreateInput, CompanySettingsUncheckedCreateInput>
    /**
     * In case the CompanySettings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompanySettingsUpdateInput, CompanySettingsUncheckedUpdateInput>
  }

  /**
   * CompanySettings delete
   */
  export type CompanySettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanySettings
     */
    select?: CompanySettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanySettings
     */
    omit?: CompanySettingsOmit<ExtArgs> | null
    /**
     * Filter which CompanySettings to delete.
     */
    where: CompanySettingsWhereUniqueInput
  }

  /**
   * CompanySettings deleteMany
   */
  export type CompanySettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompanySettings to delete
     */
    where?: CompanySettingsWhereInput
    /**
     * Limit how many CompanySettings to delete.
     */
    limit?: number
  }

  /**
   * CompanySettings without action
   */
  export type CompanySettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanySettings
     */
    select?: CompanySettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanySettings
     */
    omit?: CompanySettingsOmit<ExtArgs> | null
  }


  /**
   * Model Client
   */

  export type AggregateClient = {
    _count: ClientCountAggregateOutputType | null
    _min: ClientMinAggregateOutputType | null
    _max: ClientMaxAggregateOutputType | null
  }

  export type ClientMinAggregateOutputType = {
    id: string | null
    orgId: string | null
    name: string | null
    email: string | null
    phone: string | null
    addressLine1: string | null
    addressLine2: string | null
    city: string | null
    postcode: string | null
    country: string | null
    notes: string | null
    createdByUserId: string | null
    updatedByUserId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClientMaxAggregateOutputType = {
    id: string | null
    orgId: string | null
    name: string | null
    email: string | null
    phone: string | null
    addressLine1: string | null
    addressLine2: string | null
    city: string | null
    postcode: string | null
    country: string | null
    notes: string | null
    createdByUserId: string | null
    updatedByUserId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClientCountAggregateOutputType = {
    id: number
    orgId: number
    name: number
    email: number
    phone: number
    addressLine1: number
    addressLine2: number
    city: number
    postcode: number
    country: number
    notes: number
    createdByUserId: number
    updatedByUserId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ClientMinAggregateInputType = {
    id?: true
    orgId?: true
    name?: true
    email?: true
    phone?: true
    addressLine1?: true
    addressLine2?: true
    city?: true
    postcode?: true
    country?: true
    notes?: true
    createdByUserId?: true
    updatedByUserId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClientMaxAggregateInputType = {
    id?: true
    orgId?: true
    name?: true
    email?: true
    phone?: true
    addressLine1?: true
    addressLine2?: true
    city?: true
    postcode?: true
    country?: true
    notes?: true
    createdByUserId?: true
    updatedByUserId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClientCountAggregateInputType = {
    id?: true
    orgId?: true
    name?: true
    email?: true
    phone?: true
    addressLine1?: true
    addressLine2?: true
    city?: true
    postcode?: true
    country?: true
    notes?: true
    createdByUserId?: true
    updatedByUserId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ClientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Client to aggregate.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Clients
    **/
    _count?: true | ClientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientMaxAggregateInputType
  }

  export type GetClientAggregateType<T extends ClientAggregateArgs> = {
        [P in keyof T & keyof AggregateClient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClient[P]>
      : GetScalarType<T[P], AggregateClient[P]>
  }




  export type ClientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientWhereInput
    orderBy?: ClientOrderByWithAggregationInput | ClientOrderByWithAggregationInput[]
    by: ClientScalarFieldEnum[] | ClientScalarFieldEnum
    having?: ClientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientCountAggregateInputType | true
    _min?: ClientMinAggregateInputType
    _max?: ClientMaxAggregateInputType
  }

  export type ClientGroupByOutputType = {
    id: string
    orgId: string
    name: string
    email: string | null
    phone: string | null
    addressLine1: string | null
    addressLine2: string | null
    city: string | null
    postcode: string | null
    country: string | null
    notes: string | null
    createdByUserId: string | null
    updatedByUserId: string | null
    createdAt: Date
    updatedAt: Date
    _count: ClientCountAggregateOutputType | null
    _min: ClientMinAggregateOutputType | null
    _max: ClientMaxAggregateOutputType | null
  }

  type GetClientGroupByPayload<T extends ClientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientGroupByOutputType[P]>
            : GetScalarType<T[P], ClientGroupByOutputType[P]>
        }
      >
    >


  export type ClientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    city?: boolean
    postcode?: boolean
    country?: boolean
    notes?: boolean
    createdByUserId?: boolean
    updatedByUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    quotes?: boolean | Client$quotesArgs<ExtArgs>
    _count?: boolean | ClientCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["client"]>

  export type ClientSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    city?: boolean
    postcode?: boolean
    country?: boolean
    notes?: boolean
    createdByUserId?: boolean
    updatedByUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["client"]>

  export type ClientSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    city?: boolean
    postcode?: boolean
    country?: boolean
    notes?: boolean
    createdByUserId?: boolean
    updatedByUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["client"]>

  export type ClientSelectScalar = {
    id?: boolean
    orgId?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    city?: boolean
    postcode?: boolean
    country?: boolean
    notes?: boolean
    createdByUserId?: boolean
    updatedByUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ClientOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orgId" | "name" | "email" | "phone" | "addressLine1" | "addressLine2" | "city" | "postcode" | "country" | "notes" | "createdByUserId" | "updatedByUserId" | "createdAt" | "updatedAt", ExtArgs["result"]["client"]>
  export type ClientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quotes?: boolean | Client$quotesArgs<ExtArgs>
    _count?: boolean | ClientCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ClientIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ClientIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ClientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Client"
    objects: {
      quotes: Prisma.$QuotePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orgId: string
      name: string
      email: string | null
      phone: string | null
      addressLine1: string | null
      addressLine2: string | null
      city: string | null
      postcode: string | null
      country: string | null
      notes: string | null
      createdByUserId: string | null
      updatedByUserId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["client"]>
    composites: {}
  }

  type ClientGetPayload<S extends boolean | null | undefined | ClientDefaultArgs> = $Result.GetResult<Prisma.$ClientPayload, S>

  type ClientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClientFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClientCountAggregateInputType | true
    }

  export interface ClientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Client'], meta: { name: 'Client' } }
    /**
     * Find zero or one Client that matches the filter.
     * @param {ClientFindUniqueArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClientFindUniqueArgs>(args: SelectSubset<T, ClientFindUniqueArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Client that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClientFindUniqueOrThrowArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClientFindUniqueOrThrowArgs>(args: SelectSubset<T, ClientFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Client that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindFirstArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClientFindFirstArgs>(args?: SelectSubset<T, ClientFindFirstArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Client that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindFirstOrThrowArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClientFindFirstOrThrowArgs>(args?: SelectSubset<T, ClientFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Clients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clients
     * const clients = await prisma.client.findMany()
     * 
     * // Get first 10 Clients
     * const clients = await prisma.client.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clientWithIdOnly = await prisma.client.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClientFindManyArgs>(args?: SelectSubset<T, ClientFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Client.
     * @param {ClientCreateArgs} args - Arguments to create a Client.
     * @example
     * // Create one Client
     * const Client = await prisma.client.create({
     *   data: {
     *     // ... data to create a Client
     *   }
     * })
     * 
     */
    create<T extends ClientCreateArgs>(args: SelectSubset<T, ClientCreateArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Clients.
     * @param {ClientCreateManyArgs} args - Arguments to create many Clients.
     * @example
     * // Create many Clients
     * const client = await prisma.client.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClientCreateManyArgs>(args?: SelectSubset<T, ClientCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Clients and returns the data saved in the database.
     * @param {ClientCreateManyAndReturnArgs} args - Arguments to create many Clients.
     * @example
     * // Create many Clients
     * const client = await prisma.client.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Clients and only return the `id`
     * const clientWithIdOnly = await prisma.client.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClientCreateManyAndReturnArgs>(args?: SelectSubset<T, ClientCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Client.
     * @param {ClientDeleteArgs} args - Arguments to delete one Client.
     * @example
     * // Delete one Client
     * const Client = await prisma.client.delete({
     *   where: {
     *     // ... filter to delete one Client
     *   }
     * })
     * 
     */
    delete<T extends ClientDeleteArgs>(args: SelectSubset<T, ClientDeleteArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Client.
     * @param {ClientUpdateArgs} args - Arguments to update one Client.
     * @example
     * // Update one Client
     * const client = await prisma.client.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClientUpdateArgs>(args: SelectSubset<T, ClientUpdateArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Clients.
     * @param {ClientDeleteManyArgs} args - Arguments to filter Clients to delete.
     * @example
     * // Delete a few Clients
     * const { count } = await prisma.client.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClientDeleteManyArgs>(args?: SelectSubset<T, ClientDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clients
     * const client = await prisma.client.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClientUpdateManyArgs>(args: SelectSubset<T, ClientUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clients and returns the data updated in the database.
     * @param {ClientUpdateManyAndReturnArgs} args - Arguments to update many Clients.
     * @example
     * // Update many Clients
     * const client = await prisma.client.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Clients and only return the `id`
     * const clientWithIdOnly = await prisma.client.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClientUpdateManyAndReturnArgs>(args: SelectSubset<T, ClientUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Client.
     * @param {ClientUpsertArgs} args - Arguments to update or create a Client.
     * @example
     * // Update or create a Client
     * const client = await prisma.client.upsert({
     *   create: {
     *     // ... data to create a Client
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Client we want to update
     *   }
     * })
     */
    upsert<T extends ClientUpsertArgs>(args: SelectSubset<T, ClientUpsertArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientCountArgs} args - Arguments to filter Clients to count.
     * @example
     * // Count the number of Clients
     * const count = await prisma.client.count({
     *   where: {
     *     // ... the filter for the Clients we want to count
     *   }
     * })
    **/
    count<T extends ClientCountArgs>(
      args?: Subset<T, ClientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Client.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientAggregateArgs>(args: Subset<T, ClientAggregateArgs>): Prisma.PrismaPromise<GetClientAggregateType<T>>

    /**
     * Group by Client.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientGroupByArgs['orderBy'] }
        : { orderBy?: ClientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Client model
   */
  readonly fields: ClientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Client.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    quotes<T extends Client$quotesArgs<ExtArgs> = {}>(args?: Subset<T, Client$quotesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Client model
   */
  interface ClientFieldRefs {
    readonly id: FieldRef<"Client", 'String'>
    readonly orgId: FieldRef<"Client", 'String'>
    readonly name: FieldRef<"Client", 'String'>
    readonly email: FieldRef<"Client", 'String'>
    readonly phone: FieldRef<"Client", 'String'>
    readonly addressLine1: FieldRef<"Client", 'String'>
    readonly addressLine2: FieldRef<"Client", 'String'>
    readonly city: FieldRef<"Client", 'String'>
    readonly postcode: FieldRef<"Client", 'String'>
    readonly country: FieldRef<"Client", 'String'>
    readonly notes: FieldRef<"Client", 'String'>
    readonly createdByUserId: FieldRef<"Client", 'String'>
    readonly updatedByUserId: FieldRef<"Client", 'String'>
    readonly createdAt: FieldRef<"Client", 'DateTime'>
    readonly updatedAt: FieldRef<"Client", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Client findUnique
   */
  export type ClientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client findUniqueOrThrow
   */
  export type ClientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client findFirst
   */
  export type ClientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clients.
     */
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client findFirstOrThrow
   */
  export type ClientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clients.
     */
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client findMany
   */
  export type ClientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Clients to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client create
   */
  export type ClientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The data needed to create a Client.
     */
    data: XOR<ClientCreateInput, ClientUncheckedCreateInput>
  }

  /**
   * Client createMany
   */
  export type ClientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Clients.
     */
    data: ClientCreateManyInput | ClientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Client createManyAndReturn
   */
  export type ClientCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * The data used to create many Clients.
     */
    data: ClientCreateManyInput | ClientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Client update
   */
  export type ClientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The data needed to update a Client.
     */
    data: XOR<ClientUpdateInput, ClientUncheckedUpdateInput>
    /**
     * Choose, which Client to update.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client updateMany
   */
  export type ClientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Clients.
     */
    data: XOR<ClientUpdateManyMutationInput, ClientUncheckedUpdateManyInput>
    /**
     * Filter which Clients to update
     */
    where?: ClientWhereInput
    /**
     * Limit how many Clients to update.
     */
    limit?: number
  }

  /**
   * Client updateManyAndReturn
   */
  export type ClientUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * The data used to update Clients.
     */
    data: XOR<ClientUpdateManyMutationInput, ClientUncheckedUpdateManyInput>
    /**
     * Filter which Clients to update
     */
    where?: ClientWhereInput
    /**
     * Limit how many Clients to update.
     */
    limit?: number
  }

  /**
   * Client upsert
   */
  export type ClientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The filter to search for the Client to update in case it exists.
     */
    where: ClientWhereUniqueInput
    /**
     * In case the Client found by the `where` argument doesn't exist, create a new Client with this data.
     */
    create: XOR<ClientCreateInput, ClientUncheckedCreateInput>
    /**
     * In case the Client was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClientUpdateInput, ClientUncheckedUpdateInput>
  }

  /**
   * Client delete
   */
  export type ClientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter which Client to delete.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client deleteMany
   */
  export type ClientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Clients to delete
     */
    where?: ClientWhereInput
    /**
     * Limit how many Clients to delete.
     */
    limit?: number
  }

  /**
   * Client.quotes
   */
  export type Client$quotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quote
     */
    omit?: QuoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteInclude<ExtArgs> | null
    where?: QuoteWhereInput
    orderBy?: QuoteOrderByWithRelationInput | QuoteOrderByWithRelationInput[]
    cursor?: QuoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuoteScalarFieldEnum | QuoteScalarFieldEnum[]
  }

  /**
   * Client without action
   */
  export type ClientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
  }


  /**
   * Model Quote
   */

  export type AggregateQuote = {
    _count: QuoteCountAggregateOutputType | null
    _avg: QuoteAvgAggregateOutputType | null
    _sum: QuoteSumAggregateOutputType | null
    _min: QuoteMinAggregateOutputType | null
    _max: QuoteMaxAggregateOutputType | null
  }

  export type QuoteAvgAggregateOutputType = {
    currentVersion: number | null
    vatRateBps: number | null
    depositAmountPence: number | null
    depositPercentBps: number | null
    estimatedDurationWeeks: number | null
  }

  export type QuoteSumAggregateOutputType = {
    currentVersion: number | null
    vatRateBps: number | null
    depositAmountPence: number | null
    depositPercentBps: number | null
    estimatedDurationWeeks: number | null
  }

  export type QuoteMinAggregateOutputType = {
    id: string | null
    orgId: string | null
    clientId: string | null
    title: string | null
    referenceNo: string | null
    projectAddress: string | null
    status: $Enums.QuoteStatus | null
    currentVersion: number | null
    sentAt: Date | null
    acceptedAt: Date | null
    vatMode: $Enums.VatMode | null
    vatRateBps: number | null
    depositType: $Enums.DepositType | null
    depositAmountPence: number | null
    depositPercentBps: number | null
    showQtyToClient: boolean | null
    showUnitRatesToClient: boolean | null
    estimatedStartDate: Date | null
    estimatedDurationWeeks: number | null
    createdByUserId: string | null
    updatedByUserId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuoteMaxAggregateOutputType = {
    id: string | null
    orgId: string | null
    clientId: string | null
    title: string | null
    referenceNo: string | null
    projectAddress: string | null
    status: $Enums.QuoteStatus | null
    currentVersion: number | null
    sentAt: Date | null
    acceptedAt: Date | null
    vatMode: $Enums.VatMode | null
    vatRateBps: number | null
    depositType: $Enums.DepositType | null
    depositAmountPence: number | null
    depositPercentBps: number | null
    showQtyToClient: boolean | null
    showUnitRatesToClient: boolean | null
    estimatedStartDate: Date | null
    estimatedDurationWeeks: number | null
    createdByUserId: string | null
    updatedByUserId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuoteCountAggregateOutputType = {
    id: number
    orgId: number
    clientId: number
    title: number
    referenceNo: number
    projectAddress: number
    status: number
    currentVersion: number
    sentAt: number
    acceptedAt: number
    vatMode: number
    vatRateBps: number
    depositType: number
    depositAmountPence: number
    depositPercentBps: number
    paymentScheduleJson: number
    showQtyToClient: number
    showUnitRatesToClient: number
    scopeOverviewJson: number
    termsJson: number
    estimatedStartDate: number
    estimatedDurationWeeks: number
    createdByUserId: number
    updatedByUserId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type QuoteAvgAggregateInputType = {
    currentVersion?: true
    vatRateBps?: true
    depositAmountPence?: true
    depositPercentBps?: true
    estimatedDurationWeeks?: true
  }

  export type QuoteSumAggregateInputType = {
    currentVersion?: true
    vatRateBps?: true
    depositAmountPence?: true
    depositPercentBps?: true
    estimatedDurationWeeks?: true
  }

  export type QuoteMinAggregateInputType = {
    id?: true
    orgId?: true
    clientId?: true
    title?: true
    referenceNo?: true
    projectAddress?: true
    status?: true
    currentVersion?: true
    sentAt?: true
    acceptedAt?: true
    vatMode?: true
    vatRateBps?: true
    depositType?: true
    depositAmountPence?: true
    depositPercentBps?: true
    showQtyToClient?: true
    showUnitRatesToClient?: true
    estimatedStartDate?: true
    estimatedDurationWeeks?: true
    createdByUserId?: true
    updatedByUserId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuoteMaxAggregateInputType = {
    id?: true
    orgId?: true
    clientId?: true
    title?: true
    referenceNo?: true
    projectAddress?: true
    status?: true
    currentVersion?: true
    sentAt?: true
    acceptedAt?: true
    vatMode?: true
    vatRateBps?: true
    depositType?: true
    depositAmountPence?: true
    depositPercentBps?: true
    showQtyToClient?: true
    showUnitRatesToClient?: true
    estimatedStartDate?: true
    estimatedDurationWeeks?: true
    createdByUserId?: true
    updatedByUserId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuoteCountAggregateInputType = {
    id?: true
    orgId?: true
    clientId?: true
    title?: true
    referenceNo?: true
    projectAddress?: true
    status?: true
    currentVersion?: true
    sentAt?: true
    acceptedAt?: true
    vatMode?: true
    vatRateBps?: true
    depositType?: true
    depositAmountPence?: true
    depositPercentBps?: true
    paymentScheduleJson?: true
    showQtyToClient?: true
    showUnitRatesToClient?: true
    scopeOverviewJson?: true
    termsJson?: true
    estimatedStartDate?: true
    estimatedDurationWeeks?: true
    createdByUserId?: true
    updatedByUserId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type QuoteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Quote to aggregate.
     */
    where?: QuoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quotes to fetch.
     */
    orderBy?: QuoteOrderByWithRelationInput | QuoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Quotes
    **/
    _count?: true | QuoteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuoteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuoteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuoteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuoteMaxAggregateInputType
  }

  export type GetQuoteAggregateType<T extends QuoteAggregateArgs> = {
        [P in keyof T & keyof AggregateQuote]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuote[P]>
      : GetScalarType<T[P], AggregateQuote[P]>
  }




  export type QuoteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuoteWhereInput
    orderBy?: QuoteOrderByWithAggregationInput | QuoteOrderByWithAggregationInput[]
    by: QuoteScalarFieldEnum[] | QuoteScalarFieldEnum
    having?: QuoteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuoteCountAggregateInputType | true
    _avg?: QuoteAvgAggregateInputType
    _sum?: QuoteSumAggregateInputType
    _min?: QuoteMinAggregateInputType
    _max?: QuoteMaxAggregateInputType
  }

  export type QuoteGroupByOutputType = {
    id: string
    orgId: string
    clientId: string | null
    title: string
    referenceNo: string | null
    projectAddress: string | null
    status: $Enums.QuoteStatus
    currentVersion: number
    sentAt: Date | null
    acceptedAt: Date | null
    vatMode: $Enums.VatMode
    vatRateBps: number
    depositType: $Enums.DepositType
    depositAmountPence: number | null
    depositPercentBps: number | null
    paymentScheduleJson: JsonValue | null
    showQtyToClient: boolean
    showUnitRatesToClient: boolean
    scopeOverviewJson: JsonValue | null
    termsJson: JsonValue | null
    estimatedStartDate: Date | null
    estimatedDurationWeeks: number | null
    createdByUserId: string | null
    updatedByUserId: string | null
    createdAt: Date
    updatedAt: Date
    _count: QuoteCountAggregateOutputType | null
    _avg: QuoteAvgAggregateOutputType | null
    _sum: QuoteSumAggregateOutputType | null
    _min: QuoteMinAggregateOutputType | null
    _max: QuoteMaxAggregateOutputType | null
  }

  type GetQuoteGroupByPayload<T extends QuoteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuoteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuoteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuoteGroupByOutputType[P]>
            : GetScalarType<T[P], QuoteGroupByOutputType[P]>
        }
      >
    >


  export type QuoteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    clientId?: boolean
    title?: boolean
    referenceNo?: boolean
    projectAddress?: boolean
    status?: boolean
    currentVersion?: boolean
    sentAt?: boolean
    acceptedAt?: boolean
    vatMode?: boolean
    vatRateBps?: boolean
    depositType?: boolean
    depositAmountPence?: boolean
    depositPercentBps?: boolean
    paymentScheduleJson?: boolean
    showQtyToClient?: boolean
    showUnitRatesToClient?: boolean
    scopeOverviewJson?: boolean
    termsJson?: boolean
    estimatedStartDate?: boolean
    estimatedDurationWeeks?: boolean
    createdByUserId?: boolean
    updatedByUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client?: boolean | Quote$clientArgs<ExtArgs>
    items?: boolean | Quote$itemsArgs<ExtArgs>
    publicLinks?: boolean | Quote$publicLinksArgs<ExtArgs>
    pdfs?: boolean | Quote$pdfsArgs<ExtArgs>
    acceptance?: boolean | Quote$acceptanceArgs<ExtArgs>
    variations?: boolean | Quote$variationsArgs<ExtArgs>
    versions?: boolean | Quote$versionsArgs<ExtArgs>
    _count?: boolean | QuoteCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quote"]>

  export type QuoteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    clientId?: boolean
    title?: boolean
    referenceNo?: boolean
    projectAddress?: boolean
    status?: boolean
    currentVersion?: boolean
    sentAt?: boolean
    acceptedAt?: boolean
    vatMode?: boolean
    vatRateBps?: boolean
    depositType?: boolean
    depositAmountPence?: boolean
    depositPercentBps?: boolean
    paymentScheduleJson?: boolean
    showQtyToClient?: boolean
    showUnitRatesToClient?: boolean
    scopeOverviewJson?: boolean
    termsJson?: boolean
    estimatedStartDate?: boolean
    estimatedDurationWeeks?: boolean
    createdByUserId?: boolean
    updatedByUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client?: boolean | Quote$clientArgs<ExtArgs>
  }, ExtArgs["result"]["quote"]>

  export type QuoteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    clientId?: boolean
    title?: boolean
    referenceNo?: boolean
    projectAddress?: boolean
    status?: boolean
    currentVersion?: boolean
    sentAt?: boolean
    acceptedAt?: boolean
    vatMode?: boolean
    vatRateBps?: boolean
    depositType?: boolean
    depositAmountPence?: boolean
    depositPercentBps?: boolean
    paymentScheduleJson?: boolean
    showQtyToClient?: boolean
    showUnitRatesToClient?: boolean
    scopeOverviewJson?: boolean
    termsJson?: boolean
    estimatedStartDate?: boolean
    estimatedDurationWeeks?: boolean
    createdByUserId?: boolean
    updatedByUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client?: boolean | Quote$clientArgs<ExtArgs>
  }, ExtArgs["result"]["quote"]>

  export type QuoteSelectScalar = {
    id?: boolean
    orgId?: boolean
    clientId?: boolean
    title?: boolean
    referenceNo?: boolean
    projectAddress?: boolean
    status?: boolean
    currentVersion?: boolean
    sentAt?: boolean
    acceptedAt?: boolean
    vatMode?: boolean
    vatRateBps?: boolean
    depositType?: boolean
    depositAmountPence?: boolean
    depositPercentBps?: boolean
    paymentScheduleJson?: boolean
    showQtyToClient?: boolean
    showUnitRatesToClient?: boolean
    scopeOverviewJson?: boolean
    termsJson?: boolean
    estimatedStartDate?: boolean
    estimatedDurationWeeks?: boolean
    createdByUserId?: boolean
    updatedByUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type QuoteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orgId" | "clientId" | "title" | "referenceNo" | "projectAddress" | "status" | "currentVersion" | "sentAt" | "acceptedAt" | "vatMode" | "vatRateBps" | "depositType" | "depositAmountPence" | "depositPercentBps" | "paymentScheduleJson" | "showQtyToClient" | "showUnitRatesToClient" | "scopeOverviewJson" | "termsJson" | "estimatedStartDate" | "estimatedDurationWeeks" | "createdByUserId" | "updatedByUserId" | "createdAt" | "updatedAt", ExtArgs["result"]["quote"]>
  export type QuoteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | Quote$clientArgs<ExtArgs>
    items?: boolean | Quote$itemsArgs<ExtArgs>
    publicLinks?: boolean | Quote$publicLinksArgs<ExtArgs>
    pdfs?: boolean | Quote$pdfsArgs<ExtArgs>
    acceptance?: boolean | Quote$acceptanceArgs<ExtArgs>
    variations?: boolean | Quote$variationsArgs<ExtArgs>
    versions?: boolean | Quote$versionsArgs<ExtArgs>
    _count?: boolean | QuoteCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type QuoteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | Quote$clientArgs<ExtArgs>
  }
  export type QuoteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | Quote$clientArgs<ExtArgs>
  }

  export type $QuotePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Quote"
    objects: {
      client: Prisma.$ClientPayload<ExtArgs> | null
      items: Prisma.$QuoteItemPayload<ExtArgs>[]
      publicLinks: Prisma.$QuotePublicLinkPayload<ExtArgs>[]
      pdfs: Prisma.$QuotePdfPayload<ExtArgs>[]
      acceptance: Prisma.$QuoteAcceptancePayload<ExtArgs> | null
      variations: Prisma.$VariationPayload<ExtArgs>[]
      versions: Prisma.$QuoteVersionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orgId: string
      clientId: string | null
      title: string
      referenceNo: string | null
      projectAddress: string | null
      status: $Enums.QuoteStatus
      currentVersion: number
      sentAt: Date | null
      acceptedAt: Date | null
      vatMode: $Enums.VatMode
      vatRateBps: number
      depositType: $Enums.DepositType
      depositAmountPence: number | null
      depositPercentBps: number | null
      paymentScheduleJson: Prisma.JsonValue | null
      showQtyToClient: boolean
      showUnitRatesToClient: boolean
      scopeOverviewJson: Prisma.JsonValue | null
      termsJson: Prisma.JsonValue | null
      estimatedStartDate: Date | null
      estimatedDurationWeeks: number | null
      createdByUserId: string | null
      updatedByUserId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["quote"]>
    composites: {}
  }

  type QuoteGetPayload<S extends boolean | null | undefined | QuoteDefaultArgs> = $Result.GetResult<Prisma.$QuotePayload, S>

  type QuoteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QuoteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuoteCountAggregateInputType | true
    }

  export interface QuoteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Quote'], meta: { name: 'Quote' } }
    /**
     * Find zero or one Quote that matches the filter.
     * @param {QuoteFindUniqueArgs} args - Arguments to find a Quote
     * @example
     * // Get one Quote
     * const quote = await prisma.quote.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuoteFindUniqueArgs>(args: SelectSubset<T, QuoteFindUniqueArgs<ExtArgs>>): Prisma__QuoteClient<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Quote that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QuoteFindUniqueOrThrowArgs} args - Arguments to find a Quote
     * @example
     * // Get one Quote
     * const quote = await prisma.quote.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuoteFindUniqueOrThrowArgs>(args: SelectSubset<T, QuoteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuoteClient<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Quote that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteFindFirstArgs} args - Arguments to find a Quote
     * @example
     * // Get one Quote
     * const quote = await prisma.quote.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuoteFindFirstArgs>(args?: SelectSubset<T, QuoteFindFirstArgs<ExtArgs>>): Prisma__QuoteClient<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Quote that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteFindFirstOrThrowArgs} args - Arguments to find a Quote
     * @example
     * // Get one Quote
     * const quote = await prisma.quote.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuoteFindFirstOrThrowArgs>(args?: SelectSubset<T, QuoteFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuoteClient<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Quotes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Quotes
     * const quotes = await prisma.quote.findMany()
     * 
     * // Get first 10 Quotes
     * const quotes = await prisma.quote.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quoteWithIdOnly = await prisma.quote.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuoteFindManyArgs>(args?: SelectSubset<T, QuoteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Quote.
     * @param {QuoteCreateArgs} args - Arguments to create a Quote.
     * @example
     * // Create one Quote
     * const Quote = await prisma.quote.create({
     *   data: {
     *     // ... data to create a Quote
     *   }
     * })
     * 
     */
    create<T extends QuoteCreateArgs>(args: SelectSubset<T, QuoteCreateArgs<ExtArgs>>): Prisma__QuoteClient<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Quotes.
     * @param {QuoteCreateManyArgs} args - Arguments to create many Quotes.
     * @example
     * // Create many Quotes
     * const quote = await prisma.quote.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuoteCreateManyArgs>(args?: SelectSubset<T, QuoteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Quotes and returns the data saved in the database.
     * @param {QuoteCreateManyAndReturnArgs} args - Arguments to create many Quotes.
     * @example
     * // Create many Quotes
     * const quote = await prisma.quote.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Quotes and only return the `id`
     * const quoteWithIdOnly = await prisma.quote.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuoteCreateManyAndReturnArgs>(args?: SelectSubset<T, QuoteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Quote.
     * @param {QuoteDeleteArgs} args - Arguments to delete one Quote.
     * @example
     * // Delete one Quote
     * const Quote = await prisma.quote.delete({
     *   where: {
     *     // ... filter to delete one Quote
     *   }
     * })
     * 
     */
    delete<T extends QuoteDeleteArgs>(args: SelectSubset<T, QuoteDeleteArgs<ExtArgs>>): Prisma__QuoteClient<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Quote.
     * @param {QuoteUpdateArgs} args - Arguments to update one Quote.
     * @example
     * // Update one Quote
     * const quote = await prisma.quote.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuoteUpdateArgs>(args: SelectSubset<T, QuoteUpdateArgs<ExtArgs>>): Prisma__QuoteClient<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Quotes.
     * @param {QuoteDeleteManyArgs} args - Arguments to filter Quotes to delete.
     * @example
     * // Delete a few Quotes
     * const { count } = await prisma.quote.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuoteDeleteManyArgs>(args?: SelectSubset<T, QuoteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Quotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Quotes
     * const quote = await prisma.quote.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuoteUpdateManyArgs>(args: SelectSubset<T, QuoteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Quotes and returns the data updated in the database.
     * @param {QuoteUpdateManyAndReturnArgs} args - Arguments to update many Quotes.
     * @example
     * // Update many Quotes
     * const quote = await prisma.quote.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Quotes and only return the `id`
     * const quoteWithIdOnly = await prisma.quote.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QuoteUpdateManyAndReturnArgs>(args: SelectSubset<T, QuoteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Quote.
     * @param {QuoteUpsertArgs} args - Arguments to update or create a Quote.
     * @example
     * // Update or create a Quote
     * const quote = await prisma.quote.upsert({
     *   create: {
     *     // ... data to create a Quote
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Quote we want to update
     *   }
     * })
     */
    upsert<T extends QuoteUpsertArgs>(args: SelectSubset<T, QuoteUpsertArgs<ExtArgs>>): Prisma__QuoteClient<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Quotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteCountArgs} args - Arguments to filter Quotes to count.
     * @example
     * // Count the number of Quotes
     * const count = await prisma.quote.count({
     *   where: {
     *     // ... the filter for the Quotes we want to count
     *   }
     * })
    **/
    count<T extends QuoteCountArgs>(
      args?: Subset<T, QuoteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuoteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Quote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuoteAggregateArgs>(args: Subset<T, QuoteAggregateArgs>): Prisma.PrismaPromise<GetQuoteAggregateType<T>>

    /**
     * Group by Quote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuoteGroupByArgs['orderBy'] }
        : { orderBy?: QuoteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuoteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuoteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Quote model
   */
  readonly fields: QuoteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Quote.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuoteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client<T extends Quote$clientArgs<ExtArgs> = {}>(args?: Subset<T, Quote$clientArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    items<T extends Quote$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Quote$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuoteItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    publicLinks<T extends Quote$publicLinksArgs<ExtArgs> = {}>(args?: Subset<T, Quote$publicLinksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotePublicLinkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    pdfs<T extends Quote$pdfsArgs<ExtArgs> = {}>(args?: Subset<T, Quote$pdfsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotePdfPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    acceptance<T extends Quote$acceptanceArgs<ExtArgs> = {}>(args?: Subset<T, Quote$acceptanceArgs<ExtArgs>>): Prisma__QuoteAcceptanceClient<$Result.GetResult<Prisma.$QuoteAcceptancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    variations<T extends Quote$variationsArgs<ExtArgs> = {}>(args?: Subset<T, Quote$variationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VariationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    versions<T extends Quote$versionsArgs<ExtArgs> = {}>(args?: Subset<T, Quote$versionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuoteVersionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Quote model
   */
  interface QuoteFieldRefs {
    readonly id: FieldRef<"Quote", 'String'>
    readonly orgId: FieldRef<"Quote", 'String'>
    readonly clientId: FieldRef<"Quote", 'String'>
    readonly title: FieldRef<"Quote", 'String'>
    readonly referenceNo: FieldRef<"Quote", 'String'>
    readonly projectAddress: FieldRef<"Quote", 'String'>
    readonly status: FieldRef<"Quote", 'QuoteStatus'>
    readonly currentVersion: FieldRef<"Quote", 'Int'>
    readonly sentAt: FieldRef<"Quote", 'DateTime'>
    readonly acceptedAt: FieldRef<"Quote", 'DateTime'>
    readonly vatMode: FieldRef<"Quote", 'VatMode'>
    readonly vatRateBps: FieldRef<"Quote", 'Int'>
    readonly depositType: FieldRef<"Quote", 'DepositType'>
    readonly depositAmountPence: FieldRef<"Quote", 'Int'>
    readonly depositPercentBps: FieldRef<"Quote", 'Int'>
    readonly paymentScheduleJson: FieldRef<"Quote", 'Json'>
    readonly showQtyToClient: FieldRef<"Quote", 'Boolean'>
    readonly showUnitRatesToClient: FieldRef<"Quote", 'Boolean'>
    readonly scopeOverviewJson: FieldRef<"Quote", 'Json'>
    readonly termsJson: FieldRef<"Quote", 'Json'>
    readonly estimatedStartDate: FieldRef<"Quote", 'DateTime'>
    readonly estimatedDurationWeeks: FieldRef<"Quote", 'Int'>
    readonly createdByUserId: FieldRef<"Quote", 'String'>
    readonly updatedByUserId: FieldRef<"Quote", 'String'>
    readonly createdAt: FieldRef<"Quote", 'DateTime'>
    readonly updatedAt: FieldRef<"Quote", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Quote findUnique
   */
  export type QuoteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quote
     */
    omit?: QuoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteInclude<ExtArgs> | null
    /**
     * Filter, which Quote to fetch.
     */
    where: QuoteWhereUniqueInput
  }

  /**
   * Quote findUniqueOrThrow
   */
  export type QuoteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quote
     */
    omit?: QuoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteInclude<ExtArgs> | null
    /**
     * Filter, which Quote to fetch.
     */
    where: QuoteWhereUniqueInput
  }

  /**
   * Quote findFirst
   */
  export type QuoteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quote
     */
    omit?: QuoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteInclude<ExtArgs> | null
    /**
     * Filter, which Quote to fetch.
     */
    where?: QuoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quotes to fetch.
     */
    orderBy?: QuoteOrderByWithRelationInput | QuoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Quotes.
     */
    cursor?: QuoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Quotes.
     */
    distinct?: QuoteScalarFieldEnum | QuoteScalarFieldEnum[]
  }

  /**
   * Quote findFirstOrThrow
   */
  export type QuoteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quote
     */
    omit?: QuoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteInclude<ExtArgs> | null
    /**
     * Filter, which Quote to fetch.
     */
    where?: QuoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quotes to fetch.
     */
    orderBy?: QuoteOrderByWithRelationInput | QuoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Quotes.
     */
    cursor?: QuoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Quotes.
     */
    distinct?: QuoteScalarFieldEnum | QuoteScalarFieldEnum[]
  }

  /**
   * Quote findMany
   */
  export type QuoteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quote
     */
    omit?: QuoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteInclude<ExtArgs> | null
    /**
     * Filter, which Quotes to fetch.
     */
    where?: QuoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quotes to fetch.
     */
    orderBy?: QuoteOrderByWithRelationInput | QuoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Quotes.
     */
    cursor?: QuoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quotes.
     */
    skip?: number
    distinct?: QuoteScalarFieldEnum | QuoteScalarFieldEnum[]
  }

  /**
   * Quote create
   */
  export type QuoteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quote
     */
    omit?: QuoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteInclude<ExtArgs> | null
    /**
     * The data needed to create a Quote.
     */
    data: XOR<QuoteCreateInput, QuoteUncheckedCreateInput>
  }

  /**
   * Quote createMany
   */
  export type QuoteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Quotes.
     */
    data: QuoteCreateManyInput | QuoteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Quote createManyAndReturn
   */
  export type QuoteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Quote
     */
    omit?: QuoteOmit<ExtArgs> | null
    /**
     * The data used to create many Quotes.
     */
    data: QuoteCreateManyInput | QuoteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Quote update
   */
  export type QuoteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quote
     */
    omit?: QuoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteInclude<ExtArgs> | null
    /**
     * The data needed to update a Quote.
     */
    data: XOR<QuoteUpdateInput, QuoteUncheckedUpdateInput>
    /**
     * Choose, which Quote to update.
     */
    where: QuoteWhereUniqueInput
  }

  /**
   * Quote updateMany
   */
  export type QuoteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Quotes.
     */
    data: XOR<QuoteUpdateManyMutationInput, QuoteUncheckedUpdateManyInput>
    /**
     * Filter which Quotes to update
     */
    where?: QuoteWhereInput
    /**
     * Limit how many Quotes to update.
     */
    limit?: number
  }

  /**
   * Quote updateManyAndReturn
   */
  export type QuoteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Quote
     */
    omit?: QuoteOmit<ExtArgs> | null
    /**
     * The data used to update Quotes.
     */
    data: XOR<QuoteUpdateManyMutationInput, QuoteUncheckedUpdateManyInput>
    /**
     * Filter which Quotes to update
     */
    where?: QuoteWhereInput
    /**
     * Limit how many Quotes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Quote upsert
   */
  export type QuoteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quote
     */
    omit?: QuoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteInclude<ExtArgs> | null
    /**
     * The filter to search for the Quote to update in case it exists.
     */
    where: QuoteWhereUniqueInput
    /**
     * In case the Quote found by the `where` argument doesn't exist, create a new Quote with this data.
     */
    create: XOR<QuoteCreateInput, QuoteUncheckedCreateInput>
    /**
     * In case the Quote was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuoteUpdateInput, QuoteUncheckedUpdateInput>
  }

  /**
   * Quote delete
   */
  export type QuoteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quote
     */
    omit?: QuoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteInclude<ExtArgs> | null
    /**
     * Filter which Quote to delete.
     */
    where: QuoteWhereUniqueInput
  }

  /**
   * Quote deleteMany
   */
  export type QuoteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Quotes to delete
     */
    where?: QuoteWhereInput
    /**
     * Limit how many Quotes to delete.
     */
    limit?: number
  }

  /**
   * Quote.client
   */
  export type Quote$clientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    where?: ClientWhereInput
  }

  /**
   * Quote.items
   */
  export type Quote$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteItem
     */
    select?: QuoteItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuoteItem
     */
    omit?: QuoteItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteItemInclude<ExtArgs> | null
    where?: QuoteItemWhereInput
    orderBy?: QuoteItemOrderByWithRelationInput | QuoteItemOrderByWithRelationInput[]
    cursor?: QuoteItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuoteItemScalarFieldEnum | QuoteItemScalarFieldEnum[]
  }

  /**
   * Quote.publicLinks
   */
  export type Quote$publicLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotePublicLink
     */
    select?: QuotePublicLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuotePublicLink
     */
    omit?: QuotePublicLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotePublicLinkInclude<ExtArgs> | null
    where?: QuotePublicLinkWhereInput
    orderBy?: QuotePublicLinkOrderByWithRelationInput | QuotePublicLinkOrderByWithRelationInput[]
    cursor?: QuotePublicLinkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuotePublicLinkScalarFieldEnum | QuotePublicLinkScalarFieldEnum[]
  }

  /**
   * Quote.pdfs
   */
  export type Quote$pdfsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotePdf
     */
    select?: QuotePdfSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuotePdf
     */
    omit?: QuotePdfOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotePdfInclude<ExtArgs> | null
    where?: QuotePdfWhereInput
    orderBy?: QuotePdfOrderByWithRelationInput | QuotePdfOrderByWithRelationInput[]
    cursor?: QuotePdfWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuotePdfScalarFieldEnum | QuotePdfScalarFieldEnum[]
  }

  /**
   * Quote.acceptance
   */
  export type Quote$acceptanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteAcceptance
     */
    select?: QuoteAcceptanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuoteAcceptance
     */
    omit?: QuoteAcceptanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteAcceptanceInclude<ExtArgs> | null
    where?: QuoteAcceptanceWhereInput
  }

  /**
   * Quote.variations
   */
  export type Quote$variationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Variation
     */
    select?: VariationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Variation
     */
    omit?: VariationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariationInclude<ExtArgs> | null
    where?: VariationWhereInput
    orderBy?: VariationOrderByWithRelationInput | VariationOrderByWithRelationInput[]
    cursor?: VariationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VariationScalarFieldEnum | VariationScalarFieldEnum[]
  }

  /**
   * Quote.versions
   */
  export type Quote$versionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteVersion
     */
    select?: QuoteVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuoteVersion
     */
    omit?: QuoteVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteVersionInclude<ExtArgs> | null
    where?: QuoteVersionWhereInput
    orderBy?: QuoteVersionOrderByWithRelationInput | QuoteVersionOrderByWithRelationInput[]
    cursor?: QuoteVersionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuoteVersionScalarFieldEnum | QuoteVersionScalarFieldEnum[]
  }

  /**
   * Quote without action
   */
  export type QuoteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quote
     */
    select?: QuoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quote
     */
    omit?: QuoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteInclude<ExtArgs> | null
  }


  /**
   * Model QuoteItem
   */

  export type AggregateQuoteItem = {
    _count: QuoteItemCountAggregateOutputType | null
    _avg: QuoteItemAvgAggregateOutputType | null
    _sum: QuoteItemSumAggregateOutputType | null
    _min: QuoteItemMinAggregateOutputType | null
    _max: QuoteItemMaxAggregateOutputType | null
  }

  export type QuoteItemAvgAggregateOutputType = {
    sortOrder: number | null
    qty: Decimal | null
    unitPricePence: number | null
    hours: Decimal | null
    hourlyRatePence: number | null
    sellPricePence: number | null
    costPence: number | null
    markupPercentBps: number | null
  }

  export type QuoteItemSumAggregateOutputType = {
    sortOrder: number | null
    qty: Decimal | null
    unitPricePence: number | null
    hours: Decimal | null
    hourlyRatePence: number | null
    sellPricePence: number | null
    costPence: number | null
    markupPercentBps: number | null
  }

  export type QuoteItemMinAggregateOutputType = {
    id: string | null
    orgId: string | null
    quoteId: string | null
    parentId: string | null
    rowType: $Enums.ItemRowType | null
    title: string | null
    description: string | null
    sortOrder: number | null
    roomTag: string | null
    tradeTag: string | null
    phaseTag: string | null
    calcType: $Enums.CalcType | null
    qty: Decimal | null
    unit: string | null
    unitPricePence: number | null
    hours: Decimal | null
    hourlyRatePence: number | null
    sellPricePence: number | null
    isAllowance: boolean | null
    costPence: number | null
    markupPercentBps: number | null
    createdByUserId: string | null
    updatedByUserId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuoteItemMaxAggregateOutputType = {
    id: string | null
    orgId: string | null
    quoteId: string | null
    parentId: string | null
    rowType: $Enums.ItemRowType | null
    title: string | null
    description: string | null
    sortOrder: number | null
    roomTag: string | null
    tradeTag: string | null
    phaseTag: string | null
    calcType: $Enums.CalcType | null
    qty: Decimal | null
    unit: string | null
    unitPricePence: number | null
    hours: Decimal | null
    hourlyRatePence: number | null
    sellPricePence: number | null
    isAllowance: boolean | null
    costPence: number | null
    markupPercentBps: number | null
    createdByUserId: string | null
    updatedByUserId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuoteItemCountAggregateOutputType = {
    id: number
    orgId: number
    quoteId: number
    parentId: number
    rowType: number
    title: number
    description: number
    sortOrder: number
    roomTag: number
    tradeTag: number
    phaseTag: number
    calcType: number
    qty: number
    unit: number
    unitPricePence: number
    hours: number
    hourlyRatePence: number
    sellPricePence: number
    isAllowance: number
    costPence: number
    markupPercentBps: number
    createdByUserId: number
    updatedByUserId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type QuoteItemAvgAggregateInputType = {
    sortOrder?: true
    qty?: true
    unitPricePence?: true
    hours?: true
    hourlyRatePence?: true
    sellPricePence?: true
    costPence?: true
    markupPercentBps?: true
  }

  export type QuoteItemSumAggregateInputType = {
    sortOrder?: true
    qty?: true
    unitPricePence?: true
    hours?: true
    hourlyRatePence?: true
    sellPricePence?: true
    costPence?: true
    markupPercentBps?: true
  }

  export type QuoteItemMinAggregateInputType = {
    id?: true
    orgId?: true
    quoteId?: true
    parentId?: true
    rowType?: true
    title?: true
    description?: true
    sortOrder?: true
    roomTag?: true
    tradeTag?: true
    phaseTag?: true
    calcType?: true
    qty?: true
    unit?: true
    unitPricePence?: true
    hours?: true
    hourlyRatePence?: true
    sellPricePence?: true
    isAllowance?: true
    costPence?: true
    markupPercentBps?: true
    createdByUserId?: true
    updatedByUserId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuoteItemMaxAggregateInputType = {
    id?: true
    orgId?: true
    quoteId?: true
    parentId?: true
    rowType?: true
    title?: true
    description?: true
    sortOrder?: true
    roomTag?: true
    tradeTag?: true
    phaseTag?: true
    calcType?: true
    qty?: true
    unit?: true
    unitPricePence?: true
    hours?: true
    hourlyRatePence?: true
    sellPricePence?: true
    isAllowance?: true
    costPence?: true
    markupPercentBps?: true
    createdByUserId?: true
    updatedByUserId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuoteItemCountAggregateInputType = {
    id?: true
    orgId?: true
    quoteId?: true
    parentId?: true
    rowType?: true
    title?: true
    description?: true
    sortOrder?: true
    roomTag?: true
    tradeTag?: true
    phaseTag?: true
    calcType?: true
    qty?: true
    unit?: true
    unitPricePence?: true
    hours?: true
    hourlyRatePence?: true
    sellPricePence?: true
    isAllowance?: true
    costPence?: true
    markupPercentBps?: true
    createdByUserId?: true
    updatedByUserId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type QuoteItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuoteItem to aggregate.
     */
    where?: QuoteItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuoteItems to fetch.
     */
    orderBy?: QuoteItemOrderByWithRelationInput | QuoteItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuoteItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuoteItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuoteItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuoteItems
    **/
    _count?: true | QuoteItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuoteItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuoteItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuoteItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuoteItemMaxAggregateInputType
  }

  export type GetQuoteItemAggregateType<T extends QuoteItemAggregateArgs> = {
        [P in keyof T & keyof AggregateQuoteItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuoteItem[P]>
      : GetScalarType<T[P], AggregateQuoteItem[P]>
  }




  export type QuoteItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuoteItemWhereInput
    orderBy?: QuoteItemOrderByWithAggregationInput | QuoteItemOrderByWithAggregationInput[]
    by: QuoteItemScalarFieldEnum[] | QuoteItemScalarFieldEnum
    having?: QuoteItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuoteItemCountAggregateInputType | true
    _avg?: QuoteItemAvgAggregateInputType
    _sum?: QuoteItemSumAggregateInputType
    _min?: QuoteItemMinAggregateInputType
    _max?: QuoteItemMaxAggregateInputType
  }

  export type QuoteItemGroupByOutputType = {
    id: string
    orgId: string
    quoteId: string
    parentId: string | null
    rowType: $Enums.ItemRowType
    title: string
    description: string | null
    sortOrder: number
    roomTag: string | null
    tradeTag: string | null
    phaseTag: string | null
    calcType: $Enums.CalcType
    qty: Decimal | null
    unit: string | null
    unitPricePence: number | null
    hours: Decimal | null
    hourlyRatePence: number | null
    sellPricePence: number | null
    isAllowance: boolean
    costPence: number | null
    markupPercentBps: number | null
    createdByUserId: string | null
    updatedByUserId: string | null
    createdAt: Date
    updatedAt: Date
    _count: QuoteItemCountAggregateOutputType | null
    _avg: QuoteItemAvgAggregateOutputType | null
    _sum: QuoteItemSumAggregateOutputType | null
    _min: QuoteItemMinAggregateOutputType | null
    _max: QuoteItemMaxAggregateOutputType | null
  }

  type GetQuoteItemGroupByPayload<T extends QuoteItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuoteItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuoteItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuoteItemGroupByOutputType[P]>
            : GetScalarType<T[P], QuoteItemGroupByOutputType[P]>
        }
      >
    >


  export type QuoteItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    quoteId?: boolean
    parentId?: boolean
    rowType?: boolean
    title?: boolean
    description?: boolean
    sortOrder?: boolean
    roomTag?: boolean
    tradeTag?: boolean
    phaseTag?: boolean
    calcType?: boolean
    qty?: boolean
    unit?: boolean
    unitPricePence?: boolean
    hours?: boolean
    hourlyRatePence?: boolean
    sellPricePence?: boolean
    isAllowance?: boolean
    costPence?: boolean
    markupPercentBps?: boolean
    createdByUserId?: boolean
    updatedByUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    quote?: boolean | QuoteDefaultArgs<ExtArgs>
    parent?: boolean | QuoteItem$parentArgs<ExtArgs>
    children?: boolean | QuoteItem$childrenArgs<ExtArgs>
    _count?: boolean | QuoteItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quoteItem"]>

  export type QuoteItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    quoteId?: boolean
    parentId?: boolean
    rowType?: boolean
    title?: boolean
    description?: boolean
    sortOrder?: boolean
    roomTag?: boolean
    tradeTag?: boolean
    phaseTag?: boolean
    calcType?: boolean
    qty?: boolean
    unit?: boolean
    unitPricePence?: boolean
    hours?: boolean
    hourlyRatePence?: boolean
    sellPricePence?: boolean
    isAllowance?: boolean
    costPence?: boolean
    markupPercentBps?: boolean
    createdByUserId?: boolean
    updatedByUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    quote?: boolean | QuoteDefaultArgs<ExtArgs>
    parent?: boolean | QuoteItem$parentArgs<ExtArgs>
  }, ExtArgs["result"]["quoteItem"]>

  export type QuoteItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    quoteId?: boolean
    parentId?: boolean
    rowType?: boolean
    title?: boolean
    description?: boolean
    sortOrder?: boolean
    roomTag?: boolean
    tradeTag?: boolean
    phaseTag?: boolean
    calcType?: boolean
    qty?: boolean
    unit?: boolean
    unitPricePence?: boolean
    hours?: boolean
    hourlyRatePence?: boolean
    sellPricePence?: boolean
    isAllowance?: boolean
    costPence?: boolean
    markupPercentBps?: boolean
    createdByUserId?: boolean
    updatedByUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    quote?: boolean | QuoteDefaultArgs<ExtArgs>
    parent?: boolean | QuoteItem$parentArgs<ExtArgs>
  }, ExtArgs["result"]["quoteItem"]>

  export type QuoteItemSelectScalar = {
    id?: boolean
    orgId?: boolean
    quoteId?: boolean
    parentId?: boolean
    rowType?: boolean
    title?: boolean
    description?: boolean
    sortOrder?: boolean
    roomTag?: boolean
    tradeTag?: boolean
    phaseTag?: boolean
    calcType?: boolean
    qty?: boolean
    unit?: boolean
    unitPricePence?: boolean
    hours?: boolean
    hourlyRatePence?: boolean
    sellPricePence?: boolean
    isAllowance?: boolean
    costPence?: boolean
    markupPercentBps?: boolean
    createdByUserId?: boolean
    updatedByUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type QuoteItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orgId" | "quoteId" | "parentId" | "rowType" | "title" | "description" | "sortOrder" | "roomTag" | "tradeTag" | "phaseTag" | "calcType" | "qty" | "unit" | "unitPricePence" | "hours" | "hourlyRatePence" | "sellPricePence" | "isAllowance" | "costPence" | "markupPercentBps" | "createdByUserId" | "updatedByUserId" | "createdAt" | "updatedAt", ExtArgs["result"]["quoteItem"]>
  export type QuoteItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quote?: boolean | QuoteDefaultArgs<ExtArgs>
    parent?: boolean | QuoteItem$parentArgs<ExtArgs>
    children?: boolean | QuoteItem$childrenArgs<ExtArgs>
    _count?: boolean | QuoteItemCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type QuoteItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quote?: boolean | QuoteDefaultArgs<ExtArgs>
    parent?: boolean | QuoteItem$parentArgs<ExtArgs>
  }
  export type QuoteItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quote?: boolean | QuoteDefaultArgs<ExtArgs>
    parent?: boolean | QuoteItem$parentArgs<ExtArgs>
  }

  export type $QuoteItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QuoteItem"
    objects: {
      quote: Prisma.$QuotePayload<ExtArgs>
      parent: Prisma.$QuoteItemPayload<ExtArgs> | null
      children: Prisma.$QuoteItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orgId: string
      quoteId: string
      parentId: string | null
      rowType: $Enums.ItemRowType
      title: string
      description: string | null
      sortOrder: number
      roomTag: string | null
      tradeTag: string | null
      phaseTag: string | null
      calcType: $Enums.CalcType
      qty: Prisma.Decimal | null
      unit: string | null
      unitPricePence: number | null
      hours: Prisma.Decimal | null
      hourlyRatePence: number | null
      sellPricePence: number | null
      isAllowance: boolean
      costPence: number | null
      markupPercentBps: number | null
      createdByUserId: string | null
      updatedByUserId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["quoteItem"]>
    composites: {}
  }

  type QuoteItemGetPayload<S extends boolean | null | undefined | QuoteItemDefaultArgs> = $Result.GetResult<Prisma.$QuoteItemPayload, S>

  type QuoteItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QuoteItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuoteItemCountAggregateInputType | true
    }

  export interface QuoteItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QuoteItem'], meta: { name: 'QuoteItem' } }
    /**
     * Find zero or one QuoteItem that matches the filter.
     * @param {QuoteItemFindUniqueArgs} args - Arguments to find a QuoteItem
     * @example
     * // Get one QuoteItem
     * const quoteItem = await prisma.quoteItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuoteItemFindUniqueArgs>(args: SelectSubset<T, QuoteItemFindUniqueArgs<ExtArgs>>): Prisma__QuoteItemClient<$Result.GetResult<Prisma.$QuoteItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one QuoteItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QuoteItemFindUniqueOrThrowArgs} args - Arguments to find a QuoteItem
     * @example
     * // Get one QuoteItem
     * const quoteItem = await prisma.quoteItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuoteItemFindUniqueOrThrowArgs>(args: SelectSubset<T, QuoteItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuoteItemClient<$Result.GetResult<Prisma.$QuoteItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuoteItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteItemFindFirstArgs} args - Arguments to find a QuoteItem
     * @example
     * // Get one QuoteItem
     * const quoteItem = await prisma.quoteItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuoteItemFindFirstArgs>(args?: SelectSubset<T, QuoteItemFindFirstArgs<ExtArgs>>): Prisma__QuoteItemClient<$Result.GetResult<Prisma.$QuoteItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuoteItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteItemFindFirstOrThrowArgs} args - Arguments to find a QuoteItem
     * @example
     * // Get one QuoteItem
     * const quoteItem = await prisma.quoteItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuoteItemFindFirstOrThrowArgs>(args?: SelectSubset<T, QuoteItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuoteItemClient<$Result.GetResult<Prisma.$QuoteItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more QuoteItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuoteItems
     * const quoteItems = await prisma.quoteItem.findMany()
     * 
     * // Get first 10 QuoteItems
     * const quoteItems = await prisma.quoteItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quoteItemWithIdOnly = await prisma.quoteItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuoteItemFindManyArgs>(args?: SelectSubset<T, QuoteItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuoteItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a QuoteItem.
     * @param {QuoteItemCreateArgs} args - Arguments to create a QuoteItem.
     * @example
     * // Create one QuoteItem
     * const QuoteItem = await prisma.quoteItem.create({
     *   data: {
     *     // ... data to create a QuoteItem
     *   }
     * })
     * 
     */
    create<T extends QuoteItemCreateArgs>(args: SelectSubset<T, QuoteItemCreateArgs<ExtArgs>>): Prisma__QuoteItemClient<$Result.GetResult<Prisma.$QuoteItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many QuoteItems.
     * @param {QuoteItemCreateManyArgs} args - Arguments to create many QuoteItems.
     * @example
     * // Create many QuoteItems
     * const quoteItem = await prisma.quoteItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuoteItemCreateManyArgs>(args?: SelectSubset<T, QuoteItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QuoteItems and returns the data saved in the database.
     * @param {QuoteItemCreateManyAndReturnArgs} args - Arguments to create many QuoteItems.
     * @example
     * // Create many QuoteItems
     * const quoteItem = await prisma.quoteItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QuoteItems and only return the `id`
     * const quoteItemWithIdOnly = await prisma.quoteItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuoteItemCreateManyAndReturnArgs>(args?: SelectSubset<T, QuoteItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuoteItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a QuoteItem.
     * @param {QuoteItemDeleteArgs} args - Arguments to delete one QuoteItem.
     * @example
     * // Delete one QuoteItem
     * const QuoteItem = await prisma.quoteItem.delete({
     *   where: {
     *     // ... filter to delete one QuoteItem
     *   }
     * })
     * 
     */
    delete<T extends QuoteItemDeleteArgs>(args: SelectSubset<T, QuoteItemDeleteArgs<ExtArgs>>): Prisma__QuoteItemClient<$Result.GetResult<Prisma.$QuoteItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one QuoteItem.
     * @param {QuoteItemUpdateArgs} args - Arguments to update one QuoteItem.
     * @example
     * // Update one QuoteItem
     * const quoteItem = await prisma.quoteItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuoteItemUpdateArgs>(args: SelectSubset<T, QuoteItemUpdateArgs<ExtArgs>>): Prisma__QuoteItemClient<$Result.GetResult<Prisma.$QuoteItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more QuoteItems.
     * @param {QuoteItemDeleteManyArgs} args - Arguments to filter QuoteItems to delete.
     * @example
     * // Delete a few QuoteItems
     * const { count } = await prisma.quoteItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuoteItemDeleteManyArgs>(args?: SelectSubset<T, QuoteItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuoteItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuoteItems
     * const quoteItem = await prisma.quoteItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuoteItemUpdateManyArgs>(args: SelectSubset<T, QuoteItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuoteItems and returns the data updated in the database.
     * @param {QuoteItemUpdateManyAndReturnArgs} args - Arguments to update many QuoteItems.
     * @example
     * // Update many QuoteItems
     * const quoteItem = await prisma.quoteItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more QuoteItems and only return the `id`
     * const quoteItemWithIdOnly = await prisma.quoteItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QuoteItemUpdateManyAndReturnArgs>(args: SelectSubset<T, QuoteItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuoteItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one QuoteItem.
     * @param {QuoteItemUpsertArgs} args - Arguments to update or create a QuoteItem.
     * @example
     * // Update or create a QuoteItem
     * const quoteItem = await prisma.quoteItem.upsert({
     *   create: {
     *     // ... data to create a QuoteItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuoteItem we want to update
     *   }
     * })
     */
    upsert<T extends QuoteItemUpsertArgs>(args: SelectSubset<T, QuoteItemUpsertArgs<ExtArgs>>): Prisma__QuoteItemClient<$Result.GetResult<Prisma.$QuoteItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of QuoteItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteItemCountArgs} args - Arguments to filter QuoteItems to count.
     * @example
     * // Count the number of QuoteItems
     * const count = await prisma.quoteItem.count({
     *   where: {
     *     // ... the filter for the QuoteItems we want to count
     *   }
     * })
    **/
    count<T extends QuoteItemCountArgs>(
      args?: Subset<T, QuoteItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuoteItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuoteItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuoteItemAggregateArgs>(args: Subset<T, QuoteItemAggregateArgs>): Prisma.PrismaPromise<GetQuoteItemAggregateType<T>>

    /**
     * Group by QuoteItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuoteItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuoteItemGroupByArgs['orderBy'] }
        : { orderBy?: QuoteItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuoteItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuoteItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QuoteItem model
   */
  readonly fields: QuoteItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QuoteItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuoteItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    quote<T extends QuoteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuoteDefaultArgs<ExtArgs>>): Prisma__QuoteClient<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    parent<T extends QuoteItem$parentArgs<ExtArgs> = {}>(args?: Subset<T, QuoteItem$parentArgs<ExtArgs>>): Prisma__QuoteItemClient<$Result.GetResult<Prisma.$QuoteItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    children<T extends QuoteItem$childrenArgs<ExtArgs> = {}>(args?: Subset<T, QuoteItem$childrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuoteItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QuoteItem model
   */
  interface QuoteItemFieldRefs {
    readonly id: FieldRef<"QuoteItem", 'String'>
    readonly orgId: FieldRef<"QuoteItem", 'String'>
    readonly quoteId: FieldRef<"QuoteItem", 'String'>
    readonly parentId: FieldRef<"QuoteItem", 'String'>
    readonly rowType: FieldRef<"QuoteItem", 'ItemRowType'>
    readonly title: FieldRef<"QuoteItem", 'String'>
    readonly description: FieldRef<"QuoteItem", 'String'>
    readonly sortOrder: FieldRef<"QuoteItem", 'Int'>
    readonly roomTag: FieldRef<"QuoteItem", 'String'>
    readonly tradeTag: FieldRef<"QuoteItem", 'String'>
    readonly phaseTag: FieldRef<"QuoteItem", 'String'>
    readonly calcType: FieldRef<"QuoteItem", 'CalcType'>
    readonly qty: FieldRef<"QuoteItem", 'Decimal'>
    readonly unit: FieldRef<"QuoteItem", 'String'>
    readonly unitPricePence: FieldRef<"QuoteItem", 'Int'>
    readonly hours: FieldRef<"QuoteItem", 'Decimal'>
    readonly hourlyRatePence: FieldRef<"QuoteItem", 'Int'>
    readonly sellPricePence: FieldRef<"QuoteItem", 'Int'>
    readonly isAllowance: FieldRef<"QuoteItem", 'Boolean'>
    readonly costPence: FieldRef<"QuoteItem", 'Int'>
    readonly markupPercentBps: FieldRef<"QuoteItem", 'Int'>
    readonly createdByUserId: FieldRef<"QuoteItem", 'String'>
    readonly updatedByUserId: FieldRef<"QuoteItem", 'String'>
    readonly createdAt: FieldRef<"QuoteItem", 'DateTime'>
    readonly updatedAt: FieldRef<"QuoteItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * QuoteItem findUnique
   */
  export type QuoteItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteItem
     */
    select?: QuoteItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuoteItem
     */
    omit?: QuoteItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteItemInclude<ExtArgs> | null
    /**
     * Filter, which QuoteItem to fetch.
     */
    where: QuoteItemWhereUniqueInput
  }

  /**
   * QuoteItem findUniqueOrThrow
   */
  export type QuoteItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteItem
     */
    select?: QuoteItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuoteItem
     */
    omit?: QuoteItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteItemInclude<ExtArgs> | null
    /**
     * Filter, which QuoteItem to fetch.
     */
    where: QuoteItemWhereUniqueInput
  }

  /**
   * QuoteItem findFirst
   */
  export type QuoteItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteItem
     */
    select?: QuoteItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuoteItem
     */
    omit?: QuoteItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteItemInclude<ExtArgs> | null
    /**
     * Filter, which QuoteItem to fetch.
     */
    where?: QuoteItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuoteItems to fetch.
     */
    orderBy?: QuoteItemOrderByWithRelationInput | QuoteItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuoteItems.
     */
    cursor?: QuoteItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuoteItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuoteItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuoteItems.
     */
    distinct?: QuoteItemScalarFieldEnum | QuoteItemScalarFieldEnum[]
  }

  /**
   * QuoteItem findFirstOrThrow
   */
  export type QuoteItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteItem
     */
    select?: QuoteItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuoteItem
     */
    omit?: QuoteItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteItemInclude<ExtArgs> | null
    /**
     * Filter, which QuoteItem to fetch.
     */
    where?: QuoteItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuoteItems to fetch.
     */
    orderBy?: QuoteItemOrderByWithRelationInput | QuoteItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuoteItems.
     */
    cursor?: QuoteItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuoteItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuoteItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuoteItems.
     */
    distinct?: QuoteItemScalarFieldEnum | QuoteItemScalarFieldEnum[]
  }

  /**
   * QuoteItem findMany
   */
  export type QuoteItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteItem
     */
    select?: QuoteItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuoteItem
     */
    omit?: QuoteItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteItemInclude<ExtArgs> | null
    /**
     * Filter, which QuoteItems to fetch.
     */
    where?: QuoteItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuoteItems to fetch.
     */
    orderBy?: QuoteItemOrderByWithRelationInput | QuoteItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuoteItems.
     */
    cursor?: QuoteItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuoteItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuoteItems.
     */
    skip?: number
    distinct?: QuoteItemScalarFieldEnum | QuoteItemScalarFieldEnum[]
  }

  /**
   * QuoteItem create
   */
  export type QuoteItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteItem
     */
    select?: QuoteItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuoteItem
     */
    omit?: QuoteItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteItemInclude<ExtArgs> | null
    /**
     * The data needed to create a QuoteItem.
     */
    data: XOR<QuoteItemCreateInput, QuoteItemUncheckedCreateInput>
  }

  /**
   * QuoteItem createMany
   */
  export type QuoteItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QuoteItems.
     */
    data: QuoteItemCreateManyInput | QuoteItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QuoteItem createManyAndReturn
   */
  export type QuoteItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteItem
     */
    select?: QuoteItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuoteItem
     */
    omit?: QuoteItemOmit<ExtArgs> | null
    /**
     * The data used to create many QuoteItems.
     */
    data: QuoteItemCreateManyInput | QuoteItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuoteItem update
   */
  export type QuoteItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteItem
     */
    select?: QuoteItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuoteItem
     */
    omit?: QuoteItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteItemInclude<ExtArgs> | null
    /**
     * The data needed to update a QuoteItem.
     */
    data: XOR<QuoteItemUpdateInput, QuoteItemUncheckedUpdateInput>
    /**
     * Choose, which QuoteItem to update.
     */
    where: QuoteItemWhereUniqueInput
  }

  /**
   * QuoteItem updateMany
   */
  export type QuoteItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QuoteItems.
     */
    data: XOR<QuoteItemUpdateManyMutationInput, QuoteItemUncheckedUpdateManyInput>
    /**
     * Filter which QuoteItems to update
     */
    where?: QuoteItemWhereInput
    /**
     * Limit how many QuoteItems to update.
     */
    limit?: number
  }

  /**
   * QuoteItem updateManyAndReturn
   */
  export type QuoteItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteItem
     */
    select?: QuoteItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuoteItem
     */
    omit?: QuoteItemOmit<ExtArgs> | null
    /**
     * The data used to update QuoteItems.
     */
    data: XOR<QuoteItemUpdateManyMutationInput, QuoteItemUncheckedUpdateManyInput>
    /**
     * Filter which QuoteItems to update
     */
    where?: QuoteItemWhereInput
    /**
     * Limit how many QuoteItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuoteItem upsert
   */
  export type QuoteItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteItem
     */
    select?: QuoteItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuoteItem
     */
    omit?: QuoteItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteItemInclude<ExtArgs> | null
    /**
     * The filter to search for the QuoteItem to update in case it exists.
     */
    where: QuoteItemWhereUniqueInput
    /**
     * In case the QuoteItem found by the `where` argument doesn't exist, create a new QuoteItem with this data.
     */
    create: XOR<QuoteItemCreateInput, QuoteItemUncheckedCreateInput>
    /**
     * In case the QuoteItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuoteItemUpdateInput, QuoteItemUncheckedUpdateInput>
  }

  /**
   * QuoteItem delete
   */
  export type QuoteItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteItem
     */
    select?: QuoteItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuoteItem
     */
    omit?: QuoteItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteItemInclude<ExtArgs> | null
    /**
     * Filter which QuoteItem to delete.
     */
    where: QuoteItemWhereUniqueInput
  }

  /**
   * QuoteItem deleteMany
   */
  export type QuoteItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuoteItems to delete
     */
    where?: QuoteItemWhereInput
    /**
     * Limit how many QuoteItems to delete.
     */
    limit?: number
  }

  /**
   * QuoteItem.parent
   */
  export type QuoteItem$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteItem
     */
    select?: QuoteItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuoteItem
     */
    omit?: QuoteItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteItemInclude<ExtArgs> | null
    where?: QuoteItemWhereInput
  }

  /**
   * QuoteItem.children
   */
  export type QuoteItem$childrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteItem
     */
    select?: QuoteItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuoteItem
     */
    omit?: QuoteItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteItemInclude<ExtArgs> | null
    where?: QuoteItemWhereInput
    orderBy?: QuoteItemOrderByWithRelationInput | QuoteItemOrderByWithRelationInput[]
    cursor?: QuoteItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuoteItemScalarFieldEnum | QuoteItemScalarFieldEnum[]
  }

  /**
   * QuoteItem without action
   */
  export type QuoteItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteItem
     */
    select?: QuoteItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuoteItem
     */
    omit?: QuoteItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteItemInclude<ExtArgs> | null
  }


  /**
   * Model QuoteVersion
   */

  export type AggregateQuoteVersion = {
    _count: QuoteVersionCountAggregateOutputType | null
    _avg: QuoteVersionAvgAggregateOutputType | null
    _sum: QuoteVersionSumAggregateOutputType | null
    _min: QuoteVersionMinAggregateOutputType | null
    _max: QuoteVersionMaxAggregateOutputType | null
  }

  export type QuoteVersionAvgAggregateOutputType = {
    version: number | null
    vatRateBps: number | null
    depositAmountPence: number | null
    depositPercentBps: number | null
    subtotalPence: number | null
    vatPence: number | null
    totalPence: number | null
  }

  export type QuoteVersionSumAggregateOutputType = {
    version: number | null
    vatRateBps: number | null
    depositAmountPence: number | null
    depositPercentBps: number | null
    subtotalPence: number | null
    vatPence: number | null
    totalPence: number | null
  }

  export type QuoteVersionMinAggregateOutputType = {
    id: string | null
    orgId: string | null
    quoteId: string | null
    version: number | null
    status: $Enums.QuoteStatus | null
    vatMode: $Enums.VatMode | null
    vatRateBps: number | null
    depositType: $Enums.DepositType | null
    depositAmountPence: number | null
    depositPercentBps: number | null
    showQtyToClient: boolean | null
    showUnitRatesToClient: boolean | null
    title: string | null
    referenceNo: string | null
    projectAddress: string | null
    subtotalPence: number | null
    vatPence: number | null
    totalPence: number | null
    sentAt: Date | null
    createdByUserId: string | null
    createdAt: Date | null
  }

  export type QuoteVersionMaxAggregateOutputType = {
    id: string | null
    orgId: string | null
    quoteId: string | null
    version: number | null
    status: $Enums.QuoteStatus | null
    vatMode: $Enums.VatMode | null
    vatRateBps: number | null
    depositType: $Enums.DepositType | null
    depositAmountPence: number | null
    depositPercentBps: number | null
    showQtyToClient: boolean | null
    showUnitRatesToClient: boolean | null
    title: string | null
    referenceNo: string | null
    projectAddress: string | null
    subtotalPence: number | null
    vatPence: number | null
    totalPence: number | null
    sentAt: Date | null
    createdByUserId: string | null
    createdAt: Date | null
  }

  export type QuoteVersionCountAggregateOutputType = {
    id: number
    orgId: number
    quoteId: number
    version: number
    status: number
    vatMode: number
    vatRateBps: number
    depositType: number
    depositAmountPence: number
    depositPercentBps: number
    showQtyToClient: number
    showUnitRatesToClient: number
    title: number
    referenceNo: number
    projectAddress: number
    scopeOverviewJson: number
    termsJson: number
    paymentScheduleJson: number
    subtotalPence: number
    vatPence: number
    totalPence: number
    sentAt: number
    createdByUserId: number
    createdAt: number
    _all: number
  }


  export type QuoteVersionAvgAggregateInputType = {
    version?: true
    vatRateBps?: true
    depositAmountPence?: true
    depositPercentBps?: true
    subtotalPence?: true
    vatPence?: true
    totalPence?: true
  }

  export type QuoteVersionSumAggregateInputType = {
    version?: true
    vatRateBps?: true
    depositAmountPence?: true
    depositPercentBps?: true
    subtotalPence?: true
    vatPence?: true
    totalPence?: true
  }

  export type QuoteVersionMinAggregateInputType = {
    id?: true
    orgId?: true
    quoteId?: true
    version?: true
    status?: true
    vatMode?: true
    vatRateBps?: true
    depositType?: true
    depositAmountPence?: true
    depositPercentBps?: true
    showQtyToClient?: true
    showUnitRatesToClient?: true
    title?: true
    referenceNo?: true
    projectAddress?: true
    subtotalPence?: true
    vatPence?: true
    totalPence?: true
    sentAt?: true
    createdByUserId?: true
    createdAt?: true
  }

  export type QuoteVersionMaxAggregateInputType = {
    id?: true
    orgId?: true
    quoteId?: true
    version?: true
    status?: true
    vatMode?: true
    vatRateBps?: true
    depositType?: true
    depositAmountPence?: true
    depositPercentBps?: true
    showQtyToClient?: true
    showUnitRatesToClient?: true
    title?: true
    referenceNo?: true
    projectAddress?: true
    subtotalPence?: true
    vatPence?: true
    totalPence?: true
    sentAt?: true
    createdByUserId?: true
    createdAt?: true
  }

  export type QuoteVersionCountAggregateInputType = {
    id?: true
    orgId?: true
    quoteId?: true
    version?: true
    status?: true
    vatMode?: true
    vatRateBps?: true
    depositType?: true
    depositAmountPence?: true
    depositPercentBps?: true
    showQtyToClient?: true
    showUnitRatesToClient?: true
    title?: true
    referenceNo?: true
    projectAddress?: true
    scopeOverviewJson?: true
    termsJson?: true
    paymentScheduleJson?: true
    subtotalPence?: true
    vatPence?: true
    totalPence?: true
    sentAt?: true
    createdByUserId?: true
    createdAt?: true
    _all?: true
  }

  export type QuoteVersionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuoteVersion to aggregate.
     */
    where?: QuoteVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuoteVersions to fetch.
     */
    orderBy?: QuoteVersionOrderByWithRelationInput | QuoteVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuoteVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuoteVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuoteVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuoteVersions
    **/
    _count?: true | QuoteVersionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuoteVersionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuoteVersionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuoteVersionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuoteVersionMaxAggregateInputType
  }

  export type GetQuoteVersionAggregateType<T extends QuoteVersionAggregateArgs> = {
        [P in keyof T & keyof AggregateQuoteVersion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuoteVersion[P]>
      : GetScalarType<T[P], AggregateQuoteVersion[P]>
  }




  export type QuoteVersionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuoteVersionWhereInput
    orderBy?: QuoteVersionOrderByWithAggregationInput | QuoteVersionOrderByWithAggregationInput[]
    by: QuoteVersionScalarFieldEnum[] | QuoteVersionScalarFieldEnum
    having?: QuoteVersionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuoteVersionCountAggregateInputType | true
    _avg?: QuoteVersionAvgAggregateInputType
    _sum?: QuoteVersionSumAggregateInputType
    _min?: QuoteVersionMinAggregateInputType
    _max?: QuoteVersionMaxAggregateInputType
  }

  export type QuoteVersionGroupByOutputType = {
    id: string
    orgId: string
    quoteId: string
    version: number
    status: $Enums.QuoteStatus
    vatMode: $Enums.VatMode
    vatRateBps: number
    depositType: $Enums.DepositType
    depositAmountPence: number | null
    depositPercentBps: number | null
    showQtyToClient: boolean
    showUnitRatesToClient: boolean
    title: string
    referenceNo: string | null
    projectAddress: string | null
    scopeOverviewJson: JsonValue | null
    termsJson: JsonValue | null
    paymentScheduleJson: JsonValue | null
    subtotalPence: number | null
    vatPence: number | null
    totalPence: number | null
    sentAt: Date | null
    createdByUserId: string | null
    createdAt: Date
    _count: QuoteVersionCountAggregateOutputType | null
    _avg: QuoteVersionAvgAggregateOutputType | null
    _sum: QuoteVersionSumAggregateOutputType | null
    _min: QuoteVersionMinAggregateOutputType | null
    _max: QuoteVersionMaxAggregateOutputType | null
  }

  type GetQuoteVersionGroupByPayload<T extends QuoteVersionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuoteVersionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuoteVersionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuoteVersionGroupByOutputType[P]>
            : GetScalarType<T[P], QuoteVersionGroupByOutputType[P]>
        }
      >
    >


  export type QuoteVersionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    quoteId?: boolean
    version?: boolean
    status?: boolean
    vatMode?: boolean
    vatRateBps?: boolean
    depositType?: boolean
    depositAmountPence?: boolean
    depositPercentBps?: boolean
    showQtyToClient?: boolean
    showUnitRatesToClient?: boolean
    title?: boolean
    referenceNo?: boolean
    projectAddress?: boolean
    scopeOverviewJson?: boolean
    termsJson?: boolean
    paymentScheduleJson?: boolean
    subtotalPence?: boolean
    vatPence?: boolean
    totalPence?: boolean
    sentAt?: boolean
    createdByUserId?: boolean
    createdAt?: boolean
    quote?: boolean | QuoteDefaultArgs<ExtArgs>
    items?: boolean | QuoteVersion$itemsArgs<ExtArgs>
    _count?: boolean | QuoteVersionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quoteVersion"]>

  export type QuoteVersionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    quoteId?: boolean
    version?: boolean
    status?: boolean
    vatMode?: boolean
    vatRateBps?: boolean
    depositType?: boolean
    depositAmountPence?: boolean
    depositPercentBps?: boolean
    showQtyToClient?: boolean
    showUnitRatesToClient?: boolean
    title?: boolean
    referenceNo?: boolean
    projectAddress?: boolean
    scopeOverviewJson?: boolean
    termsJson?: boolean
    paymentScheduleJson?: boolean
    subtotalPence?: boolean
    vatPence?: boolean
    totalPence?: boolean
    sentAt?: boolean
    createdByUserId?: boolean
    createdAt?: boolean
    quote?: boolean | QuoteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quoteVersion"]>

  export type QuoteVersionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    quoteId?: boolean
    version?: boolean
    status?: boolean
    vatMode?: boolean
    vatRateBps?: boolean
    depositType?: boolean
    depositAmountPence?: boolean
    depositPercentBps?: boolean
    showQtyToClient?: boolean
    showUnitRatesToClient?: boolean
    title?: boolean
    referenceNo?: boolean
    projectAddress?: boolean
    scopeOverviewJson?: boolean
    termsJson?: boolean
    paymentScheduleJson?: boolean
    subtotalPence?: boolean
    vatPence?: boolean
    totalPence?: boolean
    sentAt?: boolean
    createdByUserId?: boolean
    createdAt?: boolean
    quote?: boolean | QuoteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quoteVersion"]>

  export type QuoteVersionSelectScalar = {
    id?: boolean
    orgId?: boolean
    quoteId?: boolean
    version?: boolean
    status?: boolean
    vatMode?: boolean
    vatRateBps?: boolean
    depositType?: boolean
    depositAmountPence?: boolean
    depositPercentBps?: boolean
    showQtyToClient?: boolean
    showUnitRatesToClient?: boolean
    title?: boolean
    referenceNo?: boolean
    projectAddress?: boolean
    scopeOverviewJson?: boolean
    termsJson?: boolean
    paymentScheduleJson?: boolean
    subtotalPence?: boolean
    vatPence?: boolean
    totalPence?: boolean
    sentAt?: boolean
    createdByUserId?: boolean
    createdAt?: boolean
  }

  export type QuoteVersionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orgId" | "quoteId" | "version" | "status" | "vatMode" | "vatRateBps" | "depositType" | "depositAmountPence" | "depositPercentBps" | "showQtyToClient" | "showUnitRatesToClient" | "title" | "referenceNo" | "projectAddress" | "scopeOverviewJson" | "termsJson" | "paymentScheduleJson" | "subtotalPence" | "vatPence" | "totalPence" | "sentAt" | "createdByUserId" | "createdAt", ExtArgs["result"]["quoteVersion"]>
  export type QuoteVersionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quote?: boolean | QuoteDefaultArgs<ExtArgs>
    items?: boolean | QuoteVersion$itemsArgs<ExtArgs>
    _count?: boolean | QuoteVersionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type QuoteVersionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quote?: boolean | QuoteDefaultArgs<ExtArgs>
  }
  export type QuoteVersionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quote?: boolean | QuoteDefaultArgs<ExtArgs>
  }

  export type $QuoteVersionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QuoteVersion"
    objects: {
      quote: Prisma.$QuotePayload<ExtArgs>
      items: Prisma.$QuoteVersionItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orgId: string
      quoteId: string
      version: number
      status: $Enums.QuoteStatus
      vatMode: $Enums.VatMode
      vatRateBps: number
      depositType: $Enums.DepositType
      depositAmountPence: number | null
      depositPercentBps: number | null
      showQtyToClient: boolean
      showUnitRatesToClient: boolean
      title: string
      referenceNo: string | null
      projectAddress: string | null
      scopeOverviewJson: Prisma.JsonValue | null
      termsJson: Prisma.JsonValue | null
      paymentScheduleJson: Prisma.JsonValue | null
      subtotalPence: number | null
      vatPence: number | null
      totalPence: number | null
      sentAt: Date | null
      createdByUserId: string | null
      createdAt: Date
    }, ExtArgs["result"]["quoteVersion"]>
    composites: {}
  }

  type QuoteVersionGetPayload<S extends boolean | null | undefined | QuoteVersionDefaultArgs> = $Result.GetResult<Prisma.$QuoteVersionPayload, S>

  type QuoteVersionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QuoteVersionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuoteVersionCountAggregateInputType | true
    }

  export interface QuoteVersionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QuoteVersion'], meta: { name: 'QuoteVersion' } }
    /**
     * Find zero or one QuoteVersion that matches the filter.
     * @param {QuoteVersionFindUniqueArgs} args - Arguments to find a QuoteVersion
     * @example
     * // Get one QuoteVersion
     * const quoteVersion = await prisma.quoteVersion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuoteVersionFindUniqueArgs>(args: SelectSubset<T, QuoteVersionFindUniqueArgs<ExtArgs>>): Prisma__QuoteVersionClient<$Result.GetResult<Prisma.$QuoteVersionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one QuoteVersion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QuoteVersionFindUniqueOrThrowArgs} args - Arguments to find a QuoteVersion
     * @example
     * // Get one QuoteVersion
     * const quoteVersion = await prisma.quoteVersion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuoteVersionFindUniqueOrThrowArgs>(args: SelectSubset<T, QuoteVersionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuoteVersionClient<$Result.GetResult<Prisma.$QuoteVersionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuoteVersion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteVersionFindFirstArgs} args - Arguments to find a QuoteVersion
     * @example
     * // Get one QuoteVersion
     * const quoteVersion = await prisma.quoteVersion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuoteVersionFindFirstArgs>(args?: SelectSubset<T, QuoteVersionFindFirstArgs<ExtArgs>>): Prisma__QuoteVersionClient<$Result.GetResult<Prisma.$QuoteVersionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuoteVersion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteVersionFindFirstOrThrowArgs} args - Arguments to find a QuoteVersion
     * @example
     * // Get one QuoteVersion
     * const quoteVersion = await prisma.quoteVersion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuoteVersionFindFirstOrThrowArgs>(args?: SelectSubset<T, QuoteVersionFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuoteVersionClient<$Result.GetResult<Prisma.$QuoteVersionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more QuoteVersions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteVersionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuoteVersions
     * const quoteVersions = await prisma.quoteVersion.findMany()
     * 
     * // Get first 10 QuoteVersions
     * const quoteVersions = await prisma.quoteVersion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quoteVersionWithIdOnly = await prisma.quoteVersion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuoteVersionFindManyArgs>(args?: SelectSubset<T, QuoteVersionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuoteVersionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a QuoteVersion.
     * @param {QuoteVersionCreateArgs} args - Arguments to create a QuoteVersion.
     * @example
     * // Create one QuoteVersion
     * const QuoteVersion = await prisma.quoteVersion.create({
     *   data: {
     *     // ... data to create a QuoteVersion
     *   }
     * })
     * 
     */
    create<T extends QuoteVersionCreateArgs>(args: SelectSubset<T, QuoteVersionCreateArgs<ExtArgs>>): Prisma__QuoteVersionClient<$Result.GetResult<Prisma.$QuoteVersionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many QuoteVersions.
     * @param {QuoteVersionCreateManyArgs} args - Arguments to create many QuoteVersions.
     * @example
     * // Create many QuoteVersions
     * const quoteVersion = await prisma.quoteVersion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuoteVersionCreateManyArgs>(args?: SelectSubset<T, QuoteVersionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QuoteVersions and returns the data saved in the database.
     * @param {QuoteVersionCreateManyAndReturnArgs} args - Arguments to create many QuoteVersions.
     * @example
     * // Create many QuoteVersions
     * const quoteVersion = await prisma.quoteVersion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QuoteVersions and only return the `id`
     * const quoteVersionWithIdOnly = await prisma.quoteVersion.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuoteVersionCreateManyAndReturnArgs>(args?: SelectSubset<T, QuoteVersionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuoteVersionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a QuoteVersion.
     * @param {QuoteVersionDeleteArgs} args - Arguments to delete one QuoteVersion.
     * @example
     * // Delete one QuoteVersion
     * const QuoteVersion = await prisma.quoteVersion.delete({
     *   where: {
     *     // ... filter to delete one QuoteVersion
     *   }
     * })
     * 
     */
    delete<T extends QuoteVersionDeleteArgs>(args: SelectSubset<T, QuoteVersionDeleteArgs<ExtArgs>>): Prisma__QuoteVersionClient<$Result.GetResult<Prisma.$QuoteVersionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one QuoteVersion.
     * @param {QuoteVersionUpdateArgs} args - Arguments to update one QuoteVersion.
     * @example
     * // Update one QuoteVersion
     * const quoteVersion = await prisma.quoteVersion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuoteVersionUpdateArgs>(args: SelectSubset<T, QuoteVersionUpdateArgs<ExtArgs>>): Prisma__QuoteVersionClient<$Result.GetResult<Prisma.$QuoteVersionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more QuoteVersions.
     * @param {QuoteVersionDeleteManyArgs} args - Arguments to filter QuoteVersions to delete.
     * @example
     * // Delete a few QuoteVersions
     * const { count } = await prisma.quoteVersion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuoteVersionDeleteManyArgs>(args?: SelectSubset<T, QuoteVersionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuoteVersions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteVersionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuoteVersions
     * const quoteVersion = await prisma.quoteVersion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuoteVersionUpdateManyArgs>(args: SelectSubset<T, QuoteVersionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuoteVersions and returns the data updated in the database.
     * @param {QuoteVersionUpdateManyAndReturnArgs} args - Arguments to update many QuoteVersions.
     * @example
     * // Update many QuoteVersions
     * const quoteVersion = await prisma.quoteVersion.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more QuoteVersions and only return the `id`
     * const quoteVersionWithIdOnly = await prisma.quoteVersion.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QuoteVersionUpdateManyAndReturnArgs>(args: SelectSubset<T, QuoteVersionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuoteVersionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one QuoteVersion.
     * @param {QuoteVersionUpsertArgs} args - Arguments to update or create a QuoteVersion.
     * @example
     * // Update or create a QuoteVersion
     * const quoteVersion = await prisma.quoteVersion.upsert({
     *   create: {
     *     // ... data to create a QuoteVersion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuoteVersion we want to update
     *   }
     * })
     */
    upsert<T extends QuoteVersionUpsertArgs>(args: SelectSubset<T, QuoteVersionUpsertArgs<ExtArgs>>): Prisma__QuoteVersionClient<$Result.GetResult<Prisma.$QuoteVersionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of QuoteVersions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteVersionCountArgs} args - Arguments to filter QuoteVersions to count.
     * @example
     * // Count the number of QuoteVersions
     * const count = await prisma.quoteVersion.count({
     *   where: {
     *     // ... the filter for the QuoteVersions we want to count
     *   }
     * })
    **/
    count<T extends QuoteVersionCountArgs>(
      args?: Subset<T, QuoteVersionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuoteVersionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuoteVersion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteVersionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuoteVersionAggregateArgs>(args: Subset<T, QuoteVersionAggregateArgs>): Prisma.PrismaPromise<GetQuoteVersionAggregateType<T>>

    /**
     * Group by QuoteVersion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteVersionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuoteVersionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuoteVersionGroupByArgs['orderBy'] }
        : { orderBy?: QuoteVersionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuoteVersionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuoteVersionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QuoteVersion model
   */
  readonly fields: QuoteVersionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QuoteVersion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuoteVersionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    quote<T extends QuoteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuoteDefaultArgs<ExtArgs>>): Prisma__QuoteClient<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    items<T extends QuoteVersion$itemsArgs<ExtArgs> = {}>(args?: Subset<T, QuoteVersion$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuoteVersionItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QuoteVersion model
   */
  interface QuoteVersionFieldRefs {
    readonly id: FieldRef<"QuoteVersion", 'String'>
    readonly orgId: FieldRef<"QuoteVersion", 'String'>
    readonly quoteId: FieldRef<"QuoteVersion", 'String'>
    readonly version: FieldRef<"QuoteVersion", 'Int'>
    readonly status: FieldRef<"QuoteVersion", 'QuoteStatus'>
    readonly vatMode: FieldRef<"QuoteVersion", 'VatMode'>
    readonly vatRateBps: FieldRef<"QuoteVersion", 'Int'>
    readonly depositType: FieldRef<"QuoteVersion", 'DepositType'>
    readonly depositAmountPence: FieldRef<"QuoteVersion", 'Int'>
    readonly depositPercentBps: FieldRef<"QuoteVersion", 'Int'>
    readonly showQtyToClient: FieldRef<"QuoteVersion", 'Boolean'>
    readonly showUnitRatesToClient: FieldRef<"QuoteVersion", 'Boolean'>
    readonly title: FieldRef<"QuoteVersion", 'String'>
    readonly referenceNo: FieldRef<"QuoteVersion", 'String'>
    readonly projectAddress: FieldRef<"QuoteVersion", 'String'>
    readonly scopeOverviewJson: FieldRef<"QuoteVersion", 'Json'>
    readonly termsJson: FieldRef<"QuoteVersion", 'Json'>
    readonly paymentScheduleJson: FieldRef<"QuoteVersion", 'Json'>
    readonly subtotalPence: FieldRef<"QuoteVersion", 'Int'>
    readonly vatPence: FieldRef<"QuoteVersion", 'Int'>
    readonly totalPence: FieldRef<"QuoteVersion", 'Int'>
    readonly sentAt: FieldRef<"QuoteVersion", 'DateTime'>
    readonly createdByUserId: FieldRef<"QuoteVersion", 'String'>
    readonly createdAt: FieldRef<"QuoteVersion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * QuoteVersion findUnique
   */
  export type QuoteVersionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteVersion
     */
    select?: QuoteVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuoteVersion
     */
    omit?: QuoteVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteVersionInclude<ExtArgs> | null
    /**
     * Filter, which QuoteVersion to fetch.
     */
    where: QuoteVersionWhereUniqueInput
  }

  /**
   * QuoteVersion findUniqueOrThrow
   */
  export type QuoteVersionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteVersion
     */
    select?: QuoteVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuoteVersion
     */
    omit?: QuoteVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteVersionInclude<ExtArgs> | null
    /**
     * Filter, which QuoteVersion to fetch.
     */
    where: QuoteVersionWhereUniqueInput
  }

  /**
   * QuoteVersion findFirst
   */
  export type QuoteVersionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteVersion
     */
    select?: QuoteVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuoteVersion
     */
    omit?: QuoteVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteVersionInclude<ExtArgs> | null
    /**
     * Filter, which QuoteVersion to fetch.
     */
    where?: QuoteVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuoteVersions to fetch.
     */
    orderBy?: QuoteVersionOrderByWithRelationInput | QuoteVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuoteVersions.
     */
    cursor?: QuoteVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuoteVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuoteVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuoteVersions.
     */
    distinct?: QuoteVersionScalarFieldEnum | QuoteVersionScalarFieldEnum[]
  }

  /**
   * QuoteVersion findFirstOrThrow
   */
  export type QuoteVersionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteVersion
     */
    select?: QuoteVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuoteVersion
     */
    omit?: QuoteVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteVersionInclude<ExtArgs> | null
    /**
     * Filter, which QuoteVersion to fetch.
     */
    where?: QuoteVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuoteVersions to fetch.
     */
    orderBy?: QuoteVersionOrderByWithRelationInput | QuoteVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuoteVersions.
     */
    cursor?: QuoteVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuoteVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuoteVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuoteVersions.
     */
    distinct?: QuoteVersionScalarFieldEnum | QuoteVersionScalarFieldEnum[]
  }

  /**
   * QuoteVersion findMany
   */
  export type QuoteVersionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteVersion
     */
    select?: QuoteVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuoteVersion
     */
    omit?: QuoteVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteVersionInclude<ExtArgs> | null
    /**
     * Filter, which QuoteVersions to fetch.
     */
    where?: QuoteVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuoteVersions to fetch.
     */
    orderBy?: QuoteVersionOrderByWithRelationInput | QuoteVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuoteVersions.
     */
    cursor?: QuoteVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuoteVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuoteVersions.
     */
    skip?: number
    distinct?: QuoteVersionScalarFieldEnum | QuoteVersionScalarFieldEnum[]
  }

  /**
   * QuoteVersion create
   */
  export type QuoteVersionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteVersion
     */
    select?: QuoteVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuoteVersion
     */
    omit?: QuoteVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteVersionInclude<ExtArgs> | null
    /**
     * The data needed to create a QuoteVersion.
     */
    data: XOR<QuoteVersionCreateInput, QuoteVersionUncheckedCreateInput>
  }

  /**
   * QuoteVersion createMany
   */
  export type QuoteVersionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QuoteVersions.
     */
    data: QuoteVersionCreateManyInput | QuoteVersionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QuoteVersion createManyAndReturn
   */
  export type QuoteVersionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteVersion
     */
    select?: QuoteVersionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuoteVersion
     */
    omit?: QuoteVersionOmit<ExtArgs> | null
    /**
     * The data used to create many QuoteVersions.
     */
    data: QuoteVersionCreateManyInput | QuoteVersionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteVersionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuoteVersion update
   */
  export type QuoteVersionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteVersion
     */
    select?: QuoteVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuoteVersion
     */
    omit?: QuoteVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteVersionInclude<ExtArgs> | null
    /**
     * The data needed to update a QuoteVersion.
     */
    data: XOR<QuoteVersionUpdateInput, QuoteVersionUncheckedUpdateInput>
    /**
     * Choose, which QuoteVersion to update.
     */
    where: QuoteVersionWhereUniqueInput
  }

  /**
   * QuoteVersion updateMany
   */
  export type QuoteVersionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QuoteVersions.
     */
    data: XOR<QuoteVersionUpdateManyMutationInput, QuoteVersionUncheckedUpdateManyInput>
    /**
     * Filter which QuoteVersions to update
     */
    where?: QuoteVersionWhereInput
    /**
     * Limit how many QuoteVersions to update.
     */
    limit?: number
  }

  /**
   * QuoteVersion updateManyAndReturn
   */
  export type QuoteVersionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteVersion
     */
    select?: QuoteVersionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuoteVersion
     */
    omit?: QuoteVersionOmit<ExtArgs> | null
    /**
     * The data used to update QuoteVersions.
     */
    data: XOR<QuoteVersionUpdateManyMutationInput, QuoteVersionUncheckedUpdateManyInput>
    /**
     * Filter which QuoteVersions to update
     */
    where?: QuoteVersionWhereInput
    /**
     * Limit how many QuoteVersions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteVersionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuoteVersion upsert
   */
  export type QuoteVersionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteVersion
     */
    select?: QuoteVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuoteVersion
     */
    omit?: QuoteVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteVersionInclude<ExtArgs> | null
    /**
     * The filter to search for the QuoteVersion to update in case it exists.
     */
    where: QuoteVersionWhereUniqueInput
    /**
     * In case the QuoteVersion found by the `where` argument doesn't exist, create a new QuoteVersion with this data.
     */
    create: XOR<QuoteVersionCreateInput, QuoteVersionUncheckedCreateInput>
    /**
     * In case the QuoteVersion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuoteVersionUpdateInput, QuoteVersionUncheckedUpdateInput>
  }

  /**
   * QuoteVersion delete
   */
  export type QuoteVersionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteVersion
     */
    select?: QuoteVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuoteVersion
     */
    omit?: QuoteVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteVersionInclude<ExtArgs> | null
    /**
     * Filter which QuoteVersion to delete.
     */
    where: QuoteVersionWhereUniqueInput
  }

  /**
   * QuoteVersion deleteMany
   */
  export type QuoteVersionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuoteVersions to delete
     */
    where?: QuoteVersionWhereInput
    /**
     * Limit how many QuoteVersions to delete.
     */
    limit?: number
  }

  /**
   * QuoteVersion.items
   */
  export type QuoteVersion$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteVersionItem
     */
    select?: QuoteVersionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuoteVersionItem
     */
    omit?: QuoteVersionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteVersionItemInclude<ExtArgs> | null
    where?: QuoteVersionItemWhereInput
    orderBy?: QuoteVersionItemOrderByWithRelationInput | QuoteVersionItemOrderByWithRelationInput[]
    cursor?: QuoteVersionItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuoteVersionItemScalarFieldEnum | QuoteVersionItemScalarFieldEnum[]
  }

  /**
   * QuoteVersion without action
   */
  export type QuoteVersionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteVersion
     */
    select?: QuoteVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuoteVersion
     */
    omit?: QuoteVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteVersionInclude<ExtArgs> | null
  }


  /**
   * Model QuoteVersionItem
   */

  export type AggregateQuoteVersionItem = {
    _count: QuoteVersionItemCountAggregateOutputType | null
    _avg: QuoteVersionItemAvgAggregateOutputType | null
    _sum: QuoteVersionItemSumAggregateOutputType | null
    _min: QuoteVersionItemMinAggregateOutputType | null
    _max: QuoteVersionItemMaxAggregateOutputType | null
  }

  export type QuoteVersionItemAvgAggregateOutputType = {
    sortOrder: number | null
    qty: Decimal | null
    unitPricePence: number | null
    hours: Decimal | null
    hourlyRatePence: number | null
    sellPricePence: number | null
    lineTotalPence: number | null
  }

  export type QuoteVersionItemSumAggregateOutputType = {
    sortOrder: number | null
    qty: Decimal | null
    unitPricePence: number | null
    hours: Decimal | null
    hourlyRatePence: number | null
    sellPricePence: number | null
    lineTotalPence: number | null
  }

  export type QuoteVersionItemMinAggregateOutputType = {
    id: string | null
    orgId: string | null
    quoteVersionId: string | null
    parentId: string | null
    sourceQuoteItemId: string | null
    rowType: $Enums.ItemRowType | null
    title: string | null
    description: string | null
    sortOrder: number | null
    roomTag: string | null
    tradeTag: string | null
    phaseTag: string | null
    calcType: $Enums.CalcType | null
    qty: Decimal | null
    unit: string | null
    unitPricePence: number | null
    hours: Decimal | null
    hourlyRatePence: number | null
    sellPricePence: number | null
    isAllowance: boolean | null
    lineTotalPence: number | null
    createdAt: Date | null
  }

  export type QuoteVersionItemMaxAggregateOutputType = {
    id: string | null
    orgId: string | null
    quoteVersionId: string | null
    parentId: string | null
    sourceQuoteItemId: string | null
    rowType: $Enums.ItemRowType | null
    title: string | null
    description: string | null
    sortOrder: number | null
    roomTag: string | null
    tradeTag: string | null
    phaseTag: string | null
    calcType: $Enums.CalcType | null
    qty: Decimal | null
    unit: string | null
    unitPricePence: number | null
    hours: Decimal | null
    hourlyRatePence: number | null
    sellPricePence: number | null
    isAllowance: boolean | null
    lineTotalPence: number | null
    createdAt: Date | null
  }

  export type QuoteVersionItemCountAggregateOutputType = {
    id: number
    orgId: number
    quoteVersionId: number
    parentId: number
    sourceQuoteItemId: number
    rowType: number
    title: number
    description: number
    sortOrder: number
    roomTag: number
    tradeTag: number
    phaseTag: number
    calcType: number
    qty: number
    unit: number
    unitPricePence: number
    hours: number
    hourlyRatePence: number
    sellPricePence: number
    isAllowance: number
    lineTotalPence: number
    createdAt: number
    _all: number
  }


  export type QuoteVersionItemAvgAggregateInputType = {
    sortOrder?: true
    qty?: true
    unitPricePence?: true
    hours?: true
    hourlyRatePence?: true
    sellPricePence?: true
    lineTotalPence?: true
  }

  export type QuoteVersionItemSumAggregateInputType = {
    sortOrder?: true
    qty?: true
    unitPricePence?: true
    hours?: true
    hourlyRatePence?: true
    sellPricePence?: true
    lineTotalPence?: true
  }

  export type QuoteVersionItemMinAggregateInputType = {
    id?: true
    orgId?: true
    quoteVersionId?: true
    parentId?: true
    sourceQuoteItemId?: true
    rowType?: true
    title?: true
    description?: true
    sortOrder?: true
    roomTag?: true
    tradeTag?: true
    phaseTag?: true
    calcType?: true
    qty?: true
    unit?: true
    unitPricePence?: true
    hours?: true
    hourlyRatePence?: true
    sellPricePence?: true
    isAllowance?: true
    lineTotalPence?: true
    createdAt?: true
  }

  export type QuoteVersionItemMaxAggregateInputType = {
    id?: true
    orgId?: true
    quoteVersionId?: true
    parentId?: true
    sourceQuoteItemId?: true
    rowType?: true
    title?: true
    description?: true
    sortOrder?: true
    roomTag?: true
    tradeTag?: true
    phaseTag?: true
    calcType?: true
    qty?: true
    unit?: true
    unitPricePence?: true
    hours?: true
    hourlyRatePence?: true
    sellPricePence?: true
    isAllowance?: true
    lineTotalPence?: true
    createdAt?: true
  }

  export type QuoteVersionItemCountAggregateInputType = {
    id?: true
    orgId?: true
    quoteVersionId?: true
    parentId?: true
    sourceQuoteItemId?: true
    rowType?: true
    title?: true
    description?: true
    sortOrder?: true
    roomTag?: true
    tradeTag?: true
    phaseTag?: true
    calcType?: true
    qty?: true
    unit?: true
    unitPricePence?: true
    hours?: true
    hourlyRatePence?: true
    sellPricePence?: true
    isAllowance?: true
    lineTotalPence?: true
    createdAt?: true
    _all?: true
  }

  export type QuoteVersionItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuoteVersionItem to aggregate.
     */
    where?: QuoteVersionItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuoteVersionItems to fetch.
     */
    orderBy?: QuoteVersionItemOrderByWithRelationInput | QuoteVersionItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuoteVersionItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuoteVersionItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuoteVersionItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuoteVersionItems
    **/
    _count?: true | QuoteVersionItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuoteVersionItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuoteVersionItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuoteVersionItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuoteVersionItemMaxAggregateInputType
  }

  export type GetQuoteVersionItemAggregateType<T extends QuoteVersionItemAggregateArgs> = {
        [P in keyof T & keyof AggregateQuoteVersionItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuoteVersionItem[P]>
      : GetScalarType<T[P], AggregateQuoteVersionItem[P]>
  }




  export type QuoteVersionItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuoteVersionItemWhereInput
    orderBy?: QuoteVersionItemOrderByWithAggregationInput | QuoteVersionItemOrderByWithAggregationInput[]
    by: QuoteVersionItemScalarFieldEnum[] | QuoteVersionItemScalarFieldEnum
    having?: QuoteVersionItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuoteVersionItemCountAggregateInputType | true
    _avg?: QuoteVersionItemAvgAggregateInputType
    _sum?: QuoteVersionItemSumAggregateInputType
    _min?: QuoteVersionItemMinAggregateInputType
    _max?: QuoteVersionItemMaxAggregateInputType
  }

  export type QuoteVersionItemGroupByOutputType = {
    id: string
    orgId: string
    quoteVersionId: string
    parentId: string | null
    sourceQuoteItemId: string | null
    rowType: $Enums.ItemRowType
    title: string
    description: string | null
    sortOrder: number
    roomTag: string | null
    tradeTag: string | null
    phaseTag: string | null
    calcType: $Enums.CalcType
    qty: Decimal | null
    unit: string | null
    unitPricePence: number | null
    hours: Decimal | null
    hourlyRatePence: number | null
    sellPricePence: number | null
    isAllowance: boolean
    lineTotalPence: number | null
    createdAt: Date
    _count: QuoteVersionItemCountAggregateOutputType | null
    _avg: QuoteVersionItemAvgAggregateOutputType | null
    _sum: QuoteVersionItemSumAggregateOutputType | null
    _min: QuoteVersionItemMinAggregateOutputType | null
    _max: QuoteVersionItemMaxAggregateOutputType | null
  }

  type GetQuoteVersionItemGroupByPayload<T extends QuoteVersionItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuoteVersionItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuoteVersionItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuoteVersionItemGroupByOutputType[P]>
            : GetScalarType<T[P], QuoteVersionItemGroupByOutputType[P]>
        }
      >
    >


  export type QuoteVersionItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    quoteVersionId?: boolean
    parentId?: boolean
    sourceQuoteItemId?: boolean
    rowType?: boolean
    title?: boolean
    description?: boolean
    sortOrder?: boolean
    roomTag?: boolean
    tradeTag?: boolean
    phaseTag?: boolean
    calcType?: boolean
    qty?: boolean
    unit?: boolean
    unitPricePence?: boolean
    hours?: boolean
    hourlyRatePence?: boolean
    sellPricePence?: boolean
    isAllowance?: boolean
    lineTotalPence?: boolean
    createdAt?: boolean
    quoteVersion?: boolean | QuoteVersionDefaultArgs<ExtArgs>
    parent?: boolean | QuoteVersionItem$parentArgs<ExtArgs>
    children?: boolean | QuoteVersionItem$childrenArgs<ExtArgs>
    _count?: boolean | QuoteVersionItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quoteVersionItem"]>

  export type QuoteVersionItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    quoteVersionId?: boolean
    parentId?: boolean
    sourceQuoteItemId?: boolean
    rowType?: boolean
    title?: boolean
    description?: boolean
    sortOrder?: boolean
    roomTag?: boolean
    tradeTag?: boolean
    phaseTag?: boolean
    calcType?: boolean
    qty?: boolean
    unit?: boolean
    unitPricePence?: boolean
    hours?: boolean
    hourlyRatePence?: boolean
    sellPricePence?: boolean
    isAllowance?: boolean
    lineTotalPence?: boolean
    createdAt?: boolean
    quoteVersion?: boolean | QuoteVersionDefaultArgs<ExtArgs>
    parent?: boolean | QuoteVersionItem$parentArgs<ExtArgs>
  }, ExtArgs["result"]["quoteVersionItem"]>

  export type QuoteVersionItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    quoteVersionId?: boolean
    parentId?: boolean
    sourceQuoteItemId?: boolean
    rowType?: boolean
    title?: boolean
    description?: boolean
    sortOrder?: boolean
    roomTag?: boolean
    tradeTag?: boolean
    phaseTag?: boolean
    calcType?: boolean
    qty?: boolean
    unit?: boolean
    unitPricePence?: boolean
    hours?: boolean
    hourlyRatePence?: boolean
    sellPricePence?: boolean
    isAllowance?: boolean
    lineTotalPence?: boolean
    createdAt?: boolean
    quoteVersion?: boolean | QuoteVersionDefaultArgs<ExtArgs>
    parent?: boolean | QuoteVersionItem$parentArgs<ExtArgs>
  }, ExtArgs["result"]["quoteVersionItem"]>

  export type QuoteVersionItemSelectScalar = {
    id?: boolean
    orgId?: boolean
    quoteVersionId?: boolean
    parentId?: boolean
    sourceQuoteItemId?: boolean
    rowType?: boolean
    title?: boolean
    description?: boolean
    sortOrder?: boolean
    roomTag?: boolean
    tradeTag?: boolean
    phaseTag?: boolean
    calcType?: boolean
    qty?: boolean
    unit?: boolean
    unitPricePence?: boolean
    hours?: boolean
    hourlyRatePence?: boolean
    sellPricePence?: boolean
    isAllowance?: boolean
    lineTotalPence?: boolean
    createdAt?: boolean
  }

  export type QuoteVersionItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orgId" | "quoteVersionId" | "parentId" | "sourceQuoteItemId" | "rowType" | "title" | "description" | "sortOrder" | "roomTag" | "tradeTag" | "phaseTag" | "calcType" | "qty" | "unit" | "unitPricePence" | "hours" | "hourlyRatePence" | "sellPricePence" | "isAllowance" | "lineTotalPence" | "createdAt", ExtArgs["result"]["quoteVersionItem"]>
  export type QuoteVersionItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quoteVersion?: boolean | QuoteVersionDefaultArgs<ExtArgs>
    parent?: boolean | QuoteVersionItem$parentArgs<ExtArgs>
    children?: boolean | QuoteVersionItem$childrenArgs<ExtArgs>
    _count?: boolean | QuoteVersionItemCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type QuoteVersionItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quoteVersion?: boolean | QuoteVersionDefaultArgs<ExtArgs>
    parent?: boolean | QuoteVersionItem$parentArgs<ExtArgs>
  }
  export type QuoteVersionItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quoteVersion?: boolean | QuoteVersionDefaultArgs<ExtArgs>
    parent?: boolean | QuoteVersionItem$parentArgs<ExtArgs>
  }

  export type $QuoteVersionItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QuoteVersionItem"
    objects: {
      quoteVersion: Prisma.$QuoteVersionPayload<ExtArgs>
      parent: Prisma.$QuoteVersionItemPayload<ExtArgs> | null
      children: Prisma.$QuoteVersionItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orgId: string
      quoteVersionId: string
      parentId: string | null
      sourceQuoteItemId: string | null
      rowType: $Enums.ItemRowType
      title: string
      description: string | null
      sortOrder: number
      roomTag: string | null
      tradeTag: string | null
      phaseTag: string | null
      calcType: $Enums.CalcType
      qty: Prisma.Decimal | null
      unit: string | null
      unitPricePence: number | null
      hours: Prisma.Decimal | null
      hourlyRatePence: number | null
      sellPricePence: number | null
      isAllowance: boolean
      lineTotalPence: number | null
      createdAt: Date
    }, ExtArgs["result"]["quoteVersionItem"]>
    composites: {}
  }

  type QuoteVersionItemGetPayload<S extends boolean | null | undefined | QuoteVersionItemDefaultArgs> = $Result.GetResult<Prisma.$QuoteVersionItemPayload, S>

  type QuoteVersionItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QuoteVersionItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuoteVersionItemCountAggregateInputType | true
    }

  export interface QuoteVersionItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QuoteVersionItem'], meta: { name: 'QuoteVersionItem' } }
    /**
     * Find zero or one QuoteVersionItem that matches the filter.
     * @param {QuoteVersionItemFindUniqueArgs} args - Arguments to find a QuoteVersionItem
     * @example
     * // Get one QuoteVersionItem
     * const quoteVersionItem = await prisma.quoteVersionItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuoteVersionItemFindUniqueArgs>(args: SelectSubset<T, QuoteVersionItemFindUniqueArgs<ExtArgs>>): Prisma__QuoteVersionItemClient<$Result.GetResult<Prisma.$QuoteVersionItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one QuoteVersionItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QuoteVersionItemFindUniqueOrThrowArgs} args - Arguments to find a QuoteVersionItem
     * @example
     * // Get one QuoteVersionItem
     * const quoteVersionItem = await prisma.quoteVersionItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuoteVersionItemFindUniqueOrThrowArgs>(args: SelectSubset<T, QuoteVersionItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuoteVersionItemClient<$Result.GetResult<Prisma.$QuoteVersionItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuoteVersionItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteVersionItemFindFirstArgs} args - Arguments to find a QuoteVersionItem
     * @example
     * // Get one QuoteVersionItem
     * const quoteVersionItem = await prisma.quoteVersionItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuoteVersionItemFindFirstArgs>(args?: SelectSubset<T, QuoteVersionItemFindFirstArgs<ExtArgs>>): Prisma__QuoteVersionItemClient<$Result.GetResult<Prisma.$QuoteVersionItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuoteVersionItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteVersionItemFindFirstOrThrowArgs} args - Arguments to find a QuoteVersionItem
     * @example
     * // Get one QuoteVersionItem
     * const quoteVersionItem = await prisma.quoteVersionItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuoteVersionItemFindFirstOrThrowArgs>(args?: SelectSubset<T, QuoteVersionItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuoteVersionItemClient<$Result.GetResult<Prisma.$QuoteVersionItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more QuoteVersionItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteVersionItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuoteVersionItems
     * const quoteVersionItems = await prisma.quoteVersionItem.findMany()
     * 
     * // Get first 10 QuoteVersionItems
     * const quoteVersionItems = await prisma.quoteVersionItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quoteVersionItemWithIdOnly = await prisma.quoteVersionItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuoteVersionItemFindManyArgs>(args?: SelectSubset<T, QuoteVersionItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuoteVersionItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a QuoteVersionItem.
     * @param {QuoteVersionItemCreateArgs} args - Arguments to create a QuoteVersionItem.
     * @example
     * // Create one QuoteVersionItem
     * const QuoteVersionItem = await prisma.quoteVersionItem.create({
     *   data: {
     *     // ... data to create a QuoteVersionItem
     *   }
     * })
     * 
     */
    create<T extends QuoteVersionItemCreateArgs>(args: SelectSubset<T, QuoteVersionItemCreateArgs<ExtArgs>>): Prisma__QuoteVersionItemClient<$Result.GetResult<Prisma.$QuoteVersionItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many QuoteVersionItems.
     * @param {QuoteVersionItemCreateManyArgs} args - Arguments to create many QuoteVersionItems.
     * @example
     * // Create many QuoteVersionItems
     * const quoteVersionItem = await prisma.quoteVersionItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuoteVersionItemCreateManyArgs>(args?: SelectSubset<T, QuoteVersionItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QuoteVersionItems and returns the data saved in the database.
     * @param {QuoteVersionItemCreateManyAndReturnArgs} args - Arguments to create many QuoteVersionItems.
     * @example
     * // Create many QuoteVersionItems
     * const quoteVersionItem = await prisma.quoteVersionItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QuoteVersionItems and only return the `id`
     * const quoteVersionItemWithIdOnly = await prisma.quoteVersionItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuoteVersionItemCreateManyAndReturnArgs>(args?: SelectSubset<T, QuoteVersionItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuoteVersionItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a QuoteVersionItem.
     * @param {QuoteVersionItemDeleteArgs} args - Arguments to delete one QuoteVersionItem.
     * @example
     * // Delete one QuoteVersionItem
     * const QuoteVersionItem = await prisma.quoteVersionItem.delete({
     *   where: {
     *     // ... filter to delete one QuoteVersionItem
     *   }
     * })
     * 
     */
    delete<T extends QuoteVersionItemDeleteArgs>(args: SelectSubset<T, QuoteVersionItemDeleteArgs<ExtArgs>>): Prisma__QuoteVersionItemClient<$Result.GetResult<Prisma.$QuoteVersionItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one QuoteVersionItem.
     * @param {QuoteVersionItemUpdateArgs} args - Arguments to update one QuoteVersionItem.
     * @example
     * // Update one QuoteVersionItem
     * const quoteVersionItem = await prisma.quoteVersionItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuoteVersionItemUpdateArgs>(args: SelectSubset<T, QuoteVersionItemUpdateArgs<ExtArgs>>): Prisma__QuoteVersionItemClient<$Result.GetResult<Prisma.$QuoteVersionItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more QuoteVersionItems.
     * @param {QuoteVersionItemDeleteManyArgs} args - Arguments to filter QuoteVersionItems to delete.
     * @example
     * // Delete a few QuoteVersionItems
     * const { count } = await prisma.quoteVersionItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuoteVersionItemDeleteManyArgs>(args?: SelectSubset<T, QuoteVersionItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuoteVersionItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteVersionItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuoteVersionItems
     * const quoteVersionItem = await prisma.quoteVersionItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuoteVersionItemUpdateManyArgs>(args: SelectSubset<T, QuoteVersionItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuoteVersionItems and returns the data updated in the database.
     * @param {QuoteVersionItemUpdateManyAndReturnArgs} args - Arguments to update many QuoteVersionItems.
     * @example
     * // Update many QuoteVersionItems
     * const quoteVersionItem = await prisma.quoteVersionItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more QuoteVersionItems and only return the `id`
     * const quoteVersionItemWithIdOnly = await prisma.quoteVersionItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QuoteVersionItemUpdateManyAndReturnArgs>(args: SelectSubset<T, QuoteVersionItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuoteVersionItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one QuoteVersionItem.
     * @param {QuoteVersionItemUpsertArgs} args - Arguments to update or create a QuoteVersionItem.
     * @example
     * // Update or create a QuoteVersionItem
     * const quoteVersionItem = await prisma.quoteVersionItem.upsert({
     *   create: {
     *     // ... data to create a QuoteVersionItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuoteVersionItem we want to update
     *   }
     * })
     */
    upsert<T extends QuoteVersionItemUpsertArgs>(args: SelectSubset<T, QuoteVersionItemUpsertArgs<ExtArgs>>): Prisma__QuoteVersionItemClient<$Result.GetResult<Prisma.$QuoteVersionItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of QuoteVersionItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteVersionItemCountArgs} args - Arguments to filter QuoteVersionItems to count.
     * @example
     * // Count the number of QuoteVersionItems
     * const count = await prisma.quoteVersionItem.count({
     *   where: {
     *     // ... the filter for the QuoteVersionItems we want to count
     *   }
     * })
    **/
    count<T extends QuoteVersionItemCountArgs>(
      args?: Subset<T, QuoteVersionItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuoteVersionItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuoteVersionItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteVersionItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuoteVersionItemAggregateArgs>(args: Subset<T, QuoteVersionItemAggregateArgs>): Prisma.PrismaPromise<GetQuoteVersionItemAggregateType<T>>

    /**
     * Group by QuoteVersionItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteVersionItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuoteVersionItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuoteVersionItemGroupByArgs['orderBy'] }
        : { orderBy?: QuoteVersionItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuoteVersionItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuoteVersionItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QuoteVersionItem model
   */
  readonly fields: QuoteVersionItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QuoteVersionItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuoteVersionItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    quoteVersion<T extends QuoteVersionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuoteVersionDefaultArgs<ExtArgs>>): Prisma__QuoteVersionClient<$Result.GetResult<Prisma.$QuoteVersionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    parent<T extends QuoteVersionItem$parentArgs<ExtArgs> = {}>(args?: Subset<T, QuoteVersionItem$parentArgs<ExtArgs>>): Prisma__QuoteVersionItemClient<$Result.GetResult<Prisma.$QuoteVersionItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    children<T extends QuoteVersionItem$childrenArgs<ExtArgs> = {}>(args?: Subset<T, QuoteVersionItem$childrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuoteVersionItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QuoteVersionItem model
   */
  interface QuoteVersionItemFieldRefs {
    readonly id: FieldRef<"QuoteVersionItem", 'String'>
    readonly orgId: FieldRef<"QuoteVersionItem", 'String'>
    readonly quoteVersionId: FieldRef<"QuoteVersionItem", 'String'>
    readonly parentId: FieldRef<"QuoteVersionItem", 'String'>
    readonly sourceQuoteItemId: FieldRef<"QuoteVersionItem", 'String'>
    readonly rowType: FieldRef<"QuoteVersionItem", 'ItemRowType'>
    readonly title: FieldRef<"QuoteVersionItem", 'String'>
    readonly description: FieldRef<"QuoteVersionItem", 'String'>
    readonly sortOrder: FieldRef<"QuoteVersionItem", 'Int'>
    readonly roomTag: FieldRef<"QuoteVersionItem", 'String'>
    readonly tradeTag: FieldRef<"QuoteVersionItem", 'String'>
    readonly phaseTag: FieldRef<"QuoteVersionItem", 'String'>
    readonly calcType: FieldRef<"QuoteVersionItem", 'CalcType'>
    readonly qty: FieldRef<"QuoteVersionItem", 'Decimal'>
    readonly unit: FieldRef<"QuoteVersionItem", 'String'>
    readonly unitPricePence: FieldRef<"QuoteVersionItem", 'Int'>
    readonly hours: FieldRef<"QuoteVersionItem", 'Decimal'>
    readonly hourlyRatePence: FieldRef<"QuoteVersionItem", 'Int'>
    readonly sellPricePence: FieldRef<"QuoteVersionItem", 'Int'>
    readonly isAllowance: FieldRef<"QuoteVersionItem", 'Boolean'>
    readonly lineTotalPence: FieldRef<"QuoteVersionItem", 'Int'>
    readonly createdAt: FieldRef<"QuoteVersionItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * QuoteVersionItem findUnique
   */
  export type QuoteVersionItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteVersionItem
     */
    select?: QuoteVersionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuoteVersionItem
     */
    omit?: QuoteVersionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteVersionItemInclude<ExtArgs> | null
    /**
     * Filter, which QuoteVersionItem to fetch.
     */
    where: QuoteVersionItemWhereUniqueInput
  }

  /**
   * QuoteVersionItem findUniqueOrThrow
   */
  export type QuoteVersionItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteVersionItem
     */
    select?: QuoteVersionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuoteVersionItem
     */
    omit?: QuoteVersionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteVersionItemInclude<ExtArgs> | null
    /**
     * Filter, which QuoteVersionItem to fetch.
     */
    where: QuoteVersionItemWhereUniqueInput
  }

  /**
   * QuoteVersionItem findFirst
   */
  export type QuoteVersionItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteVersionItem
     */
    select?: QuoteVersionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuoteVersionItem
     */
    omit?: QuoteVersionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteVersionItemInclude<ExtArgs> | null
    /**
     * Filter, which QuoteVersionItem to fetch.
     */
    where?: QuoteVersionItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuoteVersionItems to fetch.
     */
    orderBy?: QuoteVersionItemOrderByWithRelationInput | QuoteVersionItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuoteVersionItems.
     */
    cursor?: QuoteVersionItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuoteVersionItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuoteVersionItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuoteVersionItems.
     */
    distinct?: QuoteVersionItemScalarFieldEnum | QuoteVersionItemScalarFieldEnum[]
  }

  /**
   * QuoteVersionItem findFirstOrThrow
   */
  export type QuoteVersionItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteVersionItem
     */
    select?: QuoteVersionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuoteVersionItem
     */
    omit?: QuoteVersionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteVersionItemInclude<ExtArgs> | null
    /**
     * Filter, which QuoteVersionItem to fetch.
     */
    where?: QuoteVersionItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuoteVersionItems to fetch.
     */
    orderBy?: QuoteVersionItemOrderByWithRelationInput | QuoteVersionItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuoteVersionItems.
     */
    cursor?: QuoteVersionItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuoteVersionItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuoteVersionItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuoteVersionItems.
     */
    distinct?: QuoteVersionItemScalarFieldEnum | QuoteVersionItemScalarFieldEnum[]
  }

  /**
   * QuoteVersionItem findMany
   */
  export type QuoteVersionItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteVersionItem
     */
    select?: QuoteVersionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuoteVersionItem
     */
    omit?: QuoteVersionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteVersionItemInclude<ExtArgs> | null
    /**
     * Filter, which QuoteVersionItems to fetch.
     */
    where?: QuoteVersionItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuoteVersionItems to fetch.
     */
    orderBy?: QuoteVersionItemOrderByWithRelationInput | QuoteVersionItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuoteVersionItems.
     */
    cursor?: QuoteVersionItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuoteVersionItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuoteVersionItems.
     */
    skip?: number
    distinct?: QuoteVersionItemScalarFieldEnum | QuoteVersionItemScalarFieldEnum[]
  }

  /**
   * QuoteVersionItem create
   */
  export type QuoteVersionItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteVersionItem
     */
    select?: QuoteVersionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuoteVersionItem
     */
    omit?: QuoteVersionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteVersionItemInclude<ExtArgs> | null
    /**
     * The data needed to create a QuoteVersionItem.
     */
    data: XOR<QuoteVersionItemCreateInput, QuoteVersionItemUncheckedCreateInput>
  }

  /**
   * QuoteVersionItem createMany
   */
  export type QuoteVersionItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QuoteVersionItems.
     */
    data: QuoteVersionItemCreateManyInput | QuoteVersionItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QuoteVersionItem createManyAndReturn
   */
  export type QuoteVersionItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteVersionItem
     */
    select?: QuoteVersionItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuoteVersionItem
     */
    omit?: QuoteVersionItemOmit<ExtArgs> | null
    /**
     * The data used to create many QuoteVersionItems.
     */
    data: QuoteVersionItemCreateManyInput | QuoteVersionItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteVersionItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuoteVersionItem update
   */
  export type QuoteVersionItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteVersionItem
     */
    select?: QuoteVersionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuoteVersionItem
     */
    omit?: QuoteVersionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteVersionItemInclude<ExtArgs> | null
    /**
     * The data needed to update a QuoteVersionItem.
     */
    data: XOR<QuoteVersionItemUpdateInput, QuoteVersionItemUncheckedUpdateInput>
    /**
     * Choose, which QuoteVersionItem to update.
     */
    where: QuoteVersionItemWhereUniqueInput
  }

  /**
   * QuoteVersionItem updateMany
   */
  export type QuoteVersionItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QuoteVersionItems.
     */
    data: XOR<QuoteVersionItemUpdateManyMutationInput, QuoteVersionItemUncheckedUpdateManyInput>
    /**
     * Filter which QuoteVersionItems to update
     */
    where?: QuoteVersionItemWhereInput
    /**
     * Limit how many QuoteVersionItems to update.
     */
    limit?: number
  }

  /**
   * QuoteVersionItem updateManyAndReturn
   */
  export type QuoteVersionItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteVersionItem
     */
    select?: QuoteVersionItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuoteVersionItem
     */
    omit?: QuoteVersionItemOmit<ExtArgs> | null
    /**
     * The data used to update QuoteVersionItems.
     */
    data: XOR<QuoteVersionItemUpdateManyMutationInput, QuoteVersionItemUncheckedUpdateManyInput>
    /**
     * Filter which QuoteVersionItems to update
     */
    where?: QuoteVersionItemWhereInput
    /**
     * Limit how many QuoteVersionItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteVersionItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuoteVersionItem upsert
   */
  export type QuoteVersionItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteVersionItem
     */
    select?: QuoteVersionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuoteVersionItem
     */
    omit?: QuoteVersionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteVersionItemInclude<ExtArgs> | null
    /**
     * The filter to search for the QuoteVersionItem to update in case it exists.
     */
    where: QuoteVersionItemWhereUniqueInput
    /**
     * In case the QuoteVersionItem found by the `where` argument doesn't exist, create a new QuoteVersionItem with this data.
     */
    create: XOR<QuoteVersionItemCreateInput, QuoteVersionItemUncheckedCreateInput>
    /**
     * In case the QuoteVersionItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuoteVersionItemUpdateInput, QuoteVersionItemUncheckedUpdateInput>
  }

  /**
   * QuoteVersionItem delete
   */
  export type QuoteVersionItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteVersionItem
     */
    select?: QuoteVersionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuoteVersionItem
     */
    omit?: QuoteVersionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteVersionItemInclude<ExtArgs> | null
    /**
     * Filter which QuoteVersionItem to delete.
     */
    where: QuoteVersionItemWhereUniqueInput
  }

  /**
   * QuoteVersionItem deleteMany
   */
  export type QuoteVersionItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuoteVersionItems to delete
     */
    where?: QuoteVersionItemWhereInput
    /**
     * Limit how many QuoteVersionItems to delete.
     */
    limit?: number
  }

  /**
   * QuoteVersionItem.parent
   */
  export type QuoteVersionItem$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteVersionItem
     */
    select?: QuoteVersionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuoteVersionItem
     */
    omit?: QuoteVersionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteVersionItemInclude<ExtArgs> | null
    where?: QuoteVersionItemWhereInput
  }

  /**
   * QuoteVersionItem.children
   */
  export type QuoteVersionItem$childrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteVersionItem
     */
    select?: QuoteVersionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuoteVersionItem
     */
    omit?: QuoteVersionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteVersionItemInclude<ExtArgs> | null
    where?: QuoteVersionItemWhereInput
    orderBy?: QuoteVersionItemOrderByWithRelationInput | QuoteVersionItemOrderByWithRelationInput[]
    cursor?: QuoteVersionItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuoteVersionItemScalarFieldEnum | QuoteVersionItemScalarFieldEnum[]
  }

  /**
   * QuoteVersionItem without action
   */
  export type QuoteVersionItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteVersionItem
     */
    select?: QuoteVersionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuoteVersionItem
     */
    omit?: QuoteVersionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteVersionItemInclude<ExtArgs> | null
  }


  /**
   * Model QuotePublicLink
   */

  export type AggregateQuotePublicLink = {
    _count: QuotePublicLinkCountAggregateOutputType | null
    _avg: QuotePublicLinkAvgAggregateOutputType | null
    _sum: QuotePublicLinkSumAggregateOutputType | null
    _min: QuotePublicLinkMinAggregateOutputType | null
    _max: QuotePublicLinkMaxAggregateOutputType | null
  }

  export type QuotePublicLinkAvgAggregateOutputType = {
    viewCount: number | null
  }

  export type QuotePublicLinkSumAggregateOutputType = {
    viewCount: number | null
  }

  export type QuotePublicLinkMinAggregateOutputType = {
    id: string | null
    orgId: string | null
    quoteId: string | null
    tokenHash: string | null
    tokenPrefix: string | null
    isActive: boolean | null
    expiresAt: Date | null
    revokedAt: Date | null
    firstViewedAt: Date | null
    lastViewedAt: Date | null
    viewCount: number | null
    createdByUserId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuotePublicLinkMaxAggregateOutputType = {
    id: string | null
    orgId: string | null
    quoteId: string | null
    tokenHash: string | null
    tokenPrefix: string | null
    isActive: boolean | null
    expiresAt: Date | null
    revokedAt: Date | null
    firstViewedAt: Date | null
    lastViewedAt: Date | null
    viewCount: number | null
    createdByUserId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuotePublicLinkCountAggregateOutputType = {
    id: number
    orgId: number
    quoteId: number
    tokenHash: number
    tokenPrefix: number
    isActive: number
    expiresAt: number
    revokedAt: number
    firstViewedAt: number
    lastViewedAt: number
    viewCount: number
    createdByUserId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type QuotePublicLinkAvgAggregateInputType = {
    viewCount?: true
  }

  export type QuotePublicLinkSumAggregateInputType = {
    viewCount?: true
  }

  export type QuotePublicLinkMinAggregateInputType = {
    id?: true
    orgId?: true
    quoteId?: true
    tokenHash?: true
    tokenPrefix?: true
    isActive?: true
    expiresAt?: true
    revokedAt?: true
    firstViewedAt?: true
    lastViewedAt?: true
    viewCount?: true
    createdByUserId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuotePublicLinkMaxAggregateInputType = {
    id?: true
    orgId?: true
    quoteId?: true
    tokenHash?: true
    tokenPrefix?: true
    isActive?: true
    expiresAt?: true
    revokedAt?: true
    firstViewedAt?: true
    lastViewedAt?: true
    viewCount?: true
    createdByUserId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuotePublicLinkCountAggregateInputType = {
    id?: true
    orgId?: true
    quoteId?: true
    tokenHash?: true
    tokenPrefix?: true
    isActive?: true
    expiresAt?: true
    revokedAt?: true
    firstViewedAt?: true
    lastViewedAt?: true
    viewCount?: true
    createdByUserId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type QuotePublicLinkAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuotePublicLink to aggregate.
     */
    where?: QuotePublicLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuotePublicLinks to fetch.
     */
    orderBy?: QuotePublicLinkOrderByWithRelationInput | QuotePublicLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuotePublicLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuotePublicLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuotePublicLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuotePublicLinks
    **/
    _count?: true | QuotePublicLinkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuotePublicLinkAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuotePublicLinkSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuotePublicLinkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuotePublicLinkMaxAggregateInputType
  }

  export type GetQuotePublicLinkAggregateType<T extends QuotePublicLinkAggregateArgs> = {
        [P in keyof T & keyof AggregateQuotePublicLink]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuotePublicLink[P]>
      : GetScalarType<T[P], AggregateQuotePublicLink[P]>
  }




  export type QuotePublicLinkGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuotePublicLinkWhereInput
    orderBy?: QuotePublicLinkOrderByWithAggregationInput | QuotePublicLinkOrderByWithAggregationInput[]
    by: QuotePublicLinkScalarFieldEnum[] | QuotePublicLinkScalarFieldEnum
    having?: QuotePublicLinkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuotePublicLinkCountAggregateInputType | true
    _avg?: QuotePublicLinkAvgAggregateInputType
    _sum?: QuotePublicLinkSumAggregateInputType
    _min?: QuotePublicLinkMinAggregateInputType
    _max?: QuotePublicLinkMaxAggregateInputType
  }

  export type QuotePublicLinkGroupByOutputType = {
    id: string
    orgId: string
    quoteId: string
    tokenHash: string
    tokenPrefix: string | null
    isActive: boolean
    expiresAt: Date | null
    revokedAt: Date | null
    firstViewedAt: Date | null
    lastViewedAt: Date | null
    viewCount: number
    createdByUserId: string | null
    createdAt: Date
    updatedAt: Date
    _count: QuotePublicLinkCountAggregateOutputType | null
    _avg: QuotePublicLinkAvgAggregateOutputType | null
    _sum: QuotePublicLinkSumAggregateOutputType | null
    _min: QuotePublicLinkMinAggregateOutputType | null
    _max: QuotePublicLinkMaxAggregateOutputType | null
  }

  type GetQuotePublicLinkGroupByPayload<T extends QuotePublicLinkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuotePublicLinkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuotePublicLinkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuotePublicLinkGroupByOutputType[P]>
            : GetScalarType<T[P], QuotePublicLinkGroupByOutputType[P]>
        }
      >
    >


  export type QuotePublicLinkSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    quoteId?: boolean
    tokenHash?: boolean
    tokenPrefix?: boolean
    isActive?: boolean
    expiresAt?: boolean
    revokedAt?: boolean
    firstViewedAt?: boolean
    lastViewedAt?: boolean
    viewCount?: boolean
    createdByUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    quote?: boolean | QuoteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quotePublicLink"]>

  export type QuotePublicLinkSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    quoteId?: boolean
    tokenHash?: boolean
    tokenPrefix?: boolean
    isActive?: boolean
    expiresAt?: boolean
    revokedAt?: boolean
    firstViewedAt?: boolean
    lastViewedAt?: boolean
    viewCount?: boolean
    createdByUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    quote?: boolean | QuoteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quotePublicLink"]>

  export type QuotePublicLinkSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    quoteId?: boolean
    tokenHash?: boolean
    tokenPrefix?: boolean
    isActive?: boolean
    expiresAt?: boolean
    revokedAt?: boolean
    firstViewedAt?: boolean
    lastViewedAt?: boolean
    viewCount?: boolean
    createdByUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    quote?: boolean | QuoteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quotePublicLink"]>

  export type QuotePublicLinkSelectScalar = {
    id?: boolean
    orgId?: boolean
    quoteId?: boolean
    tokenHash?: boolean
    tokenPrefix?: boolean
    isActive?: boolean
    expiresAt?: boolean
    revokedAt?: boolean
    firstViewedAt?: boolean
    lastViewedAt?: boolean
    viewCount?: boolean
    createdByUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type QuotePublicLinkOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orgId" | "quoteId" | "tokenHash" | "tokenPrefix" | "isActive" | "expiresAt" | "revokedAt" | "firstViewedAt" | "lastViewedAt" | "viewCount" | "createdByUserId" | "createdAt" | "updatedAt", ExtArgs["result"]["quotePublicLink"]>
  export type QuotePublicLinkInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quote?: boolean | QuoteDefaultArgs<ExtArgs>
  }
  export type QuotePublicLinkIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quote?: boolean | QuoteDefaultArgs<ExtArgs>
  }
  export type QuotePublicLinkIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quote?: boolean | QuoteDefaultArgs<ExtArgs>
  }

  export type $QuotePublicLinkPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QuotePublicLink"
    objects: {
      quote: Prisma.$QuotePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orgId: string
      quoteId: string
      tokenHash: string
      tokenPrefix: string | null
      isActive: boolean
      expiresAt: Date | null
      revokedAt: Date | null
      firstViewedAt: Date | null
      lastViewedAt: Date | null
      viewCount: number
      createdByUserId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["quotePublicLink"]>
    composites: {}
  }

  type QuotePublicLinkGetPayload<S extends boolean | null | undefined | QuotePublicLinkDefaultArgs> = $Result.GetResult<Prisma.$QuotePublicLinkPayload, S>

  type QuotePublicLinkCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QuotePublicLinkFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuotePublicLinkCountAggregateInputType | true
    }

  export interface QuotePublicLinkDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QuotePublicLink'], meta: { name: 'QuotePublicLink' } }
    /**
     * Find zero or one QuotePublicLink that matches the filter.
     * @param {QuotePublicLinkFindUniqueArgs} args - Arguments to find a QuotePublicLink
     * @example
     * // Get one QuotePublicLink
     * const quotePublicLink = await prisma.quotePublicLink.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuotePublicLinkFindUniqueArgs>(args: SelectSubset<T, QuotePublicLinkFindUniqueArgs<ExtArgs>>): Prisma__QuotePublicLinkClient<$Result.GetResult<Prisma.$QuotePublicLinkPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one QuotePublicLink that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QuotePublicLinkFindUniqueOrThrowArgs} args - Arguments to find a QuotePublicLink
     * @example
     * // Get one QuotePublicLink
     * const quotePublicLink = await prisma.quotePublicLink.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuotePublicLinkFindUniqueOrThrowArgs>(args: SelectSubset<T, QuotePublicLinkFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuotePublicLinkClient<$Result.GetResult<Prisma.$QuotePublicLinkPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuotePublicLink that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotePublicLinkFindFirstArgs} args - Arguments to find a QuotePublicLink
     * @example
     * // Get one QuotePublicLink
     * const quotePublicLink = await prisma.quotePublicLink.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuotePublicLinkFindFirstArgs>(args?: SelectSubset<T, QuotePublicLinkFindFirstArgs<ExtArgs>>): Prisma__QuotePublicLinkClient<$Result.GetResult<Prisma.$QuotePublicLinkPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuotePublicLink that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotePublicLinkFindFirstOrThrowArgs} args - Arguments to find a QuotePublicLink
     * @example
     * // Get one QuotePublicLink
     * const quotePublicLink = await prisma.quotePublicLink.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuotePublicLinkFindFirstOrThrowArgs>(args?: SelectSubset<T, QuotePublicLinkFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuotePublicLinkClient<$Result.GetResult<Prisma.$QuotePublicLinkPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more QuotePublicLinks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotePublicLinkFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuotePublicLinks
     * const quotePublicLinks = await prisma.quotePublicLink.findMany()
     * 
     * // Get first 10 QuotePublicLinks
     * const quotePublicLinks = await prisma.quotePublicLink.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quotePublicLinkWithIdOnly = await prisma.quotePublicLink.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuotePublicLinkFindManyArgs>(args?: SelectSubset<T, QuotePublicLinkFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotePublicLinkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a QuotePublicLink.
     * @param {QuotePublicLinkCreateArgs} args - Arguments to create a QuotePublicLink.
     * @example
     * // Create one QuotePublicLink
     * const QuotePublicLink = await prisma.quotePublicLink.create({
     *   data: {
     *     // ... data to create a QuotePublicLink
     *   }
     * })
     * 
     */
    create<T extends QuotePublicLinkCreateArgs>(args: SelectSubset<T, QuotePublicLinkCreateArgs<ExtArgs>>): Prisma__QuotePublicLinkClient<$Result.GetResult<Prisma.$QuotePublicLinkPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many QuotePublicLinks.
     * @param {QuotePublicLinkCreateManyArgs} args - Arguments to create many QuotePublicLinks.
     * @example
     * // Create many QuotePublicLinks
     * const quotePublicLink = await prisma.quotePublicLink.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuotePublicLinkCreateManyArgs>(args?: SelectSubset<T, QuotePublicLinkCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QuotePublicLinks and returns the data saved in the database.
     * @param {QuotePublicLinkCreateManyAndReturnArgs} args - Arguments to create many QuotePublicLinks.
     * @example
     * // Create many QuotePublicLinks
     * const quotePublicLink = await prisma.quotePublicLink.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QuotePublicLinks and only return the `id`
     * const quotePublicLinkWithIdOnly = await prisma.quotePublicLink.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuotePublicLinkCreateManyAndReturnArgs>(args?: SelectSubset<T, QuotePublicLinkCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotePublicLinkPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a QuotePublicLink.
     * @param {QuotePublicLinkDeleteArgs} args - Arguments to delete one QuotePublicLink.
     * @example
     * // Delete one QuotePublicLink
     * const QuotePublicLink = await prisma.quotePublicLink.delete({
     *   where: {
     *     // ... filter to delete one QuotePublicLink
     *   }
     * })
     * 
     */
    delete<T extends QuotePublicLinkDeleteArgs>(args: SelectSubset<T, QuotePublicLinkDeleteArgs<ExtArgs>>): Prisma__QuotePublicLinkClient<$Result.GetResult<Prisma.$QuotePublicLinkPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one QuotePublicLink.
     * @param {QuotePublicLinkUpdateArgs} args - Arguments to update one QuotePublicLink.
     * @example
     * // Update one QuotePublicLink
     * const quotePublicLink = await prisma.quotePublicLink.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuotePublicLinkUpdateArgs>(args: SelectSubset<T, QuotePublicLinkUpdateArgs<ExtArgs>>): Prisma__QuotePublicLinkClient<$Result.GetResult<Prisma.$QuotePublicLinkPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more QuotePublicLinks.
     * @param {QuotePublicLinkDeleteManyArgs} args - Arguments to filter QuotePublicLinks to delete.
     * @example
     * // Delete a few QuotePublicLinks
     * const { count } = await prisma.quotePublicLink.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuotePublicLinkDeleteManyArgs>(args?: SelectSubset<T, QuotePublicLinkDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuotePublicLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotePublicLinkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuotePublicLinks
     * const quotePublicLink = await prisma.quotePublicLink.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuotePublicLinkUpdateManyArgs>(args: SelectSubset<T, QuotePublicLinkUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuotePublicLinks and returns the data updated in the database.
     * @param {QuotePublicLinkUpdateManyAndReturnArgs} args - Arguments to update many QuotePublicLinks.
     * @example
     * // Update many QuotePublicLinks
     * const quotePublicLink = await prisma.quotePublicLink.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more QuotePublicLinks and only return the `id`
     * const quotePublicLinkWithIdOnly = await prisma.quotePublicLink.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QuotePublicLinkUpdateManyAndReturnArgs>(args: SelectSubset<T, QuotePublicLinkUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotePublicLinkPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one QuotePublicLink.
     * @param {QuotePublicLinkUpsertArgs} args - Arguments to update or create a QuotePublicLink.
     * @example
     * // Update or create a QuotePublicLink
     * const quotePublicLink = await prisma.quotePublicLink.upsert({
     *   create: {
     *     // ... data to create a QuotePublicLink
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuotePublicLink we want to update
     *   }
     * })
     */
    upsert<T extends QuotePublicLinkUpsertArgs>(args: SelectSubset<T, QuotePublicLinkUpsertArgs<ExtArgs>>): Prisma__QuotePublicLinkClient<$Result.GetResult<Prisma.$QuotePublicLinkPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of QuotePublicLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotePublicLinkCountArgs} args - Arguments to filter QuotePublicLinks to count.
     * @example
     * // Count the number of QuotePublicLinks
     * const count = await prisma.quotePublicLink.count({
     *   where: {
     *     // ... the filter for the QuotePublicLinks we want to count
     *   }
     * })
    **/
    count<T extends QuotePublicLinkCountArgs>(
      args?: Subset<T, QuotePublicLinkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuotePublicLinkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuotePublicLink.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotePublicLinkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuotePublicLinkAggregateArgs>(args: Subset<T, QuotePublicLinkAggregateArgs>): Prisma.PrismaPromise<GetQuotePublicLinkAggregateType<T>>

    /**
     * Group by QuotePublicLink.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotePublicLinkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuotePublicLinkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuotePublicLinkGroupByArgs['orderBy'] }
        : { orderBy?: QuotePublicLinkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuotePublicLinkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuotePublicLinkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QuotePublicLink model
   */
  readonly fields: QuotePublicLinkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QuotePublicLink.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuotePublicLinkClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    quote<T extends QuoteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuoteDefaultArgs<ExtArgs>>): Prisma__QuoteClient<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QuotePublicLink model
   */
  interface QuotePublicLinkFieldRefs {
    readonly id: FieldRef<"QuotePublicLink", 'String'>
    readonly orgId: FieldRef<"QuotePublicLink", 'String'>
    readonly quoteId: FieldRef<"QuotePublicLink", 'String'>
    readonly tokenHash: FieldRef<"QuotePublicLink", 'String'>
    readonly tokenPrefix: FieldRef<"QuotePublicLink", 'String'>
    readonly isActive: FieldRef<"QuotePublicLink", 'Boolean'>
    readonly expiresAt: FieldRef<"QuotePublicLink", 'DateTime'>
    readonly revokedAt: FieldRef<"QuotePublicLink", 'DateTime'>
    readonly firstViewedAt: FieldRef<"QuotePublicLink", 'DateTime'>
    readonly lastViewedAt: FieldRef<"QuotePublicLink", 'DateTime'>
    readonly viewCount: FieldRef<"QuotePublicLink", 'Int'>
    readonly createdByUserId: FieldRef<"QuotePublicLink", 'String'>
    readonly createdAt: FieldRef<"QuotePublicLink", 'DateTime'>
    readonly updatedAt: FieldRef<"QuotePublicLink", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * QuotePublicLink findUnique
   */
  export type QuotePublicLinkFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotePublicLink
     */
    select?: QuotePublicLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuotePublicLink
     */
    omit?: QuotePublicLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotePublicLinkInclude<ExtArgs> | null
    /**
     * Filter, which QuotePublicLink to fetch.
     */
    where: QuotePublicLinkWhereUniqueInput
  }

  /**
   * QuotePublicLink findUniqueOrThrow
   */
  export type QuotePublicLinkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotePublicLink
     */
    select?: QuotePublicLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuotePublicLink
     */
    omit?: QuotePublicLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotePublicLinkInclude<ExtArgs> | null
    /**
     * Filter, which QuotePublicLink to fetch.
     */
    where: QuotePublicLinkWhereUniqueInput
  }

  /**
   * QuotePublicLink findFirst
   */
  export type QuotePublicLinkFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotePublicLink
     */
    select?: QuotePublicLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuotePublicLink
     */
    omit?: QuotePublicLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotePublicLinkInclude<ExtArgs> | null
    /**
     * Filter, which QuotePublicLink to fetch.
     */
    where?: QuotePublicLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuotePublicLinks to fetch.
     */
    orderBy?: QuotePublicLinkOrderByWithRelationInput | QuotePublicLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuotePublicLinks.
     */
    cursor?: QuotePublicLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuotePublicLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuotePublicLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuotePublicLinks.
     */
    distinct?: QuotePublicLinkScalarFieldEnum | QuotePublicLinkScalarFieldEnum[]
  }

  /**
   * QuotePublicLink findFirstOrThrow
   */
  export type QuotePublicLinkFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotePublicLink
     */
    select?: QuotePublicLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuotePublicLink
     */
    omit?: QuotePublicLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotePublicLinkInclude<ExtArgs> | null
    /**
     * Filter, which QuotePublicLink to fetch.
     */
    where?: QuotePublicLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuotePublicLinks to fetch.
     */
    orderBy?: QuotePublicLinkOrderByWithRelationInput | QuotePublicLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuotePublicLinks.
     */
    cursor?: QuotePublicLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuotePublicLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuotePublicLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuotePublicLinks.
     */
    distinct?: QuotePublicLinkScalarFieldEnum | QuotePublicLinkScalarFieldEnum[]
  }

  /**
   * QuotePublicLink findMany
   */
  export type QuotePublicLinkFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotePublicLink
     */
    select?: QuotePublicLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuotePublicLink
     */
    omit?: QuotePublicLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotePublicLinkInclude<ExtArgs> | null
    /**
     * Filter, which QuotePublicLinks to fetch.
     */
    where?: QuotePublicLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuotePublicLinks to fetch.
     */
    orderBy?: QuotePublicLinkOrderByWithRelationInput | QuotePublicLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuotePublicLinks.
     */
    cursor?: QuotePublicLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuotePublicLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuotePublicLinks.
     */
    skip?: number
    distinct?: QuotePublicLinkScalarFieldEnum | QuotePublicLinkScalarFieldEnum[]
  }

  /**
   * QuotePublicLink create
   */
  export type QuotePublicLinkCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotePublicLink
     */
    select?: QuotePublicLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuotePublicLink
     */
    omit?: QuotePublicLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotePublicLinkInclude<ExtArgs> | null
    /**
     * The data needed to create a QuotePublicLink.
     */
    data: XOR<QuotePublicLinkCreateInput, QuotePublicLinkUncheckedCreateInput>
  }

  /**
   * QuotePublicLink createMany
   */
  export type QuotePublicLinkCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QuotePublicLinks.
     */
    data: QuotePublicLinkCreateManyInput | QuotePublicLinkCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QuotePublicLink createManyAndReturn
   */
  export type QuotePublicLinkCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotePublicLink
     */
    select?: QuotePublicLinkSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuotePublicLink
     */
    omit?: QuotePublicLinkOmit<ExtArgs> | null
    /**
     * The data used to create many QuotePublicLinks.
     */
    data: QuotePublicLinkCreateManyInput | QuotePublicLinkCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotePublicLinkIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuotePublicLink update
   */
  export type QuotePublicLinkUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotePublicLink
     */
    select?: QuotePublicLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuotePublicLink
     */
    omit?: QuotePublicLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotePublicLinkInclude<ExtArgs> | null
    /**
     * The data needed to update a QuotePublicLink.
     */
    data: XOR<QuotePublicLinkUpdateInput, QuotePublicLinkUncheckedUpdateInput>
    /**
     * Choose, which QuotePublicLink to update.
     */
    where: QuotePublicLinkWhereUniqueInput
  }

  /**
   * QuotePublicLink updateMany
   */
  export type QuotePublicLinkUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QuotePublicLinks.
     */
    data: XOR<QuotePublicLinkUpdateManyMutationInput, QuotePublicLinkUncheckedUpdateManyInput>
    /**
     * Filter which QuotePublicLinks to update
     */
    where?: QuotePublicLinkWhereInput
    /**
     * Limit how many QuotePublicLinks to update.
     */
    limit?: number
  }

  /**
   * QuotePublicLink updateManyAndReturn
   */
  export type QuotePublicLinkUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotePublicLink
     */
    select?: QuotePublicLinkSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuotePublicLink
     */
    omit?: QuotePublicLinkOmit<ExtArgs> | null
    /**
     * The data used to update QuotePublicLinks.
     */
    data: XOR<QuotePublicLinkUpdateManyMutationInput, QuotePublicLinkUncheckedUpdateManyInput>
    /**
     * Filter which QuotePublicLinks to update
     */
    where?: QuotePublicLinkWhereInput
    /**
     * Limit how many QuotePublicLinks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotePublicLinkIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuotePublicLink upsert
   */
  export type QuotePublicLinkUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotePublicLink
     */
    select?: QuotePublicLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuotePublicLink
     */
    omit?: QuotePublicLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotePublicLinkInclude<ExtArgs> | null
    /**
     * The filter to search for the QuotePublicLink to update in case it exists.
     */
    where: QuotePublicLinkWhereUniqueInput
    /**
     * In case the QuotePublicLink found by the `where` argument doesn't exist, create a new QuotePublicLink with this data.
     */
    create: XOR<QuotePublicLinkCreateInput, QuotePublicLinkUncheckedCreateInput>
    /**
     * In case the QuotePublicLink was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuotePublicLinkUpdateInput, QuotePublicLinkUncheckedUpdateInput>
  }

  /**
   * QuotePublicLink delete
   */
  export type QuotePublicLinkDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotePublicLink
     */
    select?: QuotePublicLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuotePublicLink
     */
    omit?: QuotePublicLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotePublicLinkInclude<ExtArgs> | null
    /**
     * Filter which QuotePublicLink to delete.
     */
    where: QuotePublicLinkWhereUniqueInput
  }

  /**
   * QuotePublicLink deleteMany
   */
  export type QuotePublicLinkDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuotePublicLinks to delete
     */
    where?: QuotePublicLinkWhereInput
    /**
     * Limit how many QuotePublicLinks to delete.
     */
    limit?: number
  }

  /**
   * QuotePublicLink without action
   */
  export type QuotePublicLinkDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotePublicLink
     */
    select?: QuotePublicLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuotePublicLink
     */
    omit?: QuotePublicLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotePublicLinkInclude<ExtArgs> | null
  }


  /**
   * Model QuotePdf
   */

  export type AggregateQuotePdf = {
    _count: QuotePdfCountAggregateOutputType | null
    _avg: QuotePdfAvgAggregateOutputType | null
    _sum: QuotePdfSumAggregateOutputType | null
    _min: QuotePdfMinAggregateOutputType | null
    _max: QuotePdfMaxAggregateOutputType | null
  }

  export type QuotePdfAvgAggregateOutputType = {
    version: number | null
  }

  export type QuotePdfSumAggregateOutputType = {
    version: number | null
  }

  export type QuotePdfMinAggregateOutputType = {
    id: string | null
    orgId: string | null
    quoteId: string | null
    version: number | null
    fileUrl: string | null
    createdAt: Date | null
  }

  export type QuotePdfMaxAggregateOutputType = {
    id: string | null
    orgId: string | null
    quoteId: string | null
    version: number | null
    fileUrl: string | null
    createdAt: Date | null
  }

  export type QuotePdfCountAggregateOutputType = {
    id: number
    orgId: number
    quoteId: number
    version: number
    fileUrl: number
    createdAt: number
    _all: number
  }


  export type QuotePdfAvgAggregateInputType = {
    version?: true
  }

  export type QuotePdfSumAggregateInputType = {
    version?: true
  }

  export type QuotePdfMinAggregateInputType = {
    id?: true
    orgId?: true
    quoteId?: true
    version?: true
    fileUrl?: true
    createdAt?: true
  }

  export type QuotePdfMaxAggregateInputType = {
    id?: true
    orgId?: true
    quoteId?: true
    version?: true
    fileUrl?: true
    createdAt?: true
  }

  export type QuotePdfCountAggregateInputType = {
    id?: true
    orgId?: true
    quoteId?: true
    version?: true
    fileUrl?: true
    createdAt?: true
    _all?: true
  }

  export type QuotePdfAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuotePdf to aggregate.
     */
    where?: QuotePdfWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuotePdfs to fetch.
     */
    orderBy?: QuotePdfOrderByWithRelationInput | QuotePdfOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuotePdfWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuotePdfs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuotePdfs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuotePdfs
    **/
    _count?: true | QuotePdfCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuotePdfAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuotePdfSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuotePdfMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuotePdfMaxAggregateInputType
  }

  export type GetQuotePdfAggregateType<T extends QuotePdfAggregateArgs> = {
        [P in keyof T & keyof AggregateQuotePdf]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuotePdf[P]>
      : GetScalarType<T[P], AggregateQuotePdf[P]>
  }




  export type QuotePdfGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuotePdfWhereInput
    orderBy?: QuotePdfOrderByWithAggregationInput | QuotePdfOrderByWithAggregationInput[]
    by: QuotePdfScalarFieldEnum[] | QuotePdfScalarFieldEnum
    having?: QuotePdfScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuotePdfCountAggregateInputType | true
    _avg?: QuotePdfAvgAggregateInputType
    _sum?: QuotePdfSumAggregateInputType
    _min?: QuotePdfMinAggregateInputType
    _max?: QuotePdfMaxAggregateInputType
  }

  export type QuotePdfGroupByOutputType = {
    id: string
    orgId: string
    quoteId: string
    version: number
    fileUrl: string
    createdAt: Date
    _count: QuotePdfCountAggregateOutputType | null
    _avg: QuotePdfAvgAggregateOutputType | null
    _sum: QuotePdfSumAggregateOutputType | null
    _min: QuotePdfMinAggregateOutputType | null
    _max: QuotePdfMaxAggregateOutputType | null
  }

  type GetQuotePdfGroupByPayload<T extends QuotePdfGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuotePdfGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuotePdfGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuotePdfGroupByOutputType[P]>
            : GetScalarType<T[P], QuotePdfGroupByOutputType[P]>
        }
      >
    >


  export type QuotePdfSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    quoteId?: boolean
    version?: boolean
    fileUrl?: boolean
    createdAt?: boolean
    quote?: boolean | QuoteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quotePdf"]>

  export type QuotePdfSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    quoteId?: boolean
    version?: boolean
    fileUrl?: boolean
    createdAt?: boolean
    quote?: boolean | QuoteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quotePdf"]>

  export type QuotePdfSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    quoteId?: boolean
    version?: boolean
    fileUrl?: boolean
    createdAt?: boolean
    quote?: boolean | QuoteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quotePdf"]>

  export type QuotePdfSelectScalar = {
    id?: boolean
    orgId?: boolean
    quoteId?: boolean
    version?: boolean
    fileUrl?: boolean
    createdAt?: boolean
  }

  export type QuotePdfOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orgId" | "quoteId" | "version" | "fileUrl" | "createdAt", ExtArgs["result"]["quotePdf"]>
  export type QuotePdfInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quote?: boolean | QuoteDefaultArgs<ExtArgs>
  }
  export type QuotePdfIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quote?: boolean | QuoteDefaultArgs<ExtArgs>
  }
  export type QuotePdfIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quote?: boolean | QuoteDefaultArgs<ExtArgs>
  }

  export type $QuotePdfPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QuotePdf"
    objects: {
      quote: Prisma.$QuotePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orgId: string
      quoteId: string
      version: number
      fileUrl: string
      createdAt: Date
    }, ExtArgs["result"]["quotePdf"]>
    composites: {}
  }

  type QuotePdfGetPayload<S extends boolean | null | undefined | QuotePdfDefaultArgs> = $Result.GetResult<Prisma.$QuotePdfPayload, S>

  type QuotePdfCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QuotePdfFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuotePdfCountAggregateInputType | true
    }

  export interface QuotePdfDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QuotePdf'], meta: { name: 'QuotePdf' } }
    /**
     * Find zero or one QuotePdf that matches the filter.
     * @param {QuotePdfFindUniqueArgs} args - Arguments to find a QuotePdf
     * @example
     * // Get one QuotePdf
     * const quotePdf = await prisma.quotePdf.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuotePdfFindUniqueArgs>(args: SelectSubset<T, QuotePdfFindUniqueArgs<ExtArgs>>): Prisma__QuotePdfClient<$Result.GetResult<Prisma.$QuotePdfPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one QuotePdf that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QuotePdfFindUniqueOrThrowArgs} args - Arguments to find a QuotePdf
     * @example
     * // Get one QuotePdf
     * const quotePdf = await prisma.quotePdf.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuotePdfFindUniqueOrThrowArgs>(args: SelectSubset<T, QuotePdfFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuotePdfClient<$Result.GetResult<Prisma.$QuotePdfPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuotePdf that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotePdfFindFirstArgs} args - Arguments to find a QuotePdf
     * @example
     * // Get one QuotePdf
     * const quotePdf = await prisma.quotePdf.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuotePdfFindFirstArgs>(args?: SelectSubset<T, QuotePdfFindFirstArgs<ExtArgs>>): Prisma__QuotePdfClient<$Result.GetResult<Prisma.$QuotePdfPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuotePdf that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotePdfFindFirstOrThrowArgs} args - Arguments to find a QuotePdf
     * @example
     * // Get one QuotePdf
     * const quotePdf = await prisma.quotePdf.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuotePdfFindFirstOrThrowArgs>(args?: SelectSubset<T, QuotePdfFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuotePdfClient<$Result.GetResult<Prisma.$QuotePdfPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more QuotePdfs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotePdfFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuotePdfs
     * const quotePdfs = await prisma.quotePdf.findMany()
     * 
     * // Get first 10 QuotePdfs
     * const quotePdfs = await prisma.quotePdf.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quotePdfWithIdOnly = await prisma.quotePdf.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuotePdfFindManyArgs>(args?: SelectSubset<T, QuotePdfFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotePdfPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a QuotePdf.
     * @param {QuotePdfCreateArgs} args - Arguments to create a QuotePdf.
     * @example
     * // Create one QuotePdf
     * const QuotePdf = await prisma.quotePdf.create({
     *   data: {
     *     // ... data to create a QuotePdf
     *   }
     * })
     * 
     */
    create<T extends QuotePdfCreateArgs>(args: SelectSubset<T, QuotePdfCreateArgs<ExtArgs>>): Prisma__QuotePdfClient<$Result.GetResult<Prisma.$QuotePdfPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many QuotePdfs.
     * @param {QuotePdfCreateManyArgs} args - Arguments to create many QuotePdfs.
     * @example
     * // Create many QuotePdfs
     * const quotePdf = await prisma.quotePdf.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuotePdfCreateManyArgs>(args?: SelectSubset<T, QuotePdfCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QuotePdfs and returns the data saved in the database.
     * @param {QuotePdfCreateManyAndReturnArgs} args - Arguments to create many QuotePdfs.
     * @example
     * // Create many QuotePdfs
     * const quotePdf = await prisma.quotePdf.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QuotePdfs and only return the `id`
     * const quotePdfWithIdOnly = await prisma.quotePdf.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuotePdfCreateManyAndReturnArgs>(args?: SelectSubset<T, QuotePdfCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotePdfPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a QuotePdf.
     * @param {QuotePdfDeleteArgs} args - Arguments to delete one QuotePdf.
     * @example
     * // Delete one QuotePdf
     * const QuotePdf = await prisma.quotePdf.delete({
     *   where: {
     *     // ... filter to delete one QuotePdf
     *   }
     * })
     * 
     */
    delete<T extends QuotePdfDeleteArgs>(args: SelectSubset<T, QuotePdfDeleteArgs<ExtArgs>>): Prisma__QuotePdfClient<$Result.GetResult<Prisma.$QuotePdfPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one QuotePdf.
     * @param {QuotePdfUpdateArgs} args - Arguments to update one QuotePdf.
     * @example
     * // Update one QuotePdf
     * const quotePdf = await prisma.quotePdf.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuotePdfUpdateArgs>(args: SelectSubset<T, QuotePdfUpdateArgs<ExtArgs>>): Prisma__QuotePdfClient<$Result.GetResult<Prisma.$QuotePdfPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more QuotePdfs.
     * @param {QuotePdfDeleteManyArgs} args - Arguments to filter QuotePdfs to delete.
     * @example
     * // Delete a few QuotePdfs
     * const { count } = await prisma.quotePdf.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuotePdfDeleteManyArgs>(args?: SelectSubset<T, QuotePdfDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuotePdfs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotePdfUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuotePdfs
     * const quotePdf = await prisma.quotePdf.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuotePdfUpdateManyArgs>(args: SelectSubset<T, QuotePdfUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuotePdfs and returns the data updated in the database.
     * @param {QuotePdfUpdateManyAndReturnArgs} args - Arguments to update many QuotePdfs.
     * @example
     * // Update many QuotePdfs
     * const quotePdf = await prisma.quotePdf.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more QuotePdfs and only return the `id`
     * const quotePdfWithIdOnly = await prisma.quotePdf.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QuotePdfUpdateManyAndReturnArgs>(args: SelectSubset<T, QuotePdfUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuotePdfPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one QuotePdf.
     * @param {QuotePdfUpsertArgs} args - Arguments to update or create a QuotePdf.
     * @example
     * // Update or create a QuotePdf
     * const quotePdf = await prisma.quotePdf.upsert({
     *   create: {
     *     // ... data to create a QuotePdf
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuotePdf we want to update
     *   }
     * })
     */
    upsert<T extends QuotePdfUpsertArgs>(args: SelectSubset<T, QuotePdfUpsertArgs<ExtArgs>>): Prisma__QuotePdfClient<$Result.GetResult<Prisma.$QuotePdfPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of QuotePdfs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotePdfCountArgs} args - Arguments to filter QuotePdfs to count.
     * @example
     * // Count the number of QuotePdfs
     * const count = await prisma.quotePdf.count({
     *   where: {
     *     // ... the filter for the QuotePdfs we want to count
     *   }
     * })
    **/
    count<T extends QuotePdfCountArgs>(
      args?: Subset<T, QuotePdfCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuotePdfCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuotePdf.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotePdfAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuotePdfAggregateArgs>(args: Subset<T, QuotePdfAggregateArgs>): Prisma.PrismaPromise<GetQuotePdfAggregateType<T>>

    /**
     * Group by QuotePdf.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotePdfGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuotePdfGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuotePdfGroupByArgs['orderBy'] }
        : { orderBy?: QuotePdfGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuotePdfGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuotePdfGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QuotePdf model
   */
  readonly fields: QuotePdfFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QuotePdf.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuotePdfClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    quote<T extends QuoteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuoteDefaultArgs<ExtArgs>>): Prisma__QuoteClient<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QuotePdf model
   */
  interface QuotePdfFieldRefs {
    readonly id: FieldRef<"QuotePdf", 'String'>
    readonly orgId: FieldRef<"QuotePdf", 'String'>
    readonly quoteId: FieldRef<"QuotePdf", 'String'>
    readonly version: FieldRef<"QuotePdf", 'Int'>
    readonly fileUrl: FieldRef<"QuotePdf", 'String'>
    readonly createdAt: FieldRef<"QuotePdf", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * QuotePdf findUnique
   */
  export type QuotePdfFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotePdf
     */
    select?: QuotePdfSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuotePdf
     */
    omit?: QuotePdfOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotePdfInclude<ExtArgs> | null
    /**
     * Filter, which QuotePdf to fetch.
     */
    where: QuotePdfWhereUniqueInput
  }

  /**
   * QuotePdf findUniqueOrThrow
   */
  export type QuotePdfFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotePdf
     */
    select?: QuotePdfSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuotePdf
     */
    omit?: QuotePdfOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotePdfInclude<ExtArgs> | null
    /**
     * Filter, which QuotePdf to fetch.
     */
    where: QuotePdfWhereUniqueInput
  }

  /**
   * QuotePdf findFirst
   */
  export type QuotePdfFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotePdf
     */
    select?: QuotePdfSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuotePdf
     */
    omit?: QuotePdfOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotePdfInclude<ExtArgs> | null
    /**
     * Filter, which QuotePdf to fetch.
     */
    where?: QuotePdfWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuotePdfs to fetch.
     */
    orderBy?: QuotePdfOrderByWithRelationInput | QuotePdfOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuotePdfs.
     */
    cursor?: QuotePdfWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuotePdfs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuotePdfs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuotePdfs.
     */
    distinct?: QuotePdfScalarFieldEnum | QuotePdfScalarFieldEnum[]
  }

  /**
   * QuotePdf findFirstOrThrow
   */
  export type QuotePdfFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotePdf
     */
    select?: QuotePdfSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuotePdf
     */
    omit?: QuotePdfOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotePdfInclude<ExtArgs> | null
    /**
     * Filter, which QuotePdf to fetch.
     */
    where?: QuotePdfWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuotePdfs to fetch.
     */
    orderBy?: QuotePdfOrderByWithRelationInput | QuotePdfOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuotePdfs.
     */
    cursor?: QuotePdfWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuotePdfs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuotePdfs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuotePdfs.
     */
    distinct?: QuotePdfScalarFieldEnum | QuotePdfScalarFieldEnum[]
  }

  /**
   * QuotePdf findMany
   */
  export type QuotePdfFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotePdf
     */
    select?: QuotePdfSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuotePdf
     */
    omit?: QuotePdfOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotePdfInclude<ExtArgs> | null
    /**
     * Filter, which QuotePdfs to fetch.
     */
    where?: QuotePdfWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuotePdfs to fetch.
     */
    orderBy?: QuotePdfOrderByWithRelationInput | QuotePdfOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuotePdfs.
     */
    cursor?: QuotePdfWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuotePdfs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuotePdfs.
     */
    skip?: number
    distinct?: QuotePdfScalarFieldEnum | QuotePdfScalarFieldEnum[]
  }

  /**
   * QuotePdf create
   */
  export type QuotePdfCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotePdf
     */
    select?: QuotePdfSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuotePdf
     */
    omit?: QuotePdfOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotePdfInclude<ExtArgs> | null
    /**
     * The data needed to create a QuotePdf.
     */
    data: XOR<QuotePdfCreateInput, QuotePdfUncheckedCreateInput>
  }

  /**
   * QuotePdf createMany
   */
  export type QuotePdfCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QuotePdfs.
     */
    data: QuotePdfCreateManyInput | QuotePdfCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QuotePdf createManyAndReturn
   */
  export type QuotePdfCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotePdf
     */
    select?: QuotePdfSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuotePdf
     */
    omit?: QuotePdfOmit<ExtArgs> | null
    /**
     * The data used to create many QuotePdfs.
     */
    data: QuotePdfCreateManyInput | QuotePdfCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotePdfIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuotePdf update
   */
  export type QuotePdfUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotePdf
     */
    select?: QuotePdfSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuotePdf
     */
    omit?: QuotePdfOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotePdfInclude<ExtArgs> | null
    /**
     * The data needed to update a QuotePdf.
     */
    data: XOR<QuotePdfUpdateInput, QuotePdfUncheckedUpdateInput>
    /**
     * Choose, which QuotePdf to update.
     */
    where: QuotePdfWhereUniqueInput
  }

  /**
   * QuotePdf updateMany
   */
  export type QuotePdfUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QuotePdfs.
     */
    data: XOR<QuotePdfUpdateManyMutationInput, QuotePdfUncheckedUpdateManyInput>
    /**
     * Filter which QuotePdfs to update
     */
    where?: QuotePdfWhereInput
    /**
     * Limit how many QuotePdfs to update.
     */
    limit?: number
  }

  /**
   * QuotePdf updateManyAndReturn
   */
  export type QuotePdfUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotePdf
     */
    select?: QuotePdfSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuotePdf
     */
    omit?: QuotePdfOmit<ExtArgs> | null
    /**
     * The data used to update QuotePdfs.
     */
    data: XOR<QuotePdfUpdateManyMutationInput, QuotePdfUncheckedUpdateManyInput>
    /**
     * Filter which QuotePdfs to update
     */
    where?: QuotePdfWhereInput
    /**
     * Limit how many QuotePdfs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotePdfIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuotePdf upsert
   */
  export type QuotePdfUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotePdf
     */
    select?: QuotePdfSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuotePdf
     */
    omit?: QuotePdfOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotePdfInclude<ExtArgs> | null
    /**
     * The filter to search for the QuotePdf to update in case it exists.
     */
    where: QuotePdfWhereUniqueInput
    /**
     * In case the QuotePdf found by the `where` argument doesn't exist, create a new QuotePdf with this data.
     */
    create: XOR<QuotePdfCreateInput, QuotePdfUncheckedCreateInput>
    /**
     * In case the QuotePdf was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuotePdfUpdateInput, QuotePdfUncheckedUpdateInput>
  }

  /**
   * QuotePdf delete
   */
  export type QuotePdfDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotePdf
     */
    select?: QuotePdfSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuotePdf
     */
    omit?: QuotePdfOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotePdfInclude<ExtArgs> | null
    /**
     * Filter which QuotePdf to delete.
     */
    where: QuotePdfWhereUniqueInput
  }

  /**
   * QuotePdf deleteMany
   */
  export type QuotePdfDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuotePdfs to delete
     */
    where?: QuotePdfWhereInput
    /**
     * Limit how many QuotePdfs to delete.
     */
    limit?: number
  }

  /**
   * QuotePdf without action
   */
  export type QuotePdfDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuotePdf
     */
    select?: QuotePdfSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuotePdf
     */
    omit?: QuotePdfOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuotePdfInclude<ExtArgs> | null
  }


  /**
   * Model QuoteAcceptance
   */

  export type AggregateQuoteAcceptance = {
    _count: QuoteAcceptanceCountAggregateOutputType | null
    _min: QuoteAcceptanceMinAggregateOutputType | null
    _max: QuoteAcceptanceMaxAggregateOutputType | null
  }

  export type QuoteAcceptanceMinAggregateOutputType = {
    id: string | null
    orgId: string | null
    quoteId: string | null
    acceptedName: string | null
    acceptedEmail: string | null
    acceptedAt: Date | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type QuoteAcceptanceMaxAggregateOutputType = {
    id: string | null
    orgId: string | null
    quoteId: string | null
    acceptedName: string | null
    acceptedEmail: string | null
    acceptedAt: Date | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type QuoteAcceptanceCountAggregateOutputType = {
    id: number
    orgId: number
    quoteId: number
    acceptedName: number
    acceptedEmail: number
    acceptedAt: number
    ipAddress: number
    userAgent: number
    createdAt: number
    _all: number
  }


  export type QuoteAcceptanceMinAggregateInputType = {
    id?: true
    orgId?: true
    quoteId?: true
    acceptedName?: true
    acceptedEmail?: true
    acceptedAt?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type QuoteAcceptanceMaxAggregateInputType = {
    id?: true
    orgId?: true
    quoteId?: true
    acceptedName?: true
    acceptedEmail?: true
    acceptedAt?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type QuoteAcceptanceCountAggregateInputType = {
    id?: true
    orgId?: true
    quoteId?: true
    acceptedName?: true
    acceptedEmail?: true
    acceptedAt?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    _all?: true
  }

  export type QuoteAcceptanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuoteAcceptance to aggregate.
     */
    where?: QuoteAcceptanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuoteAcceptances to fetch.
     */
    orderBy?: QuoteAcceptanceOrderByWithRelationInput | QuoteAcceptanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuoteAcceptanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuoteAcceptances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuoteAcceptances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuoteAcceptances
    **/
    _count?: true | QuoteAcceptanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuoteAcceptanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuoteAcceptanceMaxAggregateInputType
  }

  export type GetQuoteAcceptanceAggregateType<T extends QuoteAcceptanceAggregateArgs> = {
        [P in keyof T & keyof AggregateQuoteAcceptance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuoteAcceptance[P]>
      : GetScalarType<T[P], AggregateQuoteAcceptance[P]>
  }




  export type QuoteAcceptanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuoteAcceptanceWhereInput
    orderBy?: QuoteAcceptanceOrderByWithAggregationInput | QuoteAcceptanceOrderByWithAggregationInput[]
    by: QuoteAcceptanceScalarFieldEnum[] | QuoteAcceptanceScalarFieldEnum
    having?: QuoteAcceptanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuoteAcceptanceCountAggregateInputType | true
    _min?: QuoteAcceptanceMinAggregateInputType
    _max?: QuoteAcceptanceMaxAggregateInputType
  }

  export type QuoteAcceptanceGroupByOutputType = {
    id: string
    orgId: string
    quoteId: string
    acceptedName: string
    acceptedEmail: string | null
    acceptedAt: Date
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date
    _count: QuoteAcceptanceCountAggregateOutputType | null
    _min: QuoteAcceptanceMinAggregateOutputType | null
    _max: QuoteAcceptanceMaxAggregateOutputType | null
  }

  type GetQuoteAcceptanceGroupByPayload<T extends QuoteAcceptanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuoteAcceptanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuoteAcceptanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuoteAcceptanceGroupByOutputType[P]>
            : GetScalarType<T[P], QuoteAcceptanceGroupByOutputType[P]>
        }
      >
    >


  export type QuoteAcceptanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    quoteId?: boolean
    acceptedName?: boolean
    acceptedEmail?: boolean
    acceptedAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    quote?: boolean | QuoteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quoteAcceptance"]>

  export type QuoteAcceptanceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    quoteId?: boolean
    acceptedName?: boolean
    acceptedEmail?: boolean
    acceptedAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    quote?: boolean | QuoteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quoteAcceptance"]>

  export type QuoteAcceptanceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    quoteId?: boolean
    acceptedName?: boolean
    acceptedEmail?: boolean
    acceptedAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    quote?: boolean | QuoteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quoteAcceptance"]>

  export type QuoteAcceptanceSelectScalar = {
    id?: boolean
    orgId?: boolean
    quoteId?: boolean
    acceptedName?: boolean
    acceptedEmail?: boolean
    acceptedAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
  }

  export type QuoteAcceptanceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orgId" | "quoteId" | "acceptedName" | "acceptedEmail" | "acceptedAt" | "ipAddress" | "userAgent" | "createdAt", ExtArgs["result"]["quoteAcceptance"]>
  export type QuoteAcceptanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quote?: boolean | QuoteDefaultArgs<ExtArgs>
  }
  export type QuoteAcceptanceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quote?: boolean | QuoteDefaultArgs<ExtArgs>
  }
  export type QuoteAcceptanceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quote?: boolean | QuoteDefaultArgs<ExtArgs>
  }

  export type $QuoteAcceptancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QuoteAcceptance"
    objects: {
      quote: Prisma.$QuotePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orgId: string
      quoteId: string
      acceptedName: string
      acceptedEmail: string | null
      acceptedAt: Date
      ipAddress: string | null
      userAgent: string | null
      createdAt: Date
    }, ExtArgs["result"]["quoteAcceptance"]>
    composites: {}
  }

  type QuoteAcceptanceGetPayload<S extends boolean | null | undefined | QuoteAcceptanceDefaultArgs> = $Result.GetResult<Prisma.$QuoteAcceptancePayload, S>

  type QuoteAcceptanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QuoteAcceptanceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuoteAcceptanceCountAggregateInputType | true
    }

  export interface QuoteAcceptanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QuoteAcceptance'], meta: { name: 'QuoteAcceptance' } }
    /**
     * Find zero or one QuoteAcceptance that matches the filter.
     * @param {QuoteAcceptanceFindUniqueArgs} args - Arguments to find a QuoteAcceptance
     * @example
     * // Get one QuoteAcceptance
     * const quoteAcceptance = await prisma.quoteAcceptance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuoteAcceptanceFindUniqueArgs>(args: SelectSubset<T, QuoteAcceptanceFindUniqueArgs<ExtArgs>>): Prisma__QuoteAcceptanceClient<$Result.GetResult<Prisma.$QuoteAcceptancePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one QuoteAcceptance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QuoteAcceptanceFindUniqueOrThrowArgs} args - Arguments to find a QuoteAcceptance
     * @example
     * // Get one QuoteAcceptance
     * const quoteAcceptance = await prisma.quoteAcceptance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuoteAcceptanceFindUniqueOrThrowArgs>(args: SelectSubset<T, QuoteAcceptanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuoteAcceptanceClient<$Result.GetResult<Prisma.$QuoteAcceptancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuoteAcceptance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteAcceptanceFindFirstArgs} args - Arguments to find a QuoteAcceptance
     * @example
     * // Get one QuoteAcceptance
     * const quoteAcceptance = await prisma.quoteAcceptance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuoteAcceptanceFindFirstArgs>(args?: SelectSubset<T, QuoteAcceptanceFindFirstArgs<ExtArgs>>): Prisma__QuoteAcceptanceClient<$Result.GetResult<Prisma.$QuoteAcceptancePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuoteAcceptance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteAcceptanceFindFirstOrThrowArgs} args - Arguments to find a QuoteAcceptance
     * @example
     * // Get one QuoteAcceptance
     * const quoteAcceptance = await prisma.quoteAcceptance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuoteAcceptanceFindFirstOrThrowArgs>(args?: SelectSubset<T, QuoteAcceptanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuoteAcceptanceClient<$Result.GetResult<Prisma.$QuoteAcceptancePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more QuoteAcceptances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteAcceptanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuoteAcceptances
     * const quoteAcceptances = await prisma.quoteAcceptance.findMany()
     * 
     * // Get first 10 QuoteAcceptances
     * const quoteAcceptances = await prisma.quoteAcceptance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quoteAcceptanceWithIdOnly = await prisma.quoteAcceptance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuoteAcceptanceFindManyArgs>(args?: SelectSubset<T, QuoteAcceptanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuoteAcceptancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a QuoteAcceptance.
     * @param {QuoteAcceptanceCreateArgs} args - Arguments to create a QuoteAcceptance.
     * @example
     * // Create one QuoteAcceptance
     * const QuoteAcceptance = await prisma.quoteAcceptance.create({
     *   data: {
     *     // ... data to create a QuoteAcceptance
     *   }
     * })
     * 
     */
    create<T extends QuoteAcceptanceCreateArgs>(args: SelectSubset<T, QuoteAcceptanceCreateArgs<ExtArgs>>): Prisma__QuoteAcceptanceClient<$Result.GetResult<Prisma.$QuoteAcceptancePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many QuoteAcceptances.
     * @param {QuoteAcceptanceCreateManyArgs} args - Arguments to create many QuoteAcceptances.
     * @example
     * // Create many QuoteAcceptances
     * const quoteAcceptance = await prisma.quoteAcceptance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuoteAcceptanceCreateManyArgs>(args?: SelectSubset<T, QuoteAcceptanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QuoteAcceptances and returns the data saved in the database.
     * @param {QuoteAcceptanceCreateManyAndReturnArgs} args - Arguments to create many QuoteAcceptances.
     * @example
     * // Create many QuoteAcceptances
     * const quoteAcceptance = await prisma.quoteAcceptance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QuoteAcceptances and only return the `id`
     * const quoteAcceptanceWithIdOnly = await prisma.quoteAcceptance.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuoteAcceptanceCreateManyAndReturnArgs>(args?: SelectSubset<T, QuoteAcceptanceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuoteAcceptancePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a QuoteAcceptance.
     * @param {QuoteAcceptanceDeleteArgs} args - Arguments to delete one QuoteAcceptance.
     * @example
     * // Delete one QuoteAcceptance
     * const QuoteAcceptance = await prisma.quoteAcceptance.delete({
     *   where: {
     *     // ... filter to delete one QuoteAcceptance
     *   }
     * })
     * 
     */
    delete<T extends QuoteAcceptanceDeleteArgs>(args: SelectSubset<T, QuoteAcceptanceDeleteArgs<ExtArgs>>): Prisma__QuoteAcceptanceClient<$Result.GetResult<Prisma.$QuoteAcceptancePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one QuoteAcceptance.
     * @param {QuoteAcceptanceUpdateArgs} args - Arguments to update one QuoteAcceptance.
     * @example
     * // Update one QuoteAcceptance
     * const quoteAcceptance = await prisma.quoteAcceptance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuoteAcceptanceUpdateArgs>(args: SelectSubset<T, QuoteAcceptanceUpdateArgs<ExtArgs>>): Prisma__QuoteAcceptanceClient<$Result.GetResult<Prisma.$QuoteAcceptancePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more QuoteAcceptances.
     * @param {QuoteAcceptanceDeleteManyArgs} args - Arguments to filter QuoteAcceptances to delete.
     * @example
     * // Delete a few QuoteAcceptances
     * const { count } = await prisma.quoteAcceptance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuoteAcceptanceDeleteManyArgs>(args?: SelectSubset<T, QuoteAcceptanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuoteAcceptances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteAcceptanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuoteAcceptances
     * const quoteAcceptance = await prisma.quoteAcceptance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuoteAcceptanceUpdateManyArgs>(args: SelectSubset<T, QuoteAcceptanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuoteAcceptances and returns the data updated in the database.
     * @param {QuoteAcceptanceUpdateManyAndReturnArgs} args - Arguments to update many QuoteAcceptances.
     * @example
     * // Update many QuoteAcceptances
     * const quoteAcceptance = await prisma.quoteAcceptance.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more QuoteAcceptances and only return the `id`
     * const quoteAcceptanceWithIdOnly = await prisma.quoteAcceptance.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QuoteAcceptanceUpdateManyAndReturnArgs>(args: SelectSubset<T, QuoteAcceptanceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuoteAcceptancePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one QuoteAcceptance.
     * @param {QuoteAcceptanceUpsertArgs} args - Arguments to update or create a QuoteAcceptance.
     * @example
     * // Update or create a QuoteAcceptance
     * const quoteAcceptance = await prisma.quoteAcceptance.upsert({
     *   create: {
     *     // ... data to create a QuoteAcceptance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuoteAcceptance we want to update
     *   }
     * })
     */
    upsert<T extends QuoteAcceptanceUpsertArgs>(args: SelectSubset<T, QuoteAcceptanceUpsertArgs<ExtArgs>>): Prisma__QuoteAcceptanceClient<$Result.GetResult<Prisma.$QuoteAcceptancePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of QuoteAcceptances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteAcceptanceCountArgs} args - Arguments to filter QuoteAcceptances to count.
     * @example
     * // Count the number of QuoteAcceptances
     * const count = await prisma.quoteAcceptance.count({
     *   where: {
     *     // ... the filter for the QuoteAcceptances we want to count
     *   }
     * })
    **/
    count<T extends QuoteAcceptanceCountArgs>(
      args?: Subset<T, QuoteAcceptanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuoteAcceptanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuoteAcceptance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteAcceptanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuoteAcceptanceAggregateArgs>(args: Subset<T, QuoteAcceptanceAggregateArgs>): Prisma.PrismaPromise<GetQuoteAcceptanceAggregateType<T>>

    /**
     * Group by QuoteAcceptance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuoteAcceptanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuoteAcceptanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuoteAcceptanceGroupByArgs['orderBy'] }
        : { orderBy?: QuoteAcceptanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuoteAcceptanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuoteAcceptanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QuoteAcceptance model
   */
  readonly fields: QuoteAcceptanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QuoteAcceptance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuoteAcceptanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    quote<T extends QuoteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuoteDefaultArgs<ExtArgs>>): Prisma__QuoteClient<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QuoteAcceptance model
   */
  interface QuoteAcceptanceFieldRefs {
    readonly id: FieldRef<"QuoteAcceptance", 'String'>
    readonly orgId: FieldRef<"QuoteAcceptance", 'String'>
    readonly quoteId: FieldRef<"QuoteAcceptance", 'String'>
    readonly acceptedName: FieldRef<"QuoteAcceptance", 'String'>
    readonly acceptedEmail: FieldRef<"QuoteAcceptance", 'String'>
    readonly acceptedAt: FieldRef<"QuoteAcceptance", 'DateTime'>
    readonly ipAddress: FieldRef<"QuoteAcceptance", 'String'>
    readonly userAgent: FieldRef<"QuoteAcceptance", 'String'>
    readonly createdAt: FieldRef<"QuoteAcceptance", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * QuoteAcceptance findUnique
   */
  export type QuoteAcceptanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteAcceptance
     */
    select?: QuoteAcceptanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuoteAcceptance
     */
    omit?: QuoteAcceptanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteAcceptanceInclude<ExtArgs> | null
    /**
     * Filter, which QuoteAcceptance to fetch.
     */
    where: QuoteAcceptanceWhereUniqueInput
  }

  /**
   * QuoteAcceptance findUniqueOrThrow
   */
  export type QuoteAcceptanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteAcceptance
     */
    select?: QuoteAcceptanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuoteAcceptance
     */
    omit?: QuoteAcceptanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteAcceptanceInclude<ExtArgs> | null
    /**
     * Filter, which QuoteAcceptance to fetch.
     */
    where: QuoteAcceptanceWhereUniqueInput
  }

  /**
   * QuoteAcceptance findFirst
   */
  export type QuoteAcceptanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteAcceptance
     */
    select?: QuoteAcceptanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuoteAcceptance
     */
    omit?: QuoteAcceptanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteAcceptanceInclude<ExtArgs> | null
    /**
     * Filter, which QuoteAcceptance to fetch.
     */
    where?: QuoteAcceptanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuoteAcceptances to fetch.
     */
    orderBy?: QuoteAcceptanceOrderByWithRelationInput | QuoteAcceptanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuoteAcceptances.
     */
    cursor?: QuoteAcceptanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuoteAcceptances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuoteAcceptances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuoteAcceptances.
     */
    distinct?: QuoteAcceptanceScalarFieldEnum | QuoteAcceptanceScalarFieldEnum[]
  }

  /**
   * QuoteAcceptance findFirstOrThrow
   */
  export type QuoteAcceptanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteAcceptance
     */
    select?: QuoteAcceptanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuoteAcceptance
     */
    omit?: QuoteAcceptanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteAcceptanceInclude<ExtArgs> | null
    /**
     * Filter, which QuoteAcceptance to fetch.
     */
    where?: QuoteAcceptanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuoteAcceptances to fetch.
     */
    orderBy?: QuoteAcceptanceOrderByWithRelationInput | QuoteAcceptanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuoteAcceptances.
     */
    cursor?: QuoteAcceptanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuoteAcceptances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuoteAcceptances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuoteAcceptances.
     */
    distinct?: QuoteAcceptanceScalarFieldEnum | QuoteAcceptanceScalarFieldEnum[]
  }

  /**
   * QuoteAcceptance findMany
   */
  export type QuoteAcceptanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteAcceptance
     */
    select?: QuoteAcceptanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuoteAcceptance
     */
    omit?: QuoteAcceptanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteAcceptanceInclude<ExtArgs> | null
    /**
     * Filter, which QuoteAcceptances to fetch.
     */
    where?: QuoteAcceptanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuoteAcceptances to fetch.
     */
    orderBy?: QuoteAcceptanceOrderByWithRelationInput | QuoteAcceptanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuoteAcceptances.
     */
    cursor?: QuoteAcceptanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuoteAcceptances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuoteAcceptances.
     */
    skip?: number
    distinct?: QuoteAcceptanceScalarFieldEnum | QuoteAcceptanceScalarFieldEnum[]
  }

  /**
   * QuoteAcceptance create
   */
  export type QuoteAcceptanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteAcceptance
     */
    select?: QuoteAcceptanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuoteAcceptance
     */
    omit?: QuoteAcceptanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteAcceptanceInclude<ExtArgs> | null
    /**
     * The data needed to create a QuoteAcceptance.
     */
    data: XOR<QuoteAcceptanceCreateInput, QuoteAcceptanceUncheckedCreateInput>
  }

  /**
   * QuoteAcceptance createMany
   */
  export type QuoteAcceptanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QuoteAcceptances.
     */
    data: QuoteAcceptanceCreateManyInput | QuoteAcceptanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QuoteAcceptance createManyAndReturn
   */
  export type QuoteAcceptanceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteAcceptance
     */
    select?: QuoteAcceptanceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuoteAcceptance
     */
    omit?: QuoteAcceptanceOmit<ExtArgs> | null
    /**
     * The data used to create many QuoteAcceptances.
     */
    data: QuoteAcceptanceCreateManyInput | QuoteAcceptanceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteAcceptanceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuoteAcceptance update
   */
  export type QuoteAcceptanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteAcceptance
     */
    select?: QuoteAcceptanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuoteAcceptance
     */
    omit?: QuoteAcceptanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteAcceptanceInclude<ExtArgs> | null
    /**
     * The data needed to update a QuoteAcceptance.
     */
    data: XOR<QuoteAcceptanceUpdateInput, QuoteAcceptanceUncheckedUpdateInput>
    /**
     * Choose, which QuoteAcceptance to update.
     */
    where: QuoteAcceptanceWhereUniqueInput
  }

  /**
   * QuoteAcceptance updateMany
   */
  export type QuoteAcceptanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QuoteAcceptances.
     */
    data: XOR<QuoteAcceptanceUpdateManyMutationInput, QuoteAcceptanceUncheckedUpdateManyInput>
    /**
     * Filter which QuoteAcceptances to update
     */
    where?: QuoteAcceptanceWhereInput
    /**
     * Limit how many QuoteAcceptances to update.
     */
    limit?: number
  }

  /**
   * QuoteAcceptance updateManyAndReturn
   */
  export type QuoteAcceptanceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteAcceptance
     */
    select?: QuoteAcceptanceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuoteAcceptance
     */
    omit?: QuoteAcceptanceOmit<ExtArgs> | null
    /**
     * The data used to update QuoteAcceptances.
     */
    data: XOR<QuoteAcceptanceUpdateManyMutationInput, QuoteAcceptanceUncheckedUpdateManyInput>
    /**
     * Filter which QuoteAcceptances to update
     */
    where?: QuoteAcceptanceWhereInput
    /**
     * Limit how many QuoteAcceptances to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteAcceptanceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuoteAcceptance upsert
   */
  export type QuoteAcceptanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteAcceptance
     */
    select?: QuoteAcceptanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuoteAcceptance
     */
    omit?: QuoteAcceptanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteAcceptanceInclude<ExtArgs> | null
    /**
     * The filter to search for the QuoteAcceptance to update in case it exists.
     */
    where: QuoteAcceptanceWhereUniqueInput
    /**
     * In case the QuoteAcceptance found by the `where` argument doesn't exist, create a new QuoteAcceptance with this data.
     */
    create: XOR<QuoteAcceptanceCreateInput, QuoteAcceptanceUncheckedCreateInput>
    /**
     * In case the QuoteAcceptance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuoteAcceptanceUpdateInput, QuoteAcceptanceUncheckedUpdateInput>
  }

  /**
   * QuoteAcceptance delete
   */
  export type QuoteAcceptanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteAcceptance
     */
    select?: QuoteAcceptanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuoteAcceptance
     */
    omit?: QuoteAcceptanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteAcceptanceInclude<ExtArgs> | null
    /**
     * Filter which QuoteAcceptance to delete.
     */
    where: QuoteAcceptanceWhereUniqueInput
  }

  /**
   * QuoteAcceptance deleteMany
   */
  export type QuoteAcceptanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuoteAcceptances to delete
     */
    where?: QuoteAcceptanceWhereInput
    /**
     * Limit how many QuoteAcceptances to delete.
     */
    limit?: number
  }

  /**
   * QuoteAcceptance without action
   */
  export type QuoteAcceptanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuoteAcceptance
     */
    select?: QuoteAcceptanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuoteAcceptance
     */
    omit?: QuoteAcceptanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuoteAcceptanceInclude<ExtArgs> | null
  }


  /**
   * Model PriceBookItem
   */

  export type AggregatePriceBookItem = {
    _count: PriceBookItemCountAggregateOutputType | null
    _avg: PriceBookItemAvgAggregateOutputType | null
    _sum: PriceBookItemSumAggregateOutputType | null
    _min: PriceBookItemMinAggregateOutputType | null
    _max: PriceBookItemMaxAggregateOutputType | null
  }

  export type PriceBookItemAvgAggregateOutputType = {
    defaultQty: Decimal | null
    defaultUnitPricePence: number | null
    defaultHours: Decimal | null
    defaultHourlyRatePence: number | null
    defaultSellPricePence: number | null
  }

  export type PriceBookItemSumAggregateOutputType = {
    defaultQty: Decimal | null
    defaultUnitPricePence: number | null
    defaultHours: Decimal | null
    defaultHourlyRatePence: number | null
    defaultSellPricePence: number | null
  }

  export type PriceBookItemMinAggregateOutputType = {
    id: string | null
    orgId: string | null
    title: string | null
    description: string | null
    calcType: $Enums.CalcType | null
    defaultQty: Decimal | null
    defaultUnit: string | null
    defaultUnitPricePence: number | null
    defaultHours: Decimal | null
    defaultHourlyRatePence: number | null
    defaultSellPricePence: number | null
    defaultIsAllowance: boolean | null
    roomTag: string | null
    tradeTag: string | null
    phaseTag: string | null
    isFavorite: boolean | null
    createdByUserId: string | null
    updatedByUserId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PriceBookItemMaxAggregateOutputType = {
    id: string | null
    orgId: string | null
    title: string | null
    description: string | null
    calcType: $Enums.CalcType | null
    defaultQty: Decimal | null
    defaultUnit: string | null
    defaultUnitPricePence: number | null
    defaultHours: Decimal | null
    defaultHourlyRatePence: number | null
    defaultSellPricePence: number | null
    defaultIsAllowance: boolean | null
    roomTag: string | null
    tradeTag: string | null
    phaseTag: string | null
    isFavorite: boolean | null
    createdByUserId: string | null
    updatedByUserId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PriceBookItemCountAggregateOutputType = {
    id: number
    orgId: number
    title: number
    description: number
    calcType: number
    defaultQty: number
    defaultUnit: number
    defaultUnitPricePence: number
    defaultHours: number
    defaultHourlyRatePence: number
    defaultSellPricePence: number
    defaultIsAllowance: number
    roomTag: number
    tradeTag: number
    phaseTag: number
    isFavorite: number
    createdByUserId: number
    updatedByUserId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PriceBookItemAvgAggregateInputType = {
    defaultQty?: true
    defaultUnitPricePence?: true
    defaultHours?: true
    defaultHourlyRatePence?: true
    defaultSellPricePence?: true
  }

  export type PriceBookItemSumAggregateInputType = {
    defaultQty?: true
    defaultUnitPricePence?: true
    defaultHours?: true
    defaultHourlyRatePence?: true
    defaultSellPricePence?: true
  }

  export type PriceBookItemMinAggregateInputType = {
    id?: true
    orgId?: true
    title?: true
    description?: true
    calcType?: true
    defaultQty?: true
    defaultUnit?: true
    defaultUnitPricePence?: true
    defaultHours?: true
    defaultHourlyRatePence?: true
    defaultSellPricePence?: true
    defaultIsAllowance?: true
    roomTag?: true
    tradeTag?: true
    phaseTag?: true
    isFavorite?: true
    createdByUserId?: true
    updatedByUserId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PriceBookItemMaxAggregateInputType = {
    id?: true
    orgId?: true
    title?: true
    description?: true
    calcType?: true
    defaultQty?: true
    defaultUnit?: true
    defaultUnitPricePence?: true
    defaultHours?: true
    defaultHourlyRatePence?: true
    defaultSellPricePence?: true
    defaultIsAllowance?: true
    roomTag?: true
    tradeTag?: true
    phaseTag?: true
    isFavorite?: true
    createdByUserId?: true
    updatedByUserId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PriceBookItemCountAggregateInputType = {
    id?: true
    orgId?: true
    title?: true
    description?: true
    calcType?: true
    defaultQty?: true
    defaultUnit?: true
    defaultUnitPricePence?: true
    defaultHours?: true
    defaultHourlyRatePence?: true
    defaultSellPricePence?: true
    defaultIsAllowance?: true
    roomTag?: true
    tradeTag?: true
    phaseTag?: true
    isFavorite?: true
    createdByUserId?: true
    updatedByUserId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PriceBookItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PriceBookItem to aggregate.
     */
    where?: PriceBookItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PriceBookItems to fetch.
     */
    orderBy?: PriceBookItemOrderByWithRelationInput | PriceBookItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PriceBookItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PriceBookItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PriceBookItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PriceBookItems
    **/
    _count?: true | PriceBookItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PriceBookItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PriceBookItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PriceBookItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PriceBookItemMaxAggregateInputType
  }

  export type GetPriceBookItemAggregateType<T extends PriceBookItemAggregateArgs> = {
        [P in keyof T & keyof AggregatePriceBookItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePriceBookItem[P]>
      : GetScalarType<T[P], AggregatePriceBookItem[P]>
  }




  export type PriceBookItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PriceBookItemWhereInput
    orderBy?: PriceBookItemOrderByWithAggregationInput | PriceBookItemOrderByWithAggregationInput[]
    by: PriceBookItemScalarFieldEnum[] | PriceBookItemScalarFieldEnum
    having?: PriceBookItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PriceBookItemCountAggregateInputType | true
    _avg?: PriceBookItemAvgAggregateInputType
    _sum?: PriceBookItemSumAggregateInputType
    _min?: PriceBookItemMinAggregateInputType
    _max?: PriceBookItemMaxAggregateInputType
  }

  export type PriceBookItemGroupByOutputType = {
    id: string
    orgId: string
    title: string
    description: string | null
    calcType: $Enums.CalcType
    defaultQty: Decimal | null
    defaultUnit: string | null
    defaultUnitPricePence: number | null
    defaultHours: Decimal | null
    defaultHourlyRatePence: number | null
    defaultSellPricePence: number | null
    defaultIsAllowance: boolean
    roomTag: string | null
    tradeTag: string | null
    phaseTag: string | null
    isFavorite: boolean
    createdByUserId: string | null
    updatedByUserId: string | null
    createdAt: Date
    updatedAt: Date
    _count: PriceBookItemCountAggregateOutputType | null
    _avg: PriceBookItemAvgAggregateOutputType | null
    _sum: PriceBookItemSumAggregateOutputType | null
    _min: PriceBookItemMinAggregateOutputType | null
    _max: PriceBookItemMaxAggregateOutputType | null
  }

  type GetPriceBookItemGroupByPayload<T extends PriceBookItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PriceBookItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PriceBookItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PriceBookItemGroupByOutputType[P]>
            : GetScalarType<T[P], PriceBookItemGroupByOutputType[P]>
        }
      >
    >


  export type PriceBookItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    title?: boolean
    description?: boolean
    calcType?: boolean
    defaultQty?: boolean
    defaultUnit?: boolean
    defaultUnitPricePence?: boolean
    defaultHours?: boolean
    defaultHourlyRatePence?: boolean
    defaultSellPricePence?: boolean
    defaultIsAllowance?: boolean
    roomTag?: boolean
    tradeTag?: boolean
    phaseTag?: boolean
    isFavorite?: boolean
    createdByUserId?: boolean
    updatedByUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["priceBookItem"]>

  export type PriceBookItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    title?: boolean
    description?: boolean
    calcType?: boolean
    defaultQty?: boolean
    defaultUnit?: boolean
    defaultUnitPricePence?: boolean
    defaultHours?: boolean
    defaultHourlyRatePence?: boolean
    defaultSellPricePence?: boolean
    defaultIsAllowance?: boolean
    roomTag?: boolean
    tradeTag?: boolean
    phaseTag?: boolean
    isFavorite?: boolean
    createdByUserId?: boolean
    updatedByUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["priceBookItem"]>

  export type PriceBookItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    title?: boolean
    description?: boolean
    calcType?: boolean
    defaultQty?: boolean
    defaultUnit?: boolean
    defaultUnitPricePence?: boolean
    defaultHours?: boolean
    defaultHourlyRatePence?: boolean
    defaultSellPricePence?: boolean
    defaultIsAllowance?: boolean
    roomTag?: boolean
    tradeTag?: boolean
    phaseTag?: boolean
    isFavorite?: boolean
    createdByUserId?: boolean
    updatedByUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["priceBookItem"]>

  export type PriceBookItemSelectScalar = {
    id?: boolean
    orgId?: boolean
    title?: boolean
    description?: boolean
    calcType?: boolean
    defaultQty?: boolean
    defaultUnit?: boolean
    defaultUnitPricePence?: boolean
    defaultHours?: boolean
    defaultHourlyRatePence?: boolean
    defaultSellPricePence?: boolean
    defaultIsAllowance?: boolean
    roomTag?: boolean
    tradeTag?: boolean
    phaseTag?: boolean
    isFavorite?: boolean
    createdByUserId?: boolean
    updatedByUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PriceBookItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orgId" | "title" | "description" | "calcType" | "defaultQty" | "defaultUnit" | "defaultUnitPricePence" | "defaultHours" | "defaultHourlyRatePence" | "defaultSellPricePence" | "defaultIsAllowance" | "roomTag" | "tradeTag" | "phaseTag" | "isFavorite" | "createdByUserId" | "updatedByUserId" | "createdAt" | "updatedAt", ExtArgs["result"]["priceBookItem"]>

  export type $PriceBookItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PriceBookItem"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orgId: string
      title: string
      description: string | null
      calcType: $Enums.CalcType
      defaultQty: Prisma.Decimal | null
      defaultUnit: string | null
      defaultUnitPricePence: number | null
      defaultHours: Prisma.Decimal | null
      defaultHourlyRatePence: number | null
      defaultSellPricePence: number | null
      defaultIsAllowance: boolean
      roomTag: string | null
      tradeTag: string | null
      phaseTag: string | null
      isFavorite: boolean
      createdByUserId: string | null
      updatedByUserId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["priceBookItem"]>
    composites: {}
  }

  type PriceBookItemGetPayload<S extends boolean | null | undefined | PriceBookItemDefaultArgs> = $Result.GetResult<Prisma.$PriceBookItemPayload, S>

  type PriceBookItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PriceBookItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PriceBookItemCountAggregateInputType | true
    }

  export interface PriceBookItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PriceBookItem'], meta: { name: 'PriceBookItem' } }
    /**
     * Find zero or one PriceBookItem that matches the filter.
     * @param {PriceBookItemFindUniqueArgs} args - Arguments to find a PriceBookItem
     * @example
     * // Get one PriceBookItem
     * const priceBookItem = await prisma.priceBookItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PriceBookItemFindUniqueArgs>(args: SelectSubset<T, PriceBookItemFindUniqueArgs<ExtArgs>>): Prisma__PriceBookItemClient<$Result.GetResult<Prisma.$PriceBookItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PriceBookItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PriceBookItemFindUniqueOrThrowArgs} args - Arguments to find a PriceBookItem
     * @example
     * // Get one PriceBookItem
     * const priceBookItem = await prisma.priceBookItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PriceBookItemFindUniqueOrThrowArgs>(args: SelectSubset<T, PriceBookItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PriceBookItemClient<$Result.GetResult<Prisma.$PriceBookItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PriceBookItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceBookItemFindFirstArgs} args - Arguments to find a PriceBookItem
     * @example
     * // Get one PriceBookItem
     * const priceBookItem = await prisma.priceBookItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PriceBookItemFindFirstArgs>(args?: SelectSubset<T, PriceBookItemFindFirstArgs<ExtArgs>>): Prisma__PriceBookItemClient<$Result.GetResult<Prisma.$PriceBookItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PriceBookItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceBookItemFindFirstOrThrowArgs} args - Arguments to find a PriceBookItem
     * @example
     * // Get one PriceBookItem
     * const priceBookItem = await prisma.priceBookItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PriceBookItemFindFirstOrThrowArgs>(args?: SelectSubset<T, PriceBookItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__PriceBookItemClient<$Result.GetResult<Prisma.$PriceBookItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PriceBookItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceBookItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PriceBookItems
     * const priceBookItems = await prisma.priceBookItem.findMany()
     * 
     * // Get first 10 PriceBookItems
     * const priceBookItems = await prisma.priceBookItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const priceBookItemWithIdOnly = await prisma.priceBookItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PriceBookItemFindManyArgs>(args?: SelectSubset<T, PriceBookItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PriceBookItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PriceBookItem.
     * @param {PriceBookItemCreateArgs} args - Arguments to create a PriceBookItem.
     * @example
     * // Create one PriceBookItem
     * const PriceBookItem = await prisma.priceBookItem.create({
     *   data: {
     *     // ... data to create a PriceBookItem
     *   }
     * })
     * 
     */
    create<T extends PriceBookItemCreateArgs>(args: SelectSubset<T, PriceBookItemCreateArgs<ExtArgs>>): Prisma__PriceBookItemClient<$Result.GetResult<Prisma.$PriceBookItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PriceBookItems.
     * @param {PriceBookItemCreateManyArgs} args - Arguments to create many PriceBookItems.
     * @example
     * // Create many PriceBookItems
     * const priceBookItem = await prisma.priceBookItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PriceBookItemCreateManyArgs>(args?: SelectSubset<T, PriceBookItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PriceBookItems and returns the data saved in the database.
     * @param {PriceBookItemCreateManyAndReturnArgs} args - Arguments to create many PriceBookItems.
     * @example
     * // Create many PriceBookItems
     * const priceBookItem = await prisma.priceBookItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PriceBookItems and only return the `id`
     * const priceBookItemWithIdOnly = await prisma.priceBookItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PriceBookItemCreateManyAndReturnArgs>(args?: SelectSubset<T, PriceBookItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PriceBookItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PriceBookItem.
     * @param {PriceBookItemDeleteArgs} args - Arguments to delete one PriceBookItem.
     * @example
     * // Delete one PriceBookItem
     * const PriceBookItem = await prisma.priceBookItem.delete({
     *   where: {
     *     // ... filter to delete one PriceBookItem
     *   }
     * })
     * 
     */
    delete<T extends PriceBookItemDeleteArgs>(args: SelectSubset<T, PriceBookItemDeleteArgs<ExtArgs>>): Prisma__PriceBookItemClient<$Result.GetResult<Prisma.$PriceBookItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PriceBookItem.
     * @param {PriceBookItemUpdateArgs} args - Arguments to update one PriceBookItem.
     * @example
     * // Update one PriceBookItem
     * const priceBookItem = await prisma.priceBookItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PriceBookItemUpdateArgs>(args: SelectSubset<T, PriceBookItemUpdateArgs<ExtArgs>>): Prisma__PriceBookItemClient<$Result.GetResult<Prisma.$PriceBookItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PriceBookItems.
     * @param {PriceBookItemDeleteManyArgs} args - Arguments to filter PriceBookItems to delete.
     * @example
     * // Delete a few PriceBookItems
     * const { count } = await prisma.priceBookItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PriceBookItemDeleteManyArgs>(args?: SelectSubset<T, PriceBookItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PriceBookItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceBookItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PriceBookItems
     * const priceBookItem = await prisma.priceBookItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PriceBookItemUpdateManyArgs>(args: SelectSubset<T, PriceBookItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PriceBookItems and returns the data updated in the database.
     * @param {PriceBookItemUpdateManyAndReturnArgs} args - Arguments to update many PriceBookItems.
     * @example
     * // Update many PriceBookItems
     * const priceBookItem = await prisma.priceBookItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PriceBookItems and only return the `id`
     * const priceBookItemWithIdOnly = await prisma.priceBookItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PriceBookItemUpdateManyAndReturnArgs>(args: SelectSubset<T, PriceBookItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PriceBookItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PriceBookItem.
     * @param {PriceBookItemUpsertArgs} args - Arguments to update or create a PriceBookItem.
     * @example
     * // Update or create a PriceBookItem
     * const priceBookItem = await prisma.priceBookItem.upsert({
     *   create: {
     *     // ... data to create a PriceBookItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PriceBookItem we want to update
     *   }
     * })
     */
    upsert<T extends PriceBookItemUpsertArgs>(args: SelectSubset<T, PriceBookItemUpsertArgs<ExtArgs>>): Prisma__PriceBookItemClient<$Result.GetResult<Prisma.$PriceBookItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PriceBookItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceBookItemCountArgs} args - Arguments to filter PriceBookItems to count.
     * @example
     * // Count the number of PriceBookItems
     * const count = await prisma.priceBookItem.count({
     *   where: {
     *     // ... the filter for the PriceBookItems we want to count
     *   }
     * })
    **/
    count<T extends PriceBookItemCountArgs>(
      args?: Subset<T, PriceBookItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PriceBookItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PriceBookItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceBookItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PriceBookItemAggregateArgs>(args: Subset<T, PriceBookItemAggregateArgs>): Prisma.PrismaPromise<GetPriceBookItemAggregateType<T>>

    /**
     * Group by PriceBookItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceBookItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PriceBookItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PriceBookItemGroupByArgs['orderBy'] }
        : { orderBy?: PriceBookItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PriceBookItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPriceBookItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PriceBookItem model
   */
  readonly fields: PriceBookItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PriceBookItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PriceBookItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PriceBookItem model
   */
  interface PriceBookItemFieldRefs {
    readonly id: FieldRef<"PriceBookItem", 'String'>
    readonly orgId: FieldRef<"PriceBookItem", 'String'>
    readonly title: FieldRef<"PriceBookItem", 'String'>
    readonly description: FieldRef<"PriceBookItem", 'String'>
    readonly calcType: FieldRef<"PriceBookItem", 'CalcType'>
    readonly defaultQty: FieldRef<"PriceBookItem", 'Decimal'>
    readonly defaultUnit: FieldRef<"PriceBookItem", 'String'>
    readonly defaultUnitPricePence: FieldRef<"PriceBookItem", 'Int'>
    readonly defaultHours: FieldRef<"PriceBookItem", 'Decimal'>
    readonly defaultHourlyRatePence: FieldRef<"PriceBookItem", 'Int'>
    readonly defaultSellPricePence: FieldRef<"PriceBookItem", 'Int'>
    readonly defaultIsAllowance: FieldRef<"PriceBookItem", 'Boolean'>
    readonly roomTag: FieldRef<"PriceBookItem", 'String'>
    readonly tradeTag: FieldRef<"PriceBookItem", 'String'>
    readonly phaseTag: FieldRef<"PriceBookItem", 'String'>
    readonly isFavorite: FieldRef<"PriceBookItem", 'Boolean'>
    readonly createdByUserId: FieldRef<"PriceBookItem", 'String'>
    readonly updatedByUserId: FieldRef<"PriceBookItem", 'String'>
    readonly createdAt: FieldRef<"PriceBookItem", 'DateTime'>
    readonly updatedAt: FieldRef<"PriceBookItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PriceBookItem findUnique
   */
  export type PriceBookItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceBookItem
     */
    select?: PriceBookItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceBookItem
     */
    omit?: PriceBookItemOmit<ExtArgs> | null
    /**
     * Filter, which PriceBookItem to fetch.
     */
    where: PriceBookItemWhereUniqueInput
  }

  /**
   * PriceBookItem findUniqueOrThrow
   */
  export type PriceBookItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceBookItem
     */
    select?: PriceBookItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceBookItem
     */
    omit?: PriceBookItemOmit<ExtArgs> | null
    /**
     * Filter, which PriceBookItem to fetch.
     */
    where: PriceBookItemWhereUniqueInput
  }

  /**
   * PriceBookItem findFirst
   */
  export type PriceBookItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceBookItem
     */
    select?: PriceBookItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceBookItem
     */
    omit?: PriceBookItemOmit<ExtArgs> | null
    /**
     * Filter, which PriceBookItem to fetch.
     */
    where?: PriceBookItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PriceBookItems to fetch.
     */
    orderBy?: PriceBookItemOrderByWithRelationInput | PriceBookItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PriceBookItems.
     */
    cursor?: PriceBookItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PriceBookItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PriceBookItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PriceBookItems.
     */
    distinct?: PriceBookItemScalarFieldEnum | PriceBookItemScalarFieldEnum[]
  }

  /**
   * PriceBookItem findFirstOrThrow
   */
  export type PriceBookItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceBookItem
     */
    select?: PriceBookItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceBookItem
     */
    omit?: PriceBookItemOmit<ExtArgs> | null
    /**
     * Filter, which PriceBookItem to fetch.
     */
    where?: PriceBookItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PriceBookItems to fetch.
     */
    orderBy?: PriceBookItemOrderByWithRelationInput | PriceBookItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PriceBookItems.
     */
    cursor?: PriceBookItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PriceBookItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PriceBookItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PriceBookItems.
     */
    distinct?: PriceBookItemScalarFieldEnum | PriceBookItemScalarFieldEnum[]
  }

  /**
   * PriceBookItem findMany
   */
  export type PriceBookItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceBookItem
     */
    select?: PriceBookItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceBookItem
     */
    omit?: PriceBookItemOmit<ExtArgs> | null
    /**
     * Filter, which PriceBookItems to fetch.
     */
    where?: PriceBookItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PriceBookItems to fetch.
     */
    orderBy?: PriceBookItemOrderByWithRelationInput | PriceBookItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PriceBookItems.
     */
    cursor?: PriceBookItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PriceBookItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PriceBookItems.
     */
    skip?: number
    distinct?: PriceBookItemScalarFieldEnum | PriceBookItemScalarFieldEnum[]
  }

  /**
   * PriceBookItem create
   */
  export type PriceBookItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceBookItem
     */
    select?: PriceBookItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceBookItem
     */
    omit?: PriceBookItemOmit<ExtArgs> | null
    /**
     * The data needed to create a PriceBookItem.
     */
    data: XOR<PriceBookItemCreateInput, PriceBookItemUncheckedCreateInput>
  }

  /**
   * PriceBookItem createMany
   */
  export type PriceBookItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PriceBookItems.
     */
    data: PriceBookItemCreateManyInput | PriceBookItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PriceBookItem createManyAndReturn
   */
  export type PriceBookItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceBookItem
     */
    select?: PriceBookItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PriceBookItem
     */
    omit?: PriceBookItemOmit<ExtArgs> | null
    /**
     * The data used to create many PriceBookItems.
     */
    data: PriceBookItemCreateManyInput | PriceBookItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PriceBookItem update
   */
  export type PriceBookItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceBookItem
     */
    select?: PriceBookItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceBookItem
     */
    omit?: PriceBookItemOmit<ExtArgs> | null
    /**
     * The data needed to update a PriceBookItem.
     */
    data: XOR<PriceBookItemUpdateInput, PriceBookItemUncheckedUpdateInput>
    /**
     * Choose, which PriceBookItem to update.
     */
    where: PriceBookItemWhereUniqueInput
  }

  /**
   * PriceBookItem updateMany
   */
  export type PriceBookItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PriceBookItems.
     */
    data: XOR<PriceBookItemUpdateManyMutationInput, PriceBookItemUncheckedUpdateManyInput>
    /**
     * Filter which PriceBookItems to update
     */
    where?: PriceBookItemWhereInput
    /**
     * Limit how many PriceBookItems to update.
     */
    limit?: number
  }

  /**
   * PriceBookItem updateManyAndReturn
   */
  export type PriceBookItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceBookItem
     */
    select?: PriceBookItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PriceBookItem
     */
    omit?: PriceBookItemOmit<ExtArgs> | null
    /**
     * The data used to update PriceBookItems.
     */
    data: XOR<PriceBookItemUpdateManyMutationInput, PriceBookItemUncheckedUpdateManyInput>
    /**
     * Filter which PriceBookItems to update
     */
    where?: PriceBookItemWhereInput
    /**
     * Limit how many PriceBookItems to update.
     */
    limit?: number
  }

  /**
   * PriceBookItem upsert
   */
  export type PriceBookItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceBookItem
     */
    select?: PriceBookItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceBookItem
     */
    omit?: PriceBookItemOmit<ExtArgs> | null
    /**
     * The filter to search for the PriceBookItem to update in case it exists.
     */
    where: PriceBookItemWhereUniqueInput
    /**
     * In case the PriceBookItem found by the `where` argument doesn't exist, create a new PriceBookItem with this data.
     */
    create: XOR<PriceBookItemCreateInput, PriceBookItemUncheckedCreateInput>
    /**
     * In case the PriceBookItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PriceBookItemUpdateInput, PriceBookItemUncheckedUpdateInput>
  }

  /**
   * PriceBookItem delete
   */
  export type PriceBookItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceBookItem
     */
    select?: PriceBookItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceBookItem
     */
    omit?: PriceBookItemOmit<ExtArgs> | null
    /**
     * Filter which PriceBookItem to delete.
     */
    where: PriceBookItemWhereUniqueInput
  }

  /**
   * PriceBookItem deleteMany
   */
  export type PriceBookItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PriceBookItems to delete
     */
    where?: PriceBookItemWhereInput
    /**
     * Limit how many PriceBookItems to delete.
     */
    limit?: number
  }

  /**
   * PriceBookItem without action
   */
  export type PriceBookItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceBookItem
     */
    select?: PriceBookItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PriceBookItem
     */
    omit?: PriceBookItemOmit<ExtArgs> | null
  }


  /**
   * Model TemplateSection
   */

  export type AggregateTemplateSection = {
    _count: TemplateSectionCountAggregateOutputType | null
    _min: TemplateSectionMinAggregateOutputType | null
    _max: TemplateSectionMaxAggregateOutputType | null
  }

  export type TemplateSectionMinAggregateOutputType = {
    id: string | null
    orgId: string | null
    name: string | null
    description: string | null
    createdByUserId: string | null
    updatedByUserId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TemplateSectionMaxAggregateOutputType = {
    id: string | null
    orgId: string | null
    name: string | null
    description: string | null
    createdByUserId: string | null
    updatedByUserId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TemplateSectionCountAggregateOutputType = {
    id: number
    orgId: number
    name: number
    description: number
    createdByUserId: number
    updatedByUserId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TemplateSectionMinAggregateInputType = {
    id?: true
    orgId?: true
    name?: true
    description?: true
    createdByUserId?: true
    updatedByUserId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TemplateSectionMaxAggregateInputType = {
    id?: true
    orgId?: true
    name?: true
    description?: true
    createdByUserId?: true
    updatedByUserId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TemplateSectionCountAggregateInputType = {
    id?: true
    orgId?: true
    name?: true
    description?: true
    createdByUserId?: true
    updatedByUserId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TemplateSectionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TemplateSection to aggregate.
     */
    where?: TemplateSectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TemplateSections to fetch.
     */
    orderBy?: TemplateSectionOrderByWithRelationInput | TemplateSectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TemplateSectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TemplateSections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TemplateSections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TemplateSections
    **/
    _count?: true | TemplateSectionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TemplateSectionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TemplateSectionMaxAggregateInputType
  }

  export type GetTemplateSectionAggregateType<T extends TemplateSectionAggregateArgs> = {
        [P in keyof T & keyof AggregateTemplateSection]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTemplateSection[P]>
      : GetScalarType<T[P], AggregateTemplateSection[P]>
  }




  export type TemplateSectionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TemplateSectionWhereInput
    orderBy?: TemplateSectionOrderByWithAggregationInput | TemplateSectionOrderByWithAggregationInput[]
    by: TemplateSectionScalarFieldEnum[] | TemplateSectionScalarFieldEnum
    having?: TemplateSectionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TemplateSectionCountAggregateInputType | true
    _min?: TemplateSectionMinAggregateInputType
    _max?: TemplateSectionMaxAggregateInputType
  }

  export type TemplateSectionGroupByOutputType = {
    id: string
    orgId: string
    name: string
    description: string | null
    createdByUserId: string | null
    updatedByUserId: string | null
    createdAt: Date
    updatedAt: Date
    _count: TemplateSectionCountAggregateOutputType | null
    _min: TemplateSectionMinAggregateOutputType | null
    _max: TemplateSectionMaxAggregateOutputType | null
  }

  type GetTemplateSectionGroupByPayload<T extends TemplateSectionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TemplateSectionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TemplateSectionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TemplateSectionGroupByOutputType[P]>
            : GetScalarType<T[P], TemplateSectionGroupByOutputType[P]>
        }
      >
    >


  export type TemplateSectionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    name?: boolean
    description?: boolean
    createdByUserId?: boolean
    updatedByUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    items?: boolean | TemplateSection$itemsArgs<ExtArgs>
    _count?: boolean | TemplateSectionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["templateSection"]>

  export type TemplateSectionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    name?: boolean
    description?: boolean
    createdByUserId?: boolean
    updatedByUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["templateSection"]>

  export type TemplateSectionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    name?: boolean
    description?: boolean
    createdByUserId?: boolean
    updatedByUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["templateSection"]>

  export type TemplateSectionSelectScalar = {
    id?: boolean
    orgId?: boolean
    name?: boolean
    description?: boolean
    createdByUserId?: boolean
    updatedByUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TemplateSectionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orgId" | "name" | "description" | "createdByUserId" | "updatedByUserId" | "createdAt" | "updatedAt", ExtArgs["result"]["templateSection"]>
  export type TemplateSectionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | TemplateSection$itemsArgs<ExtArgs>
    _count?: boolean | TemplateSectionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TemplateSectionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TemplateSectionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TemplateSectionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TemplateSection"
    objects: {
      items: Prisma.$TemplateSectionItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orgId: string
      name: string
      description: string | null
      createdByUserId: string | null
      updatedByUserId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["templateSection"]>
    composites: {}
  }

  type TemplateSectionGetPayload<S extends boolean | null | undefined | TemplateSectionDefaultArgs> = $Result.GetResult<Prisma.$TemplateSectionPayload, S>

  type TemplateSectionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TemplateSectionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TemplateSectionCountAggregateInputType | true
    }

  export interface TemplateSectionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TemplateSection'], meta: { name: 'TemplateSection' } }
    /**
     * Find zero or one TemplateSection that matches the filter.
     * @param {TemplateSectionFindUniqueArgs} args - Arguments to find a TemplateSection
     * @example
     * // Get one TemplateSection
     * const templateSection = await prisma.templateSection.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TemplateSectionFindUniqueArgs>(args: SelectSubset<T, TemplateSectionFindUniqueArgs<ExtArgs>>): Prisma__TemplateSectionClient<$Result.GetResult<Prisma.$TemplateSectionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TemplateSection that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TemplateSectionFindUniqueOrThrowArgs} args - Arguments to find a TemplateSection
     * @example
     * // Get one TemplateSection
     * const templateSection = await prisma.templateSection.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TemplateSectionFindUniqueOrThrowArgs>(args: SelectSubset<T, TemplateSectionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TemplateSectionClient<$Result.GetResult<Prisma.$TemplateSectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TemplateSection that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateSectionFindFirstArgs} args - Arguments to find a TemplateSection
     * @example
     * // Get one TemplateSection
     * const templateSection = await prisma.templateSection.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TemplateSectionFindFirstArgs>(args?: SelectSubset<T, TemplateSectionFindFirstArgs<ExtArgs>>): Prisma__TemplateSectionClient<$Result.GetResult<Prisma.$TemplateSectionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TemplateSection that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateSectionFindFirstOrThrowArgs} args - Arguments to find a TemplateSection
     * @example
     * // Get one TemplateSection
     * const templateSection = await prisma.templateSection.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TemplateSectionFindFirstOrThrowArgs>(args?: SelectSubset<T, TemplateSectionFindFirstOrThrowArgs<ExtArgs>>): Prisma__TemplateSectionClient<$Result.GetResult<Prisma.$TemplateSectionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TemplateSections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateSectionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TemplateSections
     * const templateSections = await prisma.templateSection.findMany()
     * 
     * // Get first 10 TemplateSections
     * const templateSections = await prisma.templateSection.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const templateSectionWithIdOnly = await prisma.templateSection.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TemplateSectionFindManyArgs>(args?: SelectSubset<T, TemplateSectionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TemplateSectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TemplateSection.
     * @param {TemplateSectionCreateArgs} args - Arguments to create a TemplateSection.
     * @example
     * // Create one TemplateSection
     * const TemplateSection = await prisma.templateSection.create({
     *   data: {
     *     // ... data to create a TemplateSection
     *   }
     * })
     * 
     */
    create<T extends TemplateSectionCreateArgs>(args: SelectSubset<T, TemplateSectionCreateArgs<ExtArgs>>): Prisma__TemplateSectionClient<$Result.GetResult<Prisma.$TemplateSectionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TemplateSections.
     * @param {TemplateSectionCreateManyArgs} args - Arguments to create many TemplateSections.
     * @example
     * // Create many TemplateSections
     * const templateSection = await prisma.templateSection.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TemplateSectionCreateManyArgs>(args?: SelectSubset<T, TemplateSectionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TemplateSections and returns the data saved in the database.
     * @param {TemplateSectionCreateManyAndReturnArgs} args - Arguments to create many TemplateSections.
     * @example
     * // Create many TemplateSections
     * const templateSection = await prisma.templateSection.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TemplateSections and only return the `id`
     * const templateSectionWithIdOnly = await prisma.templateSection.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TemplateSectionCreateManyAndReturnArgs>(args?: SelectSubset<T, TemplateSectionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TemplateSectionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TemplateSection.
     * @param {TemplateSectionDeleteArgs} args - Arguments to delete one TemplateSection.
     * @example
     * // Delete one TemplateSection
     * const TemplateSection = await prisma.templateSection.delete({
     *   where: {
     *     // ... filter to delete one TemplateSection
     *   }
     * })
     * 
     */
    delete<T extends TemplateSectionDeleteArgs>(args: SelectSubset<T, TemplateSectionDeleteArgs<ExtArgs>>): Prisma__TemplateSectionClient<$Result.GetResult<Prisma.$TemplateSectionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TemplateSection.
     * @param {TemplateSectionUpdateArgs} args - Arguments to update one TemplateSection.
     * @example
     * // Update one TemplateSection
     * const templateSection = await prisma.templateSection.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TemplateSectionUpdateArgs>(args: SelectSubset<T, TemplateSectionUpdateArgs<ExtArgs>>): Prisma__TemplateSectionClient<$Result.GetResult<Prisma.$TemplateSectionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TemplateSections.
     * @param {TemplateSectionDeleteManyArgs} args - Arguments to filter TemplateSections to delete.
     * @example
     * // Delete a few TemplateSections
     * const { count } = await prisma.templateSection.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TemplateSectionDeleteManyArgs>(args?: SelectSubset<T, TemplateSectionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TemplateSections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateSectionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TemplateSections
     * const templateSection = await prisma.templateSection.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TemplateSectionUpdateManyArgs>(args: SelectSubset<T, TemplateSectionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TemplateSections and returns the data updated in the database.
     * @param {TemplateSectionUpdateManyAndReturnArgs} args - Arguments to update many TemplateSections.
     * @example
     * // Update many TemplateSections
     * const templateSection = await prisma.templateSection.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TemplateSections and only return the `id`
     * const templateSectionWithIdOnly = await prisma.templateSection.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TemplateSectionUpdateManyAndReturnArgs>(args: SelectSubset<T, TemplateSectionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TemplateSectionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TemplateSection.
     * @param {TemplateSectionUpsertArgs} args - Arguments to update or create a TemplateSection.
     * @example
     * // Update or create a TemplateSection
     * const templateSection = await prisma.templateSection.upsert({
     *   create: {
     *     // ... data to create a TemplateSection
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TemplateSection we want to update
     *   }
     * })
     */
    upsert<T extends TemplateSectionUpsertArgs>(args: SelectSubset<T, TemplateSectionUpsertArgs<ExtArgs>>): Prisma__TemplateSectionClient<$Result.GetResult<Prisma.$TemplateSectionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TemplateSections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateSectionCountArgs} args - Arguments to filter TemplateSections to count.
     * @example
     * // Count the number of TemplateSections
     * const count = await prisma.templateSection.count({
     *   where: {
     *     // ... the filter for the TemplateSections we want to count
     *   }
     * })
    **/
    count<T extends TemplateSectionCountArgs>(
      args?: Subset<T, TemplateSectionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TemplateSectionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TemplateSection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateSectionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TemplateSectionAggregateArgs>(args: Subset<T, TemplateSectionAggregateArgs>): Prisma.PrismaPromise<GetTemplateSectionAggregateType<T>>

    /**
     * Group by TemplateSection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateSectionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TemplateSectionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TemplateSectionGroupByArgs['orderBy'] }
        : { orderBy?: TemplateSectionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TemplateSectionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTemplateSectionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TemplateSection model
   */
  readonly fields: TemplateSectionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TemplateSection.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TemplateSectionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    items<T extends TemplateSection$itemsArgs<ExtArgs> = {}>(args?: Subset<T, TemplateSection$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TemplateSectionItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TemplateSection model
   */
  interface TemplateSectionFieldRefs {
    readonly id: FieldRef<"TemplateSection", 'String'>
    readonly orgId: FieldRef<"TemplateSection", 'String'>
    readonly name: FieldRef<"TemplateSection", 'String'>
    readonly description: FieldRef<"TemplateSection", 'String'>
    readonly createdByUserId: FieldRef<"TemplateSection", 'String'>
    readonly updatedByUserId: FieldRef<"TemplateSection", 'String'>
    readonly createdAt: FieldRef<"TemplateSection", 'DateTime'>
    readonly updatedAt: FieldRef<"TemplateSection", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TemplateSection findUnique
   */
  export type TemplateSectionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateSection
     */
    select?: TemplateSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateSection
     */
    omit?: TemplateSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateSectionInclude<ExtArgs> | null
    /**
     * Filter, which TemplateSection to fetch.
     */
    where: TemplateSectionWhereUniqueInput
  }

  /**
   * TemplateSection findUniqueOrThrow
   */
  export type TemplateSectionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateSection
     */
    select?: TemplateSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateSection
     */
    omit?: TemplateSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateSectionInclude<ExtArgs> | null
    /**
     * Filter, which TemplateSection to fetch.
     */
    where: TemplateSectionWhereUniqueInput
  }

  /**
   * TemplateSection findFirst
   */
  export type TemplateSectionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateSection
     */
    select?: TemplateSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateSection
     */
    omit?: TemplateSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateSectionInclude<ExtArgs> | null
    /**
     * Filter, which TemplateSection to fetch.
     */
    where?: TemplateSectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TemplateSections to fetch.
     */
    orderBy?: TemplateSectionOrderByWithRelationInput | TemplateSectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TemplateSections.
     */
    cursor?: TemplateSectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TemplateSections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TemplateSections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TemplateSections.
     */
    distinct?: TemplateSectionScalarFieldEnum | TemplateSectionScalarFieldEnum[]
  }

  /**
   * TemplateSection findFirstOrThrow
   */
  export type TemplateSectionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateSection
     */
    select?: TemplateSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateSection
     */
    omit?: TemplateSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateSectionInclude<ExtArgs> | null
    /**
     * Filter, which TemplateSection to fetch.
     */
    where?: TemplateSectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TemplateSections to fetch.
     */
    orderBy?: TemplateSectionOrderByWithRelationInput | TemplateSectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TemplateSections.
     */
    cursor?: TemplateSectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TemplateSections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TemplateSections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TemplateSections.
     */
    distinct?: TemplateSectionScalarFieldEnum | TemplateSectionScalarFieldEnum[]
  }

  /**
   * TemplateSection findMany
   */
  export type TemplateSectionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateSection
     */
    select?: TemplateSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateSection
     */
    omit?: TemplateSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateSectionInclude<ExtArgs> | null
    /**
     * Filter, which TemplateSections to fetch.
     */
    where?: TemplateSectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TemplateSections to fetch.
     */
    orderBy?: TemplateSectionOrderByWithRelationInput | TemplateSectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TemplateSections.
     */
    cursor?: TemplateSectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TemplateSections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TemplateSections.
     */
    skip?: number
    distinct?: TemplateSectionScalarFieldEnum | TemplateSectionScalarFieldEnum[]
  }

  /**
   * TemplateSection create
   */
  export type TemplateSectionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateSection
     */
    select?: TemplateSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateSection
     */
    omit?: TemplateSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateSectionInclude<ExtArgs> | null
    /**
     * The data needed to create a TemplateSection.
     */
    data: XOR<TemplateSectionCreateInput, TemplateSectionUncheckedCreateInput>
  }

  /**
   * TemplateSection createMany
   */
  export type TemplateSectionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TemplateSections.
     */
    data: TemplateSectionCreateManyInput | TemplateSectionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TemplateSection createManyAndReturn
   */
  export type TemplateSectionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateSection
     */
    select?: TemplateSectionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateSection
     */
    omit?: TemplateSectionOmit<ExtArgs> | null
    /**
     * The data used to create many TemplateSections.
     */
    data: TemplateSectionCreateManyInput | TemplateSectionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TemplateSection update
   */
  export type TemplateSectionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateSection
     */
    select?: TemplateSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateSection
     */
    omit?: TemplateSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateSectionInclude<ExtArgs> | null
    /**
     * The data needed to update a TemplateSection.
     */
    data: XOR<TemplateSectionUpdateInput, TemplateSectionUncheckedUpdateInput>
    /**
     * Choose, which TemplateSection to update.
     */
    where: TemplateSectionWhereUniqueInput
  }

  /**
   * TemplateSection updateMany
   */
  export type TemplateSectionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TemplateSections.
     */
    data: XOR<TemplateSectionUpdateManyMutationInput, TemplateSectionUncheckedUpdateManyInput>
    /**
     * Filter which TemplateSections to update
     */
    where?: TemplateSectionWhereInput
    /**
     * Limit how many TemplateSections to update.
     */
    limit?: number
  }

  /**
   * TemplateSection updateManyAndReturn
   */
  export type TemplateSectionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateSection
     */
    select?: TemplateSectionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateSection
     */
    omit?: TemplateSectionOmit<ExtArgs> | null
    /**
     * The data used to update TemplateSections.
     */
    data: XOR<TemplateSectionUpdateManyMutationInput, TemplateSectionUncheckedUpdateManyInput>
    /**
     * Filter which TemplateSections to update
     */
    where?: TemplateSectionWhereInput
    /**
     * Limit how many TemplateSections to update.
     */
    limit?: number
  }

  /**
   * TemplateSection upsert
   */
  export type TemplateSectionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateSection
     */
    select?: TemplateSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateSection
     */
    omit?: TemplateSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateSectionInclude<ExtArgs> | null
    /**
     * The filter to search for the TemplateSection to update in case it exists.
     */
    where: TemplateSectionWhereUniqueInput
    /**
     * In case the TemplateSection found by the `where` argument doesn't exist, create a new TemplateSection with this data.
     */
    create: XOR<TemplateSectionCreateInput, TemplateSectionUncheckedCreateInput>
    /**
     * In case the TemplateSection was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TemplateSectionUpdateInput, TemplateSectionUncheckedUpdateInput>
  }

  /**
   * TemplateSection delete
   */
  export type TemplateSectionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateSection
     */
    select?: TemplateSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateSection
     */
    omit?: TemplateSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateSectionInclude<ExtArgs> | null
    /**
     * Filter which TemplateSection to delete.
     */
    where: TemplateSectionWhereUniqueInput
  }

  /**
   * TemplateSection deleteMany
   */
  export type TemplateSectionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TemplateSections to delete
     */
    where?: TemplateSectionWhereInput
    /**
     * Limit how many TemplateSections to delete.
     */
    limit?: number
  }

  /**
   * TemplateSection.items
   */
  export type TemplateSection$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateSectionItem
     */
    select?: TemplateSectionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateSectionItem
     */
    omit?: TemplateSectionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateSectionItemInclude<ExtArgs> | null
    where?: TemplateSectionItemWhereInput
    orderBy?: TemplateSectionItemOrderByWithRelationInput | TemplateSectionItemOrderByWithRelationInput[]
    cursor?: TemplateSectionItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TemplateSectionItemScalarFieldEnum | TemplateSectionItemScalarFieldEnum[]
  }

  /**
   * TemplateSection without action
   */
  export type TemplateSectionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateSection
     */
    select?: TemplateSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateSection
     */
    omit?: TemplateSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateSectionInclude<ExtArgs> | null
  }


  /**
   * Model TemplateSectionItem
   */

  export type AggregateTemplateSectionItem = {
    _count: TemplateSectionItemCountAggregateOutputType | null
    _avg: TemplateSectionItemAvgAggregateOutputType | null
    _sum: TemplateSectionItemSumAggregateOutputType | null
    _min: TemplateSectionItemMinAggregateOutputType | null
    _max: TemplateSectionItemMaxAggregateOutputType | null
  }

  export type TemplateSectionItemAvgAggregateOutputType = {
    sortOrder: number | null
    qty: Decimal | null
    unitPricePence: number | null
    hours: Decimal | null
    hourlyRatePence: number | null
    sellPricePence: number | null
  }

  export type TemplateSectionItemSumAggregateOutputType = {
    sortOrder: number | null
    qty: Decimal | null
    unitPricePence: number | null
    hours: Decimal | null
    hourlyRatePence: number | null
    sellPricePence: number | null
  }

  export type TemplateSectionItemMinAggregateOutputType = {
    id: string | null
    orgId: string | null
    templateSectionId: string | null
    title: string | null
    description: string | null
    sortOrder: number | null
    calcType: $Enums.CalcType | null
    qty: Decimal | null
    unit: string | null
    unitPricePence: number | null
    hours: Decimal | null
    hourlyRatePence: number | null
    sellPricePence: number | null
    isAllowance: boolean | null
    roomTag: string | null
    tradeTag: string | null
    phaseTag: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TemplateSectionItemMaxAggregateOutputType = {
    id: string | null
    orgId: string | null
    templateSectionId: string | null
    title: string | null
    description: string | null
    sortOrder: number | null
    calcType: $Enums.CalcType | null
    qty: Decimal | null
    unit: string | null
    unitPricePence: number | null
    hours: Decimal | null
    hourlyRatePence: number | null
    sellPricePence: number | null
    isAllowance: boolean | null
    roomTag: string | null
    tradeTag: string | null
    phaseTag: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TemplateSectionItemCountAggregateOutputType = {
    id: number
    orgId: number
    templateSectionId: number
    title: number
    description: number
    sortOrder: number
    calcType: number
    qty: number
    unit: number
    unitPricePence: number
    hours: number
    hourlyRatePence: number
    sellPricePence: number
    isAllowance: number
    roomTag: number
    tradeTag: number
    phaseTag: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TemplateSectionItemAvgAggregateInputType = {
    sortOrder?: true
    qty?: true
    unitPricePence?: true
    hours?: true
    hourlyRatePence?: true
    sellPricePence?: true
  }

  export type TemplateSectionItemSumAggregateInputType = {
    sortOrder?: true
    qty?: true
    unitPricePence?: true
    hours?: true
    hourlyRatePence?: true
    sellPricePence?: true
  }

  export type TemplateSectionItemMinAggregateInputType = {
    id?: true
    orgId?: true
    templateSectionId?: true
    title?: true
    description?: true
    sortOrder?: true
    calcType?: true
    qty?: true
    unit?: true
    unitPricePence?: true
    hours?: true
    hourlyRatePence?: true
    sellPricePence?: true
    isAllowance?: true
    roomTag?: true
    tradeTag?: true
    phaseTag?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TemplateSectionItemMaxAggregateInputType = {
    id?: true
    orgId?: true
    templateSectionId?: true
    title?: true
    description?: true
    sortOrder?: true
    calcType?: true
    qty?: true
    unit?: true
    unitPricePence?: true
    hours?: true
    hourlyRatePence?: true
    sellPricePence?: true
    isAllowance?: true
    roomTag?: true
    tradeTag?: true
    phaseTag?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TemplateSectionItemCountAggregateInputType = {
    id?: true
    orgId?: true
    templateSectionId?: true
    title?: true
    description?: true
    sortOrder?: true
    calcType?: true
    qty?: true
    unit?: true
    unitPricePence?: true
    hours?: true
    hourlyRatePence?: true
    sellPricePence?: true
    isAllowance?: true
    roomTag?: true
    tradeTag?: true
    phaseTag?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TemplateSectionItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TemplateSectionItem to aggregate.
     */
    where?: TemplateSectionItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TemplateSectionItems to fetch.
     */
    orderBy?: TemplateSectionItemOrderByWithRelationInput | TemplateSectionItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TemplateSectionItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TemplateSectionItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TemplateSectionItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TemplateSectionItems
    **/
    _count?: true | TemplateSectionItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TemplateSectionItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TemplateSectionItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TemplateSectionItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TemplateSectionItemMaxAggregateInputType
  }

  export type GetTemplateSectionItemAggregateType<T extends TemplateSectionItemAggregateArgs> = {
        [P in keyof T & keyof AggregateTemplateSectionItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTemplateSectionItem[P]>
      : GetScalarType<T[P], AggregateTemplateSectionItem[P]>
  }




  export type TemplateSectionItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TemplateSectionItemWhereInput
    orderBy?: TemplateSectionItemOrderByWithAggregationInput | TemplateSectionItemOrderByWithAggregationInput[]
    by: TemplateSectionItemScalarFieldEnum[] | TemplateSectionItemScalarFieldEnum
    having?: TemplateSectionItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TemplateSectionItemCountAggregateInputType | true
    _avg?: TemplateSectionItemAvgAggregateInputType
    _sum?: TemplateSectionItemSumAggregateInputType
    _min?: TemplateSectionItemMinAggregateInputType
    _max?: TemplateSectionItemMaxAggregateInputType
  }

  export type TemplateSectionItemGroupByOutputType = {
    id: string
    orgId: string
    templateSectionId: string
    title: string
    description: string | null
    sortOrder: number
    calcType: $Enums.CalcType
    qty: Decimal | null
    unit: string | null
    unitPricePence: number | null
    hours: Decimal | null
    hourlyRatePence: number | null
    sellPricePence: number | null
    isAllowance: boolean
    roomTag: string | null
    tradeTag: string | null
    phaseTag: string | null
    createdAt: Date
    updatedAt: Date
    _count: TemplateSectionItemCountAggregateOutputType | null
    _avg: TemplateSectionItemAvgAggregateOutputType | null
    _sum: TemplateSectionItemSumAggregateOutputType | null
    _min: TemplateSectionItemMinAggregateOutputType | null
    _max: TemplateSectionItemMaxAggregateOutputType | null
  }

  type GetTemplateSectionItemGroupByPayload<T extends TemplateSectionItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TemplateSectionItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TemplateSectionItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TemplateSectionItemGroupByOutputType[P]>
            : GetScalarType<T[P], TemplateSectionItemGroupByOutputType[P]>
        }
      >
    >


  export type TemplateSectionItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    templateSectionId?: boolean
    title?: boolean
    description?: boolean
    sortOrder?: boolean
    calcType?: boolean
    qty?: boolean
    unit?: boolean
    unitPricePence?: boolean
    hours?: boolean
    hourlyRatePence?: boolean
    sellPricePence?: boolean
    isAllowance?: boolean
    roomTag?: boolean
    tradeTag?: boolean
    phaseTag?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    templateSection?: boolean | TemplateSectionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["templateSectionItem"]>

  export type TemplateSectionItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    templateSectionId?: boolean
    title?: boolean
    description?: boolean
    sortOrder?: boolean
    calcType?: boolean
    qty?: boolean
    unit?: boolean
    unitPricePence?: boolean
    hours?: boolean
    hourlyRatePence?: boolean
    sellPricePence?: boolean
    isAllowance?: boolean
    roomTag?: boolean
    tradeTag?: boolean
    phaseTag?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    templateSection?: boolean | TemplateSectionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["templateSectionItem"]>

  export type TemplateSectionItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    templateSectionId?: boolean
    title?: boolean
    description?: boolean
    sortOrder?: boolean
    calcType?: boolean
    qty?: boolean
    unit?: boolean
    unitPricePence?: boolean
    hours?: boolean
    hourlyRatePence?: boolean
    sellPricePence?: boolean
    isAllowance?: boolean
    roomTag?: boolean
    tradeTag?: boolean
    phaseTag?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    templateSection?: boolean | TemplateSectionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["templateSectionItem"]>

  export type TemplateSectionItemSelectScalar = {
    id?: boolean
    orgId?: boolean
    templateSectionId?: boolean
    title?: boolean
    description?: boolean
    sortOrder?: boolean
    calcType?: boolean
    qty?: boolean
    unit?: boolean
    unitPricePence?: boolean
    hours?: boolean
    hourlyRatePence?: boolean
    sellPricePence?: boolean
    isAllowance?: boolean
    roomTag?: boolean
    tradeTag?: boolean
    phaseTag?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TemplateSectionItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orgId" | "templateSectionId" | "title" | "description" | "sortOrder" | "calcType" | "qty" | "unit" | "unitPricePence" | "hours" | "hourlyRatePence" | "sellPricePence" | "isAllowance" | "roomTag" | "tradeTag" | "phaseTag" | "createdAt" | "updatedAt", ExtArgs["result"]["templateSectionItem"]>
  export type TemplateSectionItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    templateSection?: boolean | TemplateSectionDefaultArgs<ExtArgs>
  }
  export type TemplateSectionItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    templateSection?: boolean | TemplateSectionDefaultArgs<ExtArgs>
  }
  export type TemplateSectionItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    templateSection?: boolean | TemplateSectionDefaultArgs<ExtArgs>
  }

  export type $TemplateSectionItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TemplateSectionItem"
    objects: {
      templateSection: Prisma.$TemplateSectionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orgId: string
      templateSectionId: string
      title: string
      description: string | null
      sortOrder: number
      calcType: $Enums.CalcType
      qty: Prisma.Decimal | null
      unit: string | null
      unitPricePence: number | null
      hours: Prisma.Decimal | null
      hourlyRatePence: number | null
      sellPricePence: number | null
      isAllowance: boolean
      roomTag: string | null
      tradeTag: string | null
      phaseTag: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["templateSectionItem"]>
    composites: {}
  }

  type TemplateSectionItemGetPayload<S extends boolean | null | undefined | TemplateSectionItemDefaultArgs> = $Result.GetResult<Prisma.$TemplateSectionItemPayload, S>

  type TemplateSectionItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TemplateSectionItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TemplateSectionItemCountAggregateInputType | true
    }

  export interface TemplateSectionItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TemplateSectionItem'], meta: { name: 'TemplateSectionItem' } }
    /**
     * Find zero or one TemplateSectionItem that matches the filter.
     * @param {TemplateSectionItemFindUniqueArgs} args - Arguments to find a TemplateSectionItem
     * @example
     * // Get one TemplateSectionItem
     * const templateSectionItem = await prisma.templateSectionItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TemplateSectionItemFindUniqueArgs>(args: SelectSubset<T, TemplateSectionItemFindUniqueArgs<ExtArgs>>): Prisma__TemplateSectionItemClient<$Result.GetResult<Prisma.$TemplateSectionItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TemplateSectionItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TemplateSectionItemFindUniqueOrThrowArgs} args - Arguments to find a TemplateSectionItem
     * @example
     * // Get one TemplateSectionItem
     * const templateSectionItem = await prisma.templateSectionItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TemplateSectionItemFindUniqueOrThrowArgs>(args: SelectSubset<T, TemplateSectionItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TemplateSectionItemClient<$Result.GetResult<Prisma.$TemplateSectionItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TemplateSectionItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateSectionItemFindFirstArgs} args - Arguments to find a TemplateSectionItem
     * @example
     * // Get one TemplateSectionItem
     * const templateSectionItem = await prisma.templateSectionItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TemplateSectionItemFindFirstArgs>(args?: SelectSubset<T, TemplateSectionItemFindFirstArgs<ExtArgs>>): Prisma__TemplateSectionItemClient<$Result.GetResult<Prisma.$TemplateSectionItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TemplateSectionItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateSectionItemFindFirstOrThrowArgs} args - Arguments to find a TemplateSectionItem
     * @example
     * // Get one TemplateSectionItem
     * const templateSectionItem = await prisma.templateSectionItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TemplateSectionItemFindFirstOrThrowArgs>(args?: SelectSubset<T, TemplateSectionItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__TemplateSectionItemClient<$Result.GetResult<Prisma.$TemplateSectionItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TemplateSectionItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateSectionItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TemplateSectionItems
     * const templateSectionItems = await prisma.templateSectionItem.findMany()
     * 
     * // Get first 10 TemplateSectionItems
     * const templateSectionItems = await prisma.templateSectionItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const templateSectionItemWithIdOnly = await prisma.templateSectionItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TemplateSectionItemFindManyArgs>(args?: SelectSubset<T, TemplateSectionItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TemplateSectionItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TemplateSectionItem.
     * @param {TemplateSectionItemCreateArgs} args - Arguments to create a TemplateSectionItem.
     * @example
     * // Create one TemplateSectionItem
     * const TemplateSectionItem = await prisma.templateSectionItem.create({
     *   data: {
     *     // ... data to create a TemplateSectionItem
     *   }
     * })
     * 
     */
    create<T extends TemplateSectionItemCreateArgs>(args: SelectSubset<T, TemplateSectionItemCreateArgs<ExtArgs>>): Prisma__TemplateSectionItemClient<$Result.GetResult<Prisma.$TemplateSectionItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TemplateSectionItems.
     * @param {TemplateSectionItemCreateManyArgs} args - Arguments to create many TemplateSectionItems.
     * @example
     * // Create many TemplateSectionItems
     * const templateSectionItem = await prisma.templateSectionItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TemplateSectionItemCreateManyArgs>(args?: SelectSubset<T, TemplateSectionItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TemplateSectionItems and returns the data saved in the database.
     * @param {TemplateSectionItemCreateManyAndReturnArgs} args - Arguments to create many TemplateSectionItems.
     * @example
     * // Create many TemplateSectionItems
     * const templateSectionItem = await prisma.templateSectionItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TemplateSectionItems and only return the `id`
     * const templateSectionItemWithIdOnly = await prisma.templateSectionItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TemplateSectionItemCreateManyAndReturnArgs>(args?: SelectSubset<T, TemplateSectionItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TemplateSectionItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TemplateSectionItem.
     * @param {TemplateSectionItemDeleteArgs} args - Arguments to delete one TemplateSectionItem.
     * @example
     * // Delete one TemplateSectionItem
     * const TemplateSectionItem = await prisma.templateSectionItem.delete({
     *   where: {
     *     // ... filter to delete one TemplateSectionItem
     *   }
     * })
     * 
     */
    delete<T extends TemplateSectionItemDeleteArgs>(args: SelectSubset<T, TemplateSectionItemDeleteArgs<ExtArgs>>): Prisma__TemplateSectionItemClient<$Result.GetResult<Prisma.$TemplateSectionItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TemplateSectionItem.
     * @param {TemplateSectionItemUpdateArgs} args - Arguments to update one TemplateSectionItem.
     * @example
     * // Update one TemplateSectionItem
     * const templateSectionItem = await prisma.templateSectionItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TemplateSectionItemUpdateArgs>(args: SelectSubset<T, TemplateSectionItemUpdateArgs<ExtArgs>>): Prisma__TemplateSectionItemClient<$Result.GetResult<Prisma.$TemplateSectionItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TemplateSectionItems.
     * @param {TemplateSectionItemDeleteManyArgs} args - Arguments to filter TemplateSectionItems to delete.
     * @example
     * // Delete a few TemplateSectionItems
     * const { count } = await prisma.templateSectionItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TemplateSectionItemDeleteManyArgs>(args?: SelectSubset<T, TemplateSectionItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TemplateSectionItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateSectionItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TemplateSectionItems
     * const templateSectionItem = await prisma.templateSectionItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TemplateSectionItemUpdateManyArgs>(args: SelectSubset<T, TemplateSectionItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TemplateSectionItems and returns the data updated in the database.
     * @param {TemplateSectionItemUpdateManyAndReturnArgs} args - Arguments to update many TemplateSectionItems.
     * @example
     * // Update many TemplateSectionItems
     * const templateSectionItem = await prisma.templateSectionItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TemplateSectionItems and only return the `id`
     * const templateSectionItemWithIdOnly = await prisma.templateSectionItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TemplateSectionItemUpdateManyAndReturnArgs>(args: SelectSubset<T, TemplateSectionItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TemplateSectionItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TemplateSectionItem.
     * @param {TemplateSectionItemUpsertArgs} args - Arguments to update or create a TemplateSectionItem.
     * @example
     * // Update or create a TemplateSectionItem
     * const templateSectionItem = await prisma.templateSectionItem.upsert({
     *   create: {
     *     // ... data to create a TemplateSectionItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TemplateSectionItem we want to update
     *   }
     * })
     */
    upsert<T extends TemplateSectionItemUpsertArgs>(args: SelectSubset<T, TemplateSectionItemUpsertArgs<ExtArgs>>): Prisma__TemplateSectionItemClient<$Result.GetResult<Prisma.$TemplateSectionItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TemplateSectionItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateSectionItemCountArgs} args - Arguments to filter TemplateSectionItems to count.
     * @example
     * // Count the number of TemplateSectionItems
     * const count = await prisma.templateSectionItem.count({
     *   where: {
     *     // ... the filter for the TemplateSectionItems we want to count
     *   }
     * })
    **/
    count<T extends TemplateSectionItemCountArgs>(
      args?: Subset<T, TemplateSectionItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TemplateSectionItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TemplateSectionItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateSectionItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TemplateSectionItemAggregateArgs>(args: Subset<T, TemplateSectionItemAggregateArgs>): Prisma.PrismaPromise<GetTemplateSectionItemAggregateType<T>>

    /**
     * Group by TemplateSectionItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateSectionItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TemplateSectionItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TemplateSectionItemGroupByArgs['orderBy'] }
        : { orderBy?: TemplateSectionItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TemplateSectionItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTemplateSectionItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TemplateSectionItem model
   */
  readonly fields: TemplateSectionItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TemplateSectionItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TemplateSectionItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    templateSection<T extends TemplateSectionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TemplateSectionDefaultArgs<ExtArgs>>): Prisma__TemplateSectionClient<$Result.GetResult<Prisma.$TemplateSectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TemplateSectionItem model
   */
  interface TemplateSectionItemFieldRefs {
    readonly id: FieldRef<"TemplateSectionItem", 'String'>
    readonly orgId: FieldRef<"TemplateSectionItem", 'String'>
    readonly templateSectionId: FieldRef<"TemplateSectionItem", 'String'>
    readonly title: FieldRef<"TemplateSectionItem", 'String'>
    readonly description: FieldRef<"TemplateSectionItem", 'String'>
    readonly sortOrder: FieldRef<"TemplateSectionItem", 'Int'>
    readonly calcType: FieldRef<"TemplateSectionItem", 'CalcType'>
    readonly qty: FieldRef<"TemplateSectionItem", 'Decimal'>
    readonly unit: FieldRef<"TemplateSectionItem", 'String'>
    readonly unitPricePence: FieldRef<"TemplateSectionItem", 'Int'>
    readonly hours: FieldRef<"TemplateSectionItem", 'Decimal'>
    readonly hourlyRatePence: FieldRef<"TemplateSectionItem", 'Int'>
    readonly sellPricePence: FieldRef<"TemplateSectionItem", 'Int'>
    readonly isAllowance: FieldRef<"TemplateSectionItem", 'Boolean'>
    readonly roomTag: FieldRef<"TemplateSectionItem", 'String'>
    readonly tradeTag: FieldRef<"TemplateSectionItem", 'String'>
    readonly phaseTag: FieldRef<"TemplateSectionItem", 'String'>
    readonly createdAt: FieldRef<"TemplateSectionItem", 'DateTime'>
    readonly updatedAt: FieldRef<"TemplateSectionItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TemplateSectionItem findUnique
   */
  export type TemplateSectionItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateSectionItem
     */
    select?: TemplateSectionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateSectionItem
     */
    omit?: TemplateSectionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateSectionItemInclude<ExtArgs> | null
    /**
     * Filter, which TemplateSectionItem to fetch.
     */
    where: TemplateSectionItemWhereUniqueInput
  }

  /**
   * TemplateSectionItem findUniqueOrThrow
   */
  export type TemplateSectionItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateSectionItem
     */
    select?: TemplateSectionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateSectionItem
     */
    omit?: TemplateSectionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateSectionItemInclude<ExtArgs> | null
    /**
     * Filter, which TemplateSectionItem to fetch.
     */
    where: TemplateSectionItemWhereUniqueInput
  }

  /**
   * TemplateSectionItem findFirst
   */
  export type TemplateSectionItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateSectionItem
     */
    select?: TemplateSectionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateSectionItem
     */
    omit?: TemplateSectionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateSectionItemInclude<ExtArgs> | null
    /**
     * Filter, which TemplateSectionItem to fetch.
     */
    where?: TemplateSectionItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TemplateSectionItems to fetch.
     */
    orderBy?: TemplateSectionItemOrderByWithRelationInput | TemplateSectionItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TemplateSectionItems.
     */
    cursor?: TemplateSectionItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TemplateSectionItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TemplateSectionItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TemplateSectionItems.
     */
    distinct?: TemplateSectionItemScalarFieldEnum | TemplateSectionItemScalarFieldEnum[]
  }

  /**
   * TemplateSectionItem findFirstOrThrow
   */
  export type TemplateSectionItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateSectionItem
     */
    select?: TemplateSectionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateSectionItem
     */
    omit?: TemplateSectionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateSectionItemInclude<ExtArgs> | null
    /**
     * Filter, which TemplateSectionItem to fetch.
     */
    where?: TemplateSectionItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TemplateSectionItems to fetch.
     */
    orderBy?: TemplateSectionItemOrderByWithRelationInput | TemplateSectionItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TemplateSectionItems.
     */
    cursor?: TemplateSectionItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TemplateSectionItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TemplateSectionItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TemplateSectionItems.
     */
    distinct?: TemplateSectionItemScalarFieldEnum | TemplateSectionItemScalarFieldEnum[]
  }

  /**
   * TemplateSectionItem findMany
   */
  export type TemplateSectionItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateSectionItem
     */
    select?: TemplateSectionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateSectionItem
     */
    omit?: TemplateSectionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateSectionItemInclude<ExtArgs> | null
    /**
     * Filter, which TemplateSectionItems to fetch.
     */
    where?: TemplateSectionItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TemplateSectionItems to fetch.
     */
    orderBy?: TemplateSectionItemOrderByWithRelationInput | TemplateSectionItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TemplateSectionItems.
     */
    cursor?: TemplateSectionItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TemplateSectionItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TemplateSectionItems.
     */
    skip?: number
    distinct?: TemplateSectionItemScalarFieldEnum | TemplateSectionItemScalarFieldEnum[]
  }

  /**
   * TemplateSectionItem create
   */
  export type TemplateSectionItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateSectionItem
     */
    select?: TemplateSectionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateSectionItem
     */
    omit?: TemplateSectionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateSectionItemInclude<ExtArgs> | null
    /**
     * The data needed to create a TemplateSectionItem.
     */
    data: XOR<TemplateSectionItemCreateInput, TemplateSectionItemUncheckedCreateInput>
  }

  /**
   * TemplateSectionItem createMany
   */
  export type TemplateSectionItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TemplateSectionItems.
     */
    data: TemplateSectionItemCreateManyInput | TemplateSectionItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TemplateSectionItem createManyAndReturn
   */
  export type TemplateSectionItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateSectionItem
     */
    select?: TemplateSectionItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateSectionItem
     */
    omit?: TemplateSectionItemOmit<ExtArgs> | null
    /**
     * The data used to create many TemplateSectionItems.
     */
    data: TemplateSectionItemCreateManyInput | TemplateSectionItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateSectionItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TemplateSectionItem update
   */
  export type TemplateSectionItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateSectionItem
     */
    select?: TemplateSectionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateSectionItem
     */
    omit?: TemplateSectionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateSectionItemInclude<ExtArgs> | null
    /**
     * The data needed to update a TemplateSectionItem.
     */
    data: XOR<TemplateSectionItemUpdateInput, TemplateSectionItemUncheckedUpdateInput>
    /**
     * Choose, which TemplateSectionItem to update.
     */
    where: TemplateSectionItemWhereUniqueInput
  }

  /**
   * TemplateSectionItem updateMany
   */
  export type TemplateSectionItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TemplateSectionItems.
     */
    data: XOR<TemplateSectionItemUpdateManyMutationInput, TemplateSectionItemUncheckedUpdateManyInput>
    /**
     * Filter which TemplateSectionItems to update
     */
    where?: TemplateSectionItemWhereInput
    /**
     * Limit how many TemplateSectionItems to update.
     */
    limit?: number
  }

  /**
   * TemplateSectionItem updateManyAndReturn
   */
  export type TemplateSectionItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateSectionItem
     */
    select?: TemplateSectionItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateSectionItem
     */
    omit?: TemplateSectionItemOmit<ExtArgs> | null
    /**
     * The data used to update TemplateSectionItems.
     */
    data: XOR<TemplateSectionItemUpdateManyMutationInput, TemplateSectionItemUncheckedUpdateManyInput>
    /**
     * Filter which TemplateSectionItems to update
     */
    where?: TemplateSectionItemWhereInput
    /**
     * Limit how many TemplateSectionItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateSectionItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TemplateSectionItem upsert
   */
  export type TemplateSectionItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateSectionItem
     */
    select?: TemplateSectionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateSectionItem
     */
    omit?: TemplateSectionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateSectionItemInclude<ExtArgs> | null
    /**
     * The filter to search for the TemplateSectionItem to update in case it exists.
     */
    where: TemplateSectionItemWhereUniqueInput
    /**
     * In case the TemplateSectionItem found by the `where` argument doesn't exist, create a new TemplateSectionItem with this data.
     */
    create: XOR<TemplateSectionItemCreateInput, TemplateSectionItemUncheckedCreateInput>
    /**
     * In case the TemplateSectionItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TemplateSectionItemUpdateInput, TemplateSectionItemUncheckedUpdateInput>
  }

  /**
   * TemplateSectionItem delete
   */
  export type TemplateSectionItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateSectionItem
     */
    select?: TemplateSectionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateSectionItem
     */
    omit?: TemplateSectionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateSectionItemInclude<ExtArgs> | null
    /**
     * Filter which TemplateSectionItem to delete.
     */
    where: TemplateSectionItemWhereUniqueInput
  }

  /**
   * TemplateSectionItem deleteMany
   */
  export type TemplateSectionItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TemplateSectionItems to delete
     */
    where?: TemplateSectionItemWhereInput
    /**
     * Limit how many TemplateSectionItems to delete.
     */
    limit?: number
  }

  /**
   * TemplateSectionItem without action
   */
  export type TemplateSectionItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateSectionItem
     */
    select?: TemplateSectionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TemplateSectionItem
     */
    omit?: TemplateSectionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateSectionItemInclude<ExtArgs> | null
  }


  /**
   * Model Variation
   */

  export type AggregateVariation = {
    _count: VariationCountAggregateOutputType | null
    _avg: VariationAvgAggregateOutputType | null
    _sum: VariationSumAggregateOutputType | null
    _min: VariationMinAggregateOutputType | null
    _max: VariationMaxAggregateOutputType | null
  }

  export type VariationAvgAggregateOutputType = {
    number: number | null
    vatRateBps: number | null
  }

  export type VariationSumAggregateOutputType = {
    number: number | null
    vatRateBps: number | null
  }

  export type VariationMinAggregateOutputType = {
    id: string | null
    orgId: string | null
    quoteId: string | null
    number: number | null
    title: string | null
    description: string | null
    status: $Enums.VariationStatus | null
    sentAt: Date | null
    approvedAt: Date | null
    vatMode: $Enums.VatMode | null
    vatRateBps: number | null
    createdByUserId: string | null
    updatedByUserId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VariationMaxAggregateOutputType = {
    id: string | null
    orgId: string | null
    quoteId: string | null
    number: number | null
    title: string | null
    description: string | null
    status: $Enums.VariationStatus | null
    sentAt: Date | null
    approvedAt: Date | null
    vatMode: $Enums.VatMode | null
    vatRateBps: number | null
    createdByUserId: string | null
    updatedByUserId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VariationCountAggregateOutputType = {
    id: number
    orgId: number
    quoteId: number
    number: number
    title: number
    description: number
    status: number
    sentAt: number
    approvedAt: number
    vatMode: number
    vatRateBps: number
    createdByUserId: number
    updatedByUserId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VariationAvgAggregateInputType = {
    number?: true
    vatRateBps?: true
  }

  export type VariationSumAggregateInputType = {
    number?: true
    vatRateBps?: true
  }

  export type VariationMinAggregateInputType = {
    id?: true
    orgId?: true
    quoteId?: true
    number?: true
    title?: true
    description?: true
    status?: true
    sentAt?: true
    approvedAt?: true
    vatMode?: true
    vatRateBps?: true
    createdByUserId?: true
    updatedByUserId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VariationMaxAggregateInputType = {
    id?: true
    orgId?: true
    quoteId?: true
    number?: true
    title?: true
    description?: true
    status?: true
    sentAt?: true
    approvedAt?: true
    vatMode?: true
    vatRateBps?: true
    createdByUserId?: true
    updatedByUserId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VariationCountAggregateInputType = {
    id?: true
    orgId?: true
    quoteId?: true
    number?: true
    title?: true
    description?: true
    status?: true
    sentAt?: true
    approvedAt?: true
    vatMode?: true
    vatRateBps?: true
    createdByUserId?: true
    updatedByUserId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VariationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Variation to aggregate.
     */
    where?: VariationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Variations to fetch.
     */
    orderBy?: VariationOrderByWithRelationInput | VariationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VariationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Variations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Variations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Variations
    **/
    _count?: true | VariationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VariationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VariationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VariationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VariationMaxAggregateInputType
  }

  export type GetVariationAggregateType<T extends VariationAggregateArgs> = {
        [P in keyof T & keyof AggregateVariation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVariation[P]>
      : GetScalarType<T[P], AggregateVariation[P]>
  }




  export type VariationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VariationWhereInput
    orderBy?: VariationOrderByWithAggregationInput | VariationOrderByWithAggregationInput[]
    by: VariationScalarFieldEnum[] | VariationScalarFieldEnum
    having?: VariationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VariationCountAggregateInputType | true
    _avg?: VariationAvgAggregateInputType
    _sum?: VariationSumAggregateInputType
    _min?: VariationMinAggregateInputType
    _max?: VariationMaxAggregateInputType
  }

  export type VariationGroupByOutputType = {
    id: string
    orgId: string
    quoteId: string
    number: number
    title: string
    description: string | null
    status: $Enums.VariationStatus
    sentAt: Date | null
    approvedAt: Date | null
    vatMode: $Enums.VatMode
    vatRateBps: number
    createdByUserId: string | null
    updatedByUserId: string | null
    createdAt: Date
    updatedAt: Date
    _count: VariationCountAggregateOutputType | null
    _avg: VariationAvgAggregateOutputType | null
    _sum: VariationSumAggregateOutputType | null
    _min: VariationMinAggregateOutputType | null
    _max: VariationMaxAggregateOutputType | null
  }

  type GetVariationGroupByPayload<T extends VariationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VariationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VariationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VariationGroupByOutputType[P]>
            : GetScalarType<T[P], VariationGroupByOutputType[P]>
        }
      >
    >


  export type VariationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    quoteId?: boolean
    number?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    sentAt?: boolean
    approvedAt?: boolean
    vatMode?: boolean
    vatRateBps?: boolean
    createdByUserId?: boolean
    updatedByUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    quote?: boolean | QuoteDefaultArgs<ExtArgs>
    publicLinks?: boolean | Variation$publicLinksArgs<ExtArgs>
    items?: boolean | Variation$itemsArgs<ExtArgs>
    approval?: boolean | Variation$approvalArgs<ExtArgs>
    pdfs?: boolean | Variation$pdfsArgs<ExtArgs>
    _count?: boolean | VariationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["variation"]>

  export type VariationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    quoteId?: boolean
    number?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    sentAt?: boolean
    approvedAt?: boolean
    vatMode?: boolean
    vatRateBps?: boolean
    createdByUserId?: boolean
    updatedByUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    quote?: boolean | QuoteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["variation"]>

  export type VariationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    quoteId?: boolean
    number?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    sentAt?: boolean
    approvedAt?: boolean
    vatMode?: boolean
    vatRateBps?: boolean
    createdByUserId?: boolean
    updatedByUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    quote?: boolean | QuoteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["variation"]>

  export type VariationSelectScalar = {
    id?: boolean
    orgId?: boolean
    quoteId?: boolean
    number?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    sentAt?: boolean
    approvedAt?: boolean
    vatMode?: boolean
    vatRateBps?: boolean
    createdByUserId?: boolean
    updatedByUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VariationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orgId" | "quoteId" | "number" | "title" | "description" | "status" | "sentAt" | "approvedAt" | "vatMode" | "vatRateBps" | "createdByUserId" | "updatedByUserId" | "createdAt" | "updatedAt", ExtArgs["result"]["variation"]>
  export type VariationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quote?: boolean | QuoteDefaultArgs<ExtArgs>
    publicLinks?: boolean | Variation$publicLinksArgs<ExtArgs>
    items?: boolean | Variation$itemsArgs<ExtArgs>
    approval?: boolean | Variation$approvalArgs<ExtArgs>
    pdfs?: boolean | Variation$pdfsArgs<ExtArgs>
    _count?: boolean | VariationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VariationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quote?: boolean | QuoteDefaultArgs<ExtArgs>
  }
  export type VariationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quote?: boolean | QuoteDefaultArgs<ExtArgs>
  }

  export type $VariationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Variation"
    objects: {
      quote: Prisma.$QuotePayload<ExtArgs>
      publicLinks: Prisma.$VariationPublicLinkPayload<ExtArgs>[]
      items: Prisma.$VariationItemPayload<ExtArgs>[]
      approval: Prisma.$VariationApprovalPayload<ExtArgs> | null
      pdfs: Prisma.$VariationPdfPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orgId: string
      quoteId: string
      number: number
      title: string
      description: string | null
      status: $Enums.VariationStatus
      sentAt: Date | null
      approvedAt: Date | null
      vatMode: $Enums.VatMode
      vatRateBps: number
      createdByUserId: string | null
      updatedByUserId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["variation"]>
    composites: {}
  }

  type VariationGetPayload<S extends boolean | null | undefined | VariationDefaultArgs> = $Result.GetResult<Prisma.$VariationPayload, S>

  type VariationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VariationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VariationCountAggregateInputType | true
    }

  export interface VariationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Variation'], meta: { name: 'Variation' } }
    /**
     * Find zero or one Variation that matches the filter.
     * @param {VariationFindUniqueArgs} args - Arguments to find a Variation
     * @example
     * // Get one Variation
     * const variation = await prisma.variation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VariationFindUniqueArgs>(args: SelectSubset<T, VariationFindUniqueArgs<ExtArgs>>): Prisma__VariationClient<$Result.GetResult<Prisma.$VariationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Variation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VariationFindUniqueOrThrowArgs} args - Arguments to find a Variation
     * @example
     * // Get one Variation
     * const variation = await prisma.variation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VariationFindUniqueOrThrowArgs>(args: SelectSubset<T, VariationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VariationClient<$Result.GetResult<Prisma.$VariationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Variation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VariationFindFirstArgs} args - Arguments to find a Variation
     * @example
     * // Get one Variation
     * const variation = await prisma.variation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VariationFindFirstArgs>(args?: SelectSubset<T, VariationFindFirstArgs<ExtArgs>>): Prisma__VariationClient<$Result.GetResult<Prisma.$VariationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Variation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VariationFindFirstOrThrowArgs} args - Arguments to find a Variation
     * @example
     * // Get one Variation
     * const variation = await prisma.variation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VariationFindFirstOrThrowArgs>(args?: SelectSubset<T, VariationFindFirstOrThrowArgs<ExtArgs>>): Prisma__VariationClient<$Result.GetResult<Prisma.$VariationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Variations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VariationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Variations
     * const variations = await prisma.variation.findMany()
     * 
     * // Get first 10 Variations
     * const variations = await prisma.variation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const variationWithIdOnly = await prisma.variation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VariationFindManyArgs>(args?: SelectSubset<T, VariationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VariationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Variation.
     * @param {VariationCreateArgs} args - Arguments to create a Variation.
     * @example
     * // Create one Variation
     * const Variation = await prisma.variation.create({
     *   data: {
     *     // ... data to create a Variation
     *   }
     * })
     * 
     */
    create<T extends VariationCreateArgs>(args: SelectSubset<T, VariationCreateArgs<ExtArgs>>): Prisma__VariationClient<$Result.GetResult<Prisma.$VariationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Variations.
     * @param {VariationCreateManyArgs} args - Arguments to create many Variations.
     * @example
     * // Create many Variations
     * const variation = await prisma.variation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VariationCreateManyArgs>(args?: SelectSubset<T, VariationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Variations and returns the data saved in the database.
     * @param {VariationCreateManyAndReturnArgs} args - Arguments to create many Variations.
     * @example
     * // Create many Variations
     * const variation = await prisma.variation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Variations and only return the `id`
     * const variationWithIdOnly = await prisma.variation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VariationCreateManyAndReturnArgs>(args?: SelectSubset<T, VariationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VariationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Variation.
     * @param {VariationDeleteArgs} args - Arguments to delete one Variation.
     * @example
     * // Delete one Variation
     * const Variation = await prisma.variation.delete({
     *   where: {
     *     // ... filter to delete one Variation
     *   }
     * })
     * 
     */
    delete<T extends VariationDeleteArgs>(args: SelectSubset<T, VariationDeleteArgs<ExtArgs>>): Prisma__VariationClient<$Result.GetResult<Prisma.$VariationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Variation.
     * @param {VariationUpdateArgs} args - Arguments to update one Variation.
     * @example
     * // Update one Variation
     * const variation = await prisma.variation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VariationUpdateArgs>(args: SelectSubset<T, VariationUpdateArgs<ExtArgs>>): Prisma__VariationClient<$Result.GetResult<Prisma.$VariationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Variations.
     * @param {VariationDeleteManyArgs} args - Arguments to filter Variations to delete.
     * @example
     * // Delete a few Variations
     * const { count } = await prisma.variation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VariationDeleteManyArgs>(args?: SelectSubset<T, VariationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Variations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VariationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Variations
     * const variation = await prisma.variation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VariationUpdateManyArgs>(args: SelectSubset<T, VariationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Variations and returns the data updated in the database.
     * @param {VariationUpdateManyAndReturnArgs} args - Arguments to update many Variations.
     * @example
     * // Update many Variations
     * const variation = await prisma.variation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Variations and only return the `id`
     * const variationWithIdOnly = await prisma.variation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VariationUpdateManyAndReturnArgs>(args: SelectSubset<T, VariationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VariationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Variation.
     * @param {VariationUpsertArgs} args - Arguments to update or create a Variation.
     * @example
     * // Update or create a Variation
     * const variation = await prisma.variation.upsert({
     *   create: {
     *     // ... data to create a Variation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Variation we want to update
     *   }
     * })
     */
    upsert<T extends VariationUpsertArgs>(args: SelectSubset<T, VariationUpsertArgs<ExtArgs>>): Prisma__VariationClient<$Result.GetResult<Prisma.$VariationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Variations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VariationCountArgs} args - Arguments to filter Variations to count.
     * @example
     * // Count the number of Variations
     * const count = await prisma.variation.count({
     *   where: {
     *     // ... the filter for the Variations we want to count
     *   }
     * })
    **/
    count<T extends VariationCountArgs>(
      args?: Subset<T, VariationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VariationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Variation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VariationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VariationAggregateArgs>(args: Subset<T, VariationAggregateArgs>): Prisma.PrismaPromise<GetVariationAggregateType<T>>

    /**
     * Group by Variation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VariationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VariationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VariationGroupByArgs['orderBy'] }
        : { orderBy?: VariationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VariationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVariationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Variation model
   */
  readonly fields: VariationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Variation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VariationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    quote<T extends QuoteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuoteDefaultArgs<ExtArgs>>): Prisma__QuoteClient<$Result.GetResult<Prisma.$QuotePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    publicLinks<T extends Variation$publicLinksArgs<ExtArgs> = {}>(args?: Subset<T, Variation$publicLinksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VariationPublicLinkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    items<T extends Variation$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Variation$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VariationItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    approval<T extends Variation$approvalArgs<ExtArgs> = {}>(args?: Subset<T, Variation$approvalArgs<ExtArgs>>): Prisma__VariationApprovalClient<$Result.GetResult<Prisma.$VariationApprovalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    pdfs<T extends Variation$pdfsArgs<ExtArgs> = {}>(args?: Subset<T, Variation$pdfsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VariationPdfPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Variation model
   */
  interface VariationFieldRefs {
    readonly id: FieldRef<"Variation", 'String'>
    readonly orgId: FieldRef<"Variation", 'String'>
    readonly quoteId: FieldRef<"Variation", 'String'>
    readonly number: FieldRef<"Variation", 'Int'>
    readonly title: FieldRef<"Variation", 'String'>
    readonly description: FieldRef<"Variation", 'String'>
    readonly status: FieldRef<"Variation", 'VariationStatus'>
    readonly sentAt: FieldRef<"Variation", 'DateTime'>
    readonly approvedAt: FieldRef<"Variation", 'DateTime'>
    readonly vatMode: FieldRef<"Variation", 'VatMode'>
    readonly vatRateBps: FieldRef<"Variation", 'Int'>
    readonly createdByUserId: FieldRef<"Variation", 'String'>
    readonly updatedByUserId: FieldRef<"Variation", 'String'>
    readonly createdAt: FieldRef<"Variation", 'DateTime'>
    readonly updatedAt: FieldRef<"Variation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Variation findUnique
   */
  export type VariationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Variation
     */
    select?: VariationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Variation
     */
    omit?: VariationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariationInclude<ExtArgs> | null
    /**
     * Filter, which Variation to fetch.
     */
    where: VariationWhereUniqueInput
  }

  /**
   * Variation findUniqueOrThrow
   */
  export type VariationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Variation
     */
    select?: VariationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Variation
     */
    omit?: VariationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariationInclude<ExtArgs> | null
    /**
     * Filter, which Variation to fetch.
     */
    where: VariationWhereUniqueInput
  }

  /**
   * Variation findFirst
   */
  export type VariationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Variation
     */
    select?: VariationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Variation
     */
    omit?: VariationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariationInclude<ExtArgs> | null
    /**
     * Filter, which Variation to fetch.
     */
    where?: VariationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Variations to fetch.
     */
    orderBy?: VariationOrderByWithRelationInput | VariationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Variations.
     */
    cursor?: VariationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Variations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Variations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Variations.
     */
    distinct?: VariationScalarFieldEnum | VariationScalarFieldEnum[]
  }

  /**
   * Variation findFirstOrThrow
   */
  export type VariationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Variation
     */
    select?: VariationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Variation
     */
    omit?: VariationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariationInclude<ExtArgs> | null
    /**
     * Filter, which Variation to fetch.
     */
    where?: VariationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Variations to fetch.
     */
    orderBy?: VariationOrderByWithRelationInput | VariationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Variations.
     */
    cursor?: VariationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Variations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Variations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Variations.
     */
    distinct?: VariationScalarFieldEnum | VariationScalarFieldEnum[]
  }

  /**
   * Variation findMany
   */
  export type VariationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Variation
     */
    select?: VariationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Variation
     */
    omit?: VariationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariationInclude<ExtArgs> | null
    /**
     * Filter, which Variations to fetch.
     */
    where?: VariationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Variations to fetch.
     */
    orderBy?: VariationOrderByWithRelationInput | VariationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Variations.
     */
    cursor?: VariationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Variations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Variations.
     */
    skip?: number
    distinct?: VariationScalarFieldEnum | VariationScalarFieldEnum[]
  }

  /**
   * Variation create
   */
  export type VariationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Variation
     */
    select?: VariationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Variation
     */
    omit?: VariationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariationInclude<ExtArgs> | null
    /**
     * The data needed to create a Variation.
     */
    data: XOR<VariationCreateInput, VariationUncheckedCreateInput>
  }

  /**
   * Variation createMany
   */
  export type VariationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Variations.
     */
    data: VariationCreateManyInput | VariationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Variation createManyAndReturn
   */
  export type VariationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Variation
     */
    select?: VariationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Variation
     */
    omit?: VariationOmit<ExtArgs> | null
    /**
     * The data used to create many Variations.
     */
    data: VariationCreateManyInput | VariationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Variation update
   */
  export type VariationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Variation
     */
    select?: VariationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Variation
     */
    omit?: VariationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariationInclude<ExtArgs> | null
    /**
     * The data needed to update a Variation.
     */
    data: XOR<VariationUpdateInput, VariationUncheckedUpdateInput>
    /**
     * Choose, which Variation to update.
     */
    where: VariationWhereUniqueInput
  }

  /**
   * Variation updateMany
   */
  export type VariationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Variations.
     */
    data: XOR<VariationUpdateManyMutationInput, VariationUncheckedUpdateManyInput>
    /**
     * Filter which Variations to update
     */
    where?: VariationWhereInput
    /**
     * Limit how many Variations to update.
     */
    limit?: number
  }

  /**
   * Variation updateManyAndReturn
   */
  export type VariationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Variation
     */
    select?: VariationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Variation
     */
    omit?: VariationOmit<ExtArgs> | null
    /**
     * The data used to update Variations.
     */
    data: XOR<VariationUpdateManyMutationInput, VariationUncheckedUpdateManyInput>
    /**
     * Filter which Variations to update
     */
    where?: VariationWhereInput
    /**
     * Limit how many Variations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Variation upsert
   */
  export type VariationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Variation
     */
    select?: VariationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Variation
     */
    omit?: VariationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariationInclude<ExtArgs> | null
    /**
     * The filter to search for the Variation to update in case it exists.
     */
    where: VariationWhereUniqueInput
    /**
     * In case the Variation found by the `where` argument doesn't exist, create a new Variation with this data.
     */
    create: XOR<VariationCreateInput, VariationUncheckedCreateInput>
    /**
     * In case the Variation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VariationUpdateInput, VariationUncheckedUpdateInput>
  }

  /**
   * Variation delete
   */
  export type VariationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Variation
     */
    select?: VariationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Variation
     */
    omit?: VariationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariationInclude<ExtArgs> | null
    /**
     * Filter which Variation to delete.
     */
    where: VariationWhereUniqueInput
  }

  /**
   * Variation deleteMany
   */
  export type VariationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Variations to delete
     */
    where?: VariationWhereInput
    /**
     * Limit how many Variations to delete.
     */
    limit?: number
  }

  /**
   * Variation.publicLinks
   */
  export type Variation$publicLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariationPublicLink
     */
    select?: VariationPublicLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VariationPublicLink
     */
    omit?: VariationPublicLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariationPublicLinkInclude<ExtArgs> | null
    where?: VariationPublicLinkWhereInput
    orderBy?: VariationPublicLinkOrderByWithRelationInput | VariationPublicLinkOrderByWithRelationInput[]
    cursor?: VariationPublicLinkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VariationPublicLinkScalarFieldEnum | VariationPublicLinkScalarFieldEnum[]
  }

  /**
   * Variation.items
   */
  export type Variation$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariationItem
     */
    select?: VariationItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VariationItem
     */
    omit?: VariationItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariationItemInclude<ExtArgs> | null
    where?: VariationItemWhereInput
    orderBy?: VariationItemOrderByWithRelationInput | VariationItemOrderByWithRelationInput[]
    cursor?: VariationItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VariationItemScalarFieldEnum | VariationItemScalarFieldEnum[]
  }

  /**
   * Variation.approval
   */
  export type Variation$approvalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariationApproval
     */
    select?: VariationApprovalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VariationApproval
     */
    omit?: VariationApprovalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariationApprovalInclude<ExtArgs> | null
    where?: VariationApprovalWhereInput
  }

  /**
   * Variation.pdfs
   */
  export type Variation$pdfsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariationPdf
     */
    select?: VariationPdfSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VariationPdf
     */
    omit?: VariationPdfOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariationPdfInclude<ExtArgs> | null
    where?: VariationPdfWhereInput
    orderBy?: VariationPdfOrderByWithRelationInput | VariationPdfOrderByWithRelationInput[]
    cursor?: VariationPdfWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VariationPdfScalarFieldEnum | VariationPdfScalarFieldEnum[]
  }

  /**
   * Variation without action
   */
  export type VariationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Variation
     */
    select?: VariationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Variation
     */
    omit?: VariationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariationInclude<ExtArgs> | null
  }


  /**
   * Model VariationItem
   */

  export type AggregateVariationItem = {
    _count: VariationItemCountAggregateOutputType | null
    _avg: VariationItemAvgAggregateOutputType | null
    _sum: VariationItemSumAggregateOutputType | null
    _min: VariationItemMinAggregateOutputType | null
    _max: VariationItemMaxAggregateOutputType | null
  }

  export type VariationItemAvgAggregateOutputType = {
    sortOrder: number | null
    qty: Decimal | null
    unitPricePence: number | null
    hours: Decimal | null
    hourlyRatePence: number | null
    sellPricePence: number | null
    costPence: number | null
    markupPercentBps: number | null
  }

  export type VariationItemSumAggregateOutputType = {
    sortOrder: number | null
    qty: Decimal | null
    unitPricePence: number | null
    hours: Decimal | null
    hourlyRatePence: number | null
    sellPricePence: number | null
    costPence: number | null
    markupPercentBps: number | null
  }

  export type VariationItemMinAggregateOutputType = {
    id: string | null
    orgId: string | null
    variationId: string | null
    parentId: string | null
    rowType: $Enums.ItemRowType | null
    title: string | null
    description: string | null
    sortOrder: number | null
    calcType: $Enums.CalcType | null
    qty: Decimal | null
    unit: string | null
    unitPricePence: number | null
    hours: Decimal | null
    hourlyRatePence: number | null
    sellPricePence: number | null
    isAllowance: boolean | null
    roomTag: string | null
    tradeTag: string | null
    phaseTag: string | null
    costPence: number | null
    markupPercentBps: number | null
    createdByUserId: string | null
    updatedByUserId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VariationItemMaxAggregateOutputType = {
    id: string | null
    orgId: string | null
    variationId: string | null
    parentId: string | null
    rowType: $Enums.ItemRowType | null
    title: string | null
    description: string | null
    sortOrder: number | null
    calcType: $Enums.CalcType | null
    qty: Decimal | null
    unit: string | null
    unitPricePence: number | null
    hours: Decimal | null
    hourlyRatePence: number | null
    sellPricePence: number | null
    isAllowance: boolean | null
    roomTag: string | null
    tradeTag: string | null
    phaseTag: string | null
    costPence: number | null
    markupPercentBps: number | null
    createdByUserId: string | null
    updatedByUserId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VariationItemCountAggregateOutputType = {
    id: number
    orgId: number
    variationId: number
    parentId: number
    rowType: number
    title: number
    description: number
    sortOrder: number
    calcType: number
    qty: number
    unit: number
    unitPricePence: number
    hours: number
    hourlyRatePence: number
    sellPricePence: number
    isAllowance: number
    roomTag: number
    tradeTag: number
    phaseTag: number
    costPence: number
    markupPercentBps: number
    createdByUserId: number
    updatedByUserId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VariationItemAvgAggregateInputType = {
    sortOrder?: true
    qty?: true
    unitPricePence?: true
    hours?: true
    hourlyRatePence?: true
    sellPricePence?: true
    costPence?: true
    markupPercentBps?: true
  }

  export type VariationItemSumAggregateInputType = {
    sortOrder?: true
    qty?: true
    unitPricePence?: true
    hours?: true
    hourlyRatePence?: true
    sellPricePence?: true
    costPence?: true
    markupPercentBps?: true
  }

  export type VariationItemMinAggregateInputType = {
    id?: true
    orgId?: true
    variationId?: true
    parentId?: true
    rowType?: true
    title?: true
    description?: true
    sortOrder?: true
    calcType?: true
    qty?: true
    unit?: true
    unitPricePence?: true
    hours?: true
    hourlyRatePence?: true
    sellPricePence?: true
    isAllowance?: true
    roomTag?: true
    tradeTag?: true
    phaseTag?: true
    costPence?: true
    markupPercentBps?: true
    createdByUserId?: true
    updatedByUserId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VariationItemMaxAggregateInputType = {
    id?: true
    orgId?: true
    variationId?: true
    parentId?: true
    rowType?: true
    title?: true
    description?: true
    sortOrder?: true
    calcType?: true
    qty?: true
    unit?: true
    unitPricePence?: true
    hours?: true
    hourlyRatePence?: true
    sellPricePence?: true
    isAllowance?: true
    roomTag?: true
    tradeTag?: true
    phaseTag?: true
    costPence?: true
    markupPercentBps?: true
    createdByUserId?: true
    updatedByUserId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VariationItemCountAggregateInputType = {
    id?: true
    orgId?: true
    variationId?: true
    parentId?: true
    rowType?: true
    title?: true
    description?: true
    sortOrder?: true
    calcType?: true
    qty?: true
    unit?: true
    unitPricePence?: true
    hours?: true
    hourlyRatePence?: true
    sellPricePence?: true
    isAllowance?: true
    roomTag?: true
    tradeTag?: true
    phaseTag?: true
    costPence?: true
    markupPercentBps?: true
    createdByUserId?: true
    updatedByUserId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VariationItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VariationItem to aggregate.
     */
    where?: VariationItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VariationItems to fetch.
     */
    orderBy?: VariationItemOrderByWithRelationInput | VariationItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VariationItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VariationItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VariationItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VariationItems
    **/
    _count?: true | VariationItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VariationItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VariationItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VariationItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VariationItemMaxAggregateInputType
  }

  export type GetVariationItemAggregateType<T extends VariationItemAggregateArgs> = {
        [P in keyof T & keyof AggregateVariationItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVariationItem[P]>
      : GetScalarType<T[P], AggregateVariationItem[P]>
  }




  export type VariationItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VariationItemWhereInput
    orderBy?: VariationItemOrderByWithAggregationInput | VariationItemOrderByWithAggregationInput[]
    by: VariationItemScalarFieldEnum[] | VariationItemScalarFieldEnum
    having?: VariationItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VariationItemCountAggregateInputType | true
    _avg?: VariationItemAvgAggregateInputType
    _sum?: VariationItemSumAggregateInputType
    _min?: VariationItemMinAggregateInputType
    _max?: VariationItemMaxAggregateInputType
  }

  export type VariationItemGroupByOutputType = {
    id: string
    orgId: string
    variationId: string
    parentId: string | null
    rowType: $Enums.ItemRowType
    title: string
    description: string | null
    sortOrder: number
    calcType: $Enums.CalcType
    qty: Decimal | null
    unit: string | null
    unitPricePence: number | null
    hours: Decimal | null
    hourlyRatePence: number | null
    sellPricePence: number | null
    isAllowance: boolean
    roomTag: string | null
    tradeTag: string | null
    phaseTag: string | null
    costPence: number | null
    markupPercentBps: number | null
    createdByUserId: string | null
    updatedByUserId: string | null
    createdAt: Date
    updatedAt: Date
    _count: VariationItemCountAggregateOutputType | null
    _avg: VariationItemAvgAggregateOutputType | null
    _sum: VariationItemSumAggregateOutputType | null
    _min: VariationItemMinAggregateOutputType | null
    _max: VariationItemMaxAggregateOutputType | null
  }

  type GetVariationItemGroupByPayload<T extends VariationItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VariationItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VariationItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VariationItemGroupByOutputType[P]>
            : GetScalarType<T[P], VariationItemGroupByOutputType[P]>
        }
      >
    >


  export type VariationItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    variationId?: boolean
    parentId?: boolean
    rowType?: boolean
    title?: boolean
    description?: boolean
    sortOrder?: boolean
    calcType?: boolean
    qty?: boolean
    unit?: boolean
    unitPricePence?: boolean
    hours?: boolean
    hourlyRatePence?: boolean
    sellPricePence?: boolean
    isAllowance?: boolean
    roomTag?: boolean
    tradeTag?: boolean
    phaseTag?: boolean
    costPence?: boolean
    markupPercentBps?: boolean
    createdByUserId?: boolean
    updatedByUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    variation?: boolean | VariationDefaultArgs<ExtArgs>
    parent?: boolean | VariationItem$parentArgs<ExtArgs>
    children?: boolean | VariationItem$childrenArgs<ExtArgs>
    _count?: boolean | VariationItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["variationItem"]>

  export type VariationItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    variationId?: boolean
    parentId?: boolean
    rowType?: boolean
    title?: boolean
    description?: boolean
    sortOrder?: boolean
    calcType?: boolean
    qty?: boolean
    unit?: boolean
    unitPricePence?: boolean
    hours?: boolean
    hourlyRatePence?: boolean
    sellPricePence?: boolean
    isAllowance?: boolean
    roomTag?: boolean
    tradeTag?: boolean
    phaseTag?: boolean
    costPence?: boolean
    markupPercentBps?: boolean
    createdByUserId?: boolean
    updatedByUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    variation?: boolean | VariationDefaultArgs<ExtArgs>
    parent?: boolean | VariationItem$parentArgs<ExtArgs>
  }, ExtArgs["result"]["variationItem"]>

  export type VariationItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    variationId?: boolean
    parentId?: boolean
    rowType?: boolean
    title?: boolean
    description?: boolean
    sortOrder?: boolean
    calcType?: boolean
    qty?: boolean
    unit?: boolean
    unitPricePence?: boolean
    hours?: boolean
    hourlyRatePence?: boolean
    sellPricePence?: boolean
    isAllowance?: boolean
    roomTag?: boolean
    tradeTag?: boolean
    phaseTag?: boolean
    costPence?: boolean
    markupPercentBps?: boolean
    createdByUserId?: boolean
    updatedByUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    variation?: boolean | VariationDefaultArgs<ExtArgs>
    parent?: boolean | VariationItem$parentArgs<ExtArgs>
  }, ExtArgs["result"]["variationItem"]>

  export type VariationItemSelectScalar = {
    id?: boolean
    orgId?: boolean
    variationId?: boolean
    parentId?: boolean
    rowType?: boolean
    title?: boolean
    description?: boolean
    sortOrder?: boolean
    calcType?: boolean
    qty?: boolean
    unit?: boolean
    unitPricePence?: boolean
    hours?: boolean
    hourlyRatePence?: boolean
    sellPricePence?: boolean
    isAllowance?: boolean
    roomTag?: boolean
    tradeTag?: boolean
    phaseTag?: boolean
    costPence?: boolean
    markupPercentBps?: boolean
    createdByUserId?: boolean
    updatedByUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VariationItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orgId" | "variationId" | "parentId" | "rowType" | "title" | "description" | "sortOrder" | "calcType" | "qty" | "unit" | "unitPricePence" | "hours" | "hourlyRatePence" | "sellPricePence" | "isAllowance" | "roomTag" | "tradeTag" | "phaseTag" | "costPence" | "markupPercentBps" | "createdByUserId" | "updatedByUserId" | "createdAt" | "updatedAt", ExtArgs["result"]["variationItem"]>
  export type VariationItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    variation?: boolean | VariationDefaultArgs<ExtArgs>
    parent?: boolean | VariationItem$parentArgs<ExtArgs>
    children?: boolean | VariationItem$childrenArgs<ExtArgs>
    _count?: boolean | VariationItemCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VariationItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    variation?: boolean | VariationDefaultArgs<ExtArgs>
    parent?: boolean | VariationItem$parentArgs<ExtArgs>
  }
  export type VariationItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    variation?: boolean | VariationDefaultArgs<ExtArgs>
    parent?: boolean | VariationItem$parentArgs<ExtArgs>
  }

  export type $VariationItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VariationItem"
    objects: {
      variation: Prisma.$VariationPayload<ExtArgs>
      parent: Prisma.$VariationItemPayload<ExtArgs> | null
      children: Prisma.$VariationItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orgId: string
      variationId: string
      parentId: string | null
      rowType: $Enums.ItemRowType
      title: string
      description: string | null
      sortOrder: number
      calcType: $Enums.CalcType
      qty: Prisma.Decimal | null
      unit: string | null
      unitPricePence: number | null
      hours: Prisma.Decimal | null
      hourlyRatePence: number | null
      sellPricePence: number | null
      isAllowance: boolean
      roomTag: string | null
      tradeTag: string | null
      phaseTag: string | null
      costPence: number | null
      markupPercentBps: number | null
      createdByUserId: string | null
      updatedByUserId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["variationItem"]>
    composites: {}
  }

  type VariationItemGetPayload<S extends boolean | null | undefined | VariationItemDefaultArgs> = $Result.GetResult<Prisma.$VariationItemPayload, S>

  type VariationItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VariationItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VariationItemCountAggregateInputType | true
    }

  export interface VariationItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VariationItem'], meta: { name: 'VariationItem' } }
    /**
     * Find zero or one VariationItem that matches the filter.
     * @param {VariationItemFindUniqueArgs} args - Arguments to find a VariationItem
     * @example
     * // Get one VariationItem
     * const variationItem = await prisma.variationItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VariationItemFindUniqueArgs>(args: SelectSubset<T, VariationItemFindUniqueArgs<ExtArgs>>): Prisma__VariationItemClient<$Result.GetResult<Prisma.$VariationItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VariationItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VariationItemFindUniqueOrThrowArgs} args - Arguments to find a VariationItem
     * @example
     * // Get one VariationItem
     * const variationItem = await prisma.variationItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VariationItemFindUniqueOrThrowArgs>(args: SelectSubset<T, VariationItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VariationItemClient<$Result.GetResult<Prisma.$VariationItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VariationItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VariationItemFindFirstArgs} args - Arguments to find a VariationItem
     * @example
     * // Get one VariationItem
     * const variationItem = await prisma.variationItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VariationItemFindFirstArgs>(args?: SelectSubset<T, VariationItemFindFirstArgs<ExtArgs>>): Prisma__VariationItemClient<$Result.GetResult<Prisma.$VariationItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VariationItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VariationItemFindFirstOrThrowArgs} args - Arguments to find a VariationItem
     * @example
     * // Get one VariationItem
     * const variationItem = await prisma.variationItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VariationItemFindFirstOrThrowArgs>(args?: SelectSubset<T, VariationItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__VariationItemClient<$Result.GetResult<Prisma.$VariationItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VariationItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VariationItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VariationItems
     * const variationItems = await prisma.variationItem.findMany()
     * 
     * // Get first 10 VariationItems
     * const variationItems = await prisma.variationItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const variationItemWithIdOnly = await prisma.variationItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VariationItemFindManyArgs>(args?: SelectSubset<T, VariationItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VariationItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VariationItem.
     * @param {VariationItemCreateArgs} args - Arguments to create a VariationItem.
     * @example
     * // Create one VariationItem
     * const VariationItem = await prisma.variationItem.create({
     *   data: {
     *     // ... data to create a VariationItem
     *   }
     * })
     * 
     */
    create<T extends VariationItemCreateArgs>(args: SelectSubset<T, VariationItemCreateArgs<ExtArgs>>): Prisma__VariationItemClient<$Result.GetResult<Prisma.$VariationItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VariationItems.
     * @param {VariationItemCreateManyArgs} args - Arguments to create many VariationItems.
     * @example
     * // Create many VariationItems
     * const variationItem = await prisma.variationItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VariationItemCreateManyArgs>(args?: SelectSubset<T, VariationItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VariationItems and returns the data saved in the database.
     * @param {VariationItemCreateManyAndReturnArgs} args - Arguments to create many VariationItems.
     * @example
     * // Create many VariationItems
     * const variationItem = await prisma.variationItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VariationItems and only return the `id`
     * const variationItemWithIdOnly = await prisma.variationItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VariationItemCreateManyAndReturnArgs>(args?: SelectSubset<T, VariationItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VariationItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VariationItem.
     * @param {VariationItemDeleteArgs} args - Arguments to delete one VariationItem.
     * @example
     * // Delete one VariationItem
     * const VariationItem = await prisma.variationItem.delete({
     *   where: {
     *     // ... filter to delete one VariationItem
     *   }
     * })
     * 
     */
    delete<T extends VariationItemDeleteArgs>(args: SelectSubset<T, VariationItemDeleteArgs<ExtArgs>>): Prisma__VariationItemClient<$Result.GetResult<Prisma.$VariationItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VariationItem.
     * @param {VariationItemUpdateArgs} args - Arguments to update one VariationItem.
     * @example
     * // Update one VariationItem
     * const variationItem = await prisma.variationItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VariationItemUpdateArgs>(args: SelectSubset<T, VariationItemUpdateArgs<ExtArgs>>): Prisma__VariationItemClient<$Result.GetResult<Prisma.$VariationItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VariationItems.
     * @param {VariationItemDeleteManyArgs} args - Arguments to filter VariationItems to delete.
     * @example
     * // Delete a few VariationItems
     * const { count } = await prisma.variationItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VariationItemDeleteManyArgs>(args?: SelectSubset<T, VariationItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VariationItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VariationItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VariationItems
     * const variationItem = await prisma.variationItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VariationItemUpdateManyArgs>(args: SelectSubset<T, VariationItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VariationItems and returns the data updated in the database.
     * @param {VariationItemUpdateManyAndReturnArgs} args - Arguments to update many VariationItems.
     * @example
     * // Update many VariationItems
     * const variationItem = await prisma.variationItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VariationItems and only return the `id`
     * const variationItemWithIdOnly = await prisma.variationItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VariationItemUpdateManyAndReturnArgs>(args: SelectSubset<T, VariationItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VariationItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VariationItem.
     * @param {VariationItemUpsertArgs} args - Arguments to update or create a VariationItem.
     * @example
     * // Update or create a VariationItem
     * const variationItem = await prisma.variationItem.upsert({
     *   create: {
     *     // ... data to create a VariationItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VariationItem we want to update
     *   }
     * })
     */
    upsert<T extends VariationItemUpsertArgs>(args: SelectSubset<T, VariationItemUpsertArgs<ExtArgs>>): Prisma__VariationItemClient<$Result.GetResult<Prisma.$VariationItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VariationItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VariationItemCountArgs} args - Arguments to filter VariationItems to count.
     * @example
     * // Count the number of VariationItems
     * const count = await prisma.variationItem.count({
     *   where: {
     *     // ... the filter for the VariationItems we want to count
     *   }
     * })
    **/
    count<T extends VariationItemCountArgs>(
      args?: Subset<T, VariationItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VariationItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VariationItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VariationItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VariationItemAggregateArgs>(args: Subset<T, VariationItemAggregateArgs>): Prisma.PrismaPromise<GetVariationItemAggregateType<T>>

    /**
     * Group by VariationItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VariationItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VariationItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VariationItemGroupByArgs['orderBy'] }
        : { orderBy?: VariationItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VariationItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVariationItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VariationItem model
   */
  readonly fields: VariationItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VariationItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VariationItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    variation<T extends VariationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VariationDefaultArgs<ExtArgs>>): Prisma__VariationClient<$Result.GetResult<Prisma.$VariationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    parent<T extends VariationItem$parentArgs<ExtArgs> = {}>(args?: Subset<T, VariationItem$parentArgs<ExtArgs>>): Prisma__VariationItemClient<$Result.GetResult<Prisma.$VariationItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    children<T extends VariationItem$childrenArgs<ExtArgs> = {}>(args?: Subset<T, VariationItem$childrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VariationItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VariationItem model
   */
  interface VariationItemFieldRefs {
    readonly id: FieldRef<"VariationItem", 'String'>
    readonly orgId: FieldRef<"VariationItem", 'String'>
    readonly variationId: FieldRef<"VariationItem", 'String'>
    readonly parentId: FieldRef<"VariationItem", 'String'>
    readonly rowType: FieldRef<"VariationItem", 'ItemRowType'>
    readonly title: FieldRef<"VariationItem", 'String'>
    readonly description: FieldRef<"VariationItem", 'String'>
    readonly sortOrder: FieldRef<"VariationItem", 'Int'>
    readonly calcType: FieldRef<"VariationItem", 'CalcType'>
    readonly qty: FieldRef<"VariationItem", 'Decimal'>
    readonly unit: FieldRef<"VariationItem", 'String'>
    readonly unitPricePence: FieldRef<"VariationItem", 'Int'>
    readonly hours: FieldRef<"VariationItem", 'Decimal'>
    readonly hourlyRatePence: FieldRef<"VariationItem", 'Int'>
    readonly sellPricePence: FieldRef<"VariationItem", 'Int'>
    readonly isAllowance: FieldRef<"VariationItem", 'Boolean'>
    readonly roomTag: FieldRef<"VariationItem", 'String'>
    readonly tradeTag: FieldRef<"VariationItem", 'String'>
    readonly phaseTag: FieldRef<"VariationItem", 'String'>
    readonly costPence: FieldRef<"VariationItem", 'Int'>
    readonly markupPercentBps: FieldRef<"VariationItem", 'Int'>
    readonly createdByUserId: FieldRef<"VariationItem", 'String'>
    readonly updatedByUserId: FieldRef<"VariationItem", 'String'>
    readonly createdAt: FieldRef<"VariationItem", 'DateTime'>
    readonly updatedAt: FieldRef<"VariationItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VariationItem findUnique
   */
  export type VariationItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariationItem
     */
    select?: VariationItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VariationItem
     */
    omit?: VariationItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariationItemInclude<ExtArgs> | null
    /**
     * Filter, which VariationItem to fetch.
     */
    where: VariationItemWhereUniqueInput
  }

  /**
   * VariationItem findUniqueOrThrow
   */
  export type VariationItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariationItem
     */
    select?: VariationItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VariationItem
     */
    omit?: VariationItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariationItemInclude<ExtArgs> | null
    /**
     * Filter, which VariationItem to fetch.
     */
    where: VariationItemWhereUniqueInput
  }

  /**
   * VariationItem findFirst
   */
  export type VariationItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariationItem
     */
    select?: VariationItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VariationItem
     */
    omit?: VariationItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariationItemInclude<ExtArgs> | null
    /**
     * Filter, which VariationItem to fetch.
     */
    where?: VariationItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VariationItems to fetch.
     */
    orderBy?: VariationItemOrderByWithRelationInput | VariationItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VariationItems.
     */
    cursor?: VariationItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VariationItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VariationItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VariationItems.
     */
    distinct?: VariationItemScalarFieldEnum | VariationItemScalarFieldEnum[]
  }

  /**
   * VariationItem findFirstOrThrow
   */
  export type VariationItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariationItem
     */
    select?: VariationItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VariationItem
     */
    omit?: VariationItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariationItemInclude<ExtArgs> | null
    /**
     * Filter, which VariationItem to fetch.
     */
    where?: VariationItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VariationItems to fetch.
     */
    orderBy?: VariationItemOrderByWithRelationInput | VariationItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VariationItems.
     */
    cursor?: VariationItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VariationItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VariationItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VariationItems.
     */
    distinct?: VariationItemScalarFieldEnum | VariationItemScalarFieldEnum[]
  }

  /**
   * VariationItem findMany
   */
  export type VariationItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariationItem
     */
    select?: VariationItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VariationItem
     */
    omit?: VariationItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariationItemInclude<ExtArgs> | null
    /**
     * Filter, which VariationItems to fetch.
     */
    where?: VariationItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VariationItems to fetch.
     */
    orderBy?: VariationItemOrderByWithRelationInput | VariationItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VariationItems.
     */
    cursor?: VariationItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VariationItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VariationItems.
     */
    skip?: number
    distinct?: VariationItemScalarFieldEnum | VariationItemScalarFieldEnum[]
  }

  /**
   * VariationItem create
   */
  export type VariationItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariationItem
     */
    select?: VariationItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VariationItem
     */
    omit?: VariationItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariationItemInclude<ExtArgs> | null
    /**
     * The data needed to create a VariationItem.
     */
    data: XOR<VariationItemCreateInput, VariationItemUncheckedCreateInput>
  }

  /**
   * VariationItem createMany
   */
  export type VariationItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VariationItems.
     */
    data: VariationItemCreateManyInput | VariationItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VariationItem createManyAndReturn
   */
  export type VariationItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariationItem
     */
    select?: VariationItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VariationItem
     */
    omit?: VariationItemOmit<ExtArgs> | null
    /**
     * The data used to create many VariationItems.
     */
    data: VariationItemCreateManyInput | VariationItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariationItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VariationItem update
   */
  export type VariationItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariationItem
     */
    select?: VariationItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VariationItem
     */
    omit?: VariationItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariationItemInclude<ExtArgs> | null
    /**
     * The data needed to update a VariationItem.
     */
    data: XOR<VariationItemUpdateInput, VariationItemUncheckedUpdateInput>
    /**
     * Choose, which VariationItem to update.
     */
    where: VariationItemWhereUniqueInput
  }

  /**
   * VariationItem updateMany
   */
  export type VariationItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VariationItems.
     */
    data: XOR<VariationItemUpdateManyMutationInput, VariationItemUncheckedUpdateManyInput>
    /**
     * Filter which VariationItems to update
     */
    where?: VariationItemWhereInput
    /**
     * Limit how many VariationItems to update.
     */
    limit?: number
  }

  /**
   * VariationItem updateManyAndReturn
   */
  export type VariationItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariationItem
     */
    select?: VariationItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VariationItem
     */
    omit?: VariationItemOmit<ExtArgs> | null
    /**
     * The data used to update VariationItems.
     */
    data: XOR<VariationItemUpdateManyMutationInput, VariationItemUncheckedUpdateManyInput>
    /**
     * Filter which VariationItems to update
     */
    where?: VariationItemWhereInput
    /**
     * Limit how many VariationItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariationItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * VariationItem upsert
   */
  export type VariationItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariationItem
     */
    select?: VariationItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VariationItem
     */
    omit?: VariationItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariationItemInclude<ExtArgs> | null
    /**
     * The filter to search for the VariationItem to update in case it exists.
     */
    where: VariationItemWhereUniqueInput
    /**
     * In case the VariationItem found by the `where` argument doesn't exist, create a new VariationItem with this data.
     */
    create: XOR<VariationItemCreateInput, VariationItemUncheckedCreateInput>
    /**
     * In case the VariationItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VariationItemUpdateInput, VariationItemUncheckedUpdateInput>
  }

  /**
   * VariationItem delete
   */
  export type VariationItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariationItem
     */
    select?: VariationItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VariationItem
     */
    omit?: VariationItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariationItemInclude<ExtArgs> | null
    /**
     * Filter which VariationItem to delete.
     */
    where: VariationItemWhereUniqueInput
  }

  /**
   * VariationItem deleteMany
   */
  export type VariationItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VariationItems to delete
     */
    where?: VariationItemWhereInput
    /**
     * Limit how many VariationItems to delete.
     */
    limit?: number
  }

  /**
   * VariationItem.parent
   */
  export type VariationItem$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariationItem
     */
    select?: VariationItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VariationItem
     */
    omit?: VariationItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariationItemInclude<ExtArgs> | null
    where?: VariationItemWhereInput
  }

  /**
   * VariationItem.children
   */
  export type VariationItem$childrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariationItem
     */
    select?: VariationItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VariationItem
     */
    omit?: VariationItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariationItemInclude<ExtArgs> | null
    where?: VariationItemWhereInput
    orderBy?: VariationItemOrderByWithRelationInput | VariationItemOrderByWithRelationInput[]
    cursor?: VariationItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VariationItemScalarFieldEnum | VariationItemScalarFieldEnum[]
  }

  /**
   * VariationItem without action
   */
  export type VariationItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariationItem
     */
    select?: VariationItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VariationItem
     */
    omit?: VariationItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariationItemInclude<ExtArgs> | null
  }


  /**
   * Model VariationApproval
   */

  export type AggregateVariationApproval = {
    _count: VariationApprovalCountAggregateOutputType | null
    _min: VariationApprovalMinAggregateOutputType | null
    _max: VariationApprovalMaxAggregateOutputType | null
  }

  export type VariationApprovalMinAggregateOutputType = {
    id: string | null
    orgId: string | null
    variationId: string | null
    approvedName: string | null
    approvedEmail: string | null
    approvedAt: Date | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type VariationApprovalMaxAggregateOutputType = {
    id: string | null
    orgId: string | null
    variationId: string | null
    approvedName: string | null
    approvedEmail: string | null
    approvedAt: Date | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type VariationApprovalCountAggregateOutputType = {
    id: number
    orgId: number
    variationId: number
    approvedName: number
    approvedEmail: number
    approvedAt: number
    ipAddress: number
    userAgent: number
    createdAt: number
    _all: number
  }


  export type VariationApprovalMinAggregateInputType = {
    id?: true
    orgId?: true
    variationId?: true
    approvedName?: true
    approvedEmail?: true
    approvedAt?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type VariationApprovalMaxAggregateInputType = {
    id?: true
    orgId?: true
    variationId?: true
    approvedName?: true
    approvedEmail?: true
    approvedAt?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type VariationApprovalCountAggregateInputType = {
    id?: true
    orgId?: true
    variationId?: true
    approvedName?: true
    approvedEmail?: true
    approvedAt?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    _all?: true
  }

  export type VariationApprovalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VariationApproval to aggregate.
     */
    where?: VariationApprovalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VariationApprovals to fetch.
     */
    orderBy?: VariationApprovalOrderByWithRelationInput | VariationApprovalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VariationApprovalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VariationApprovals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VariationApprovals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VariationApprovals
    **/
    _count?: true | VariationApprovalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VariationApprovalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VariationApprovalMaxAggregateInputType
  }

  export type GetVariationApprovalAggregateType<T extends VariationApprovalAggregateArgs> = {
        [P in keyof T & keyof AggregateVariationApproval]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVariationApproval[P]>
      : GetScalarType<T[P], AggregateVariationApproval[P]>
  }




  export type VariationApprovalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VariationApprovalWhereInput
    orderBy?: VariationApprovalOrderByWithAggregationInput | VariationApprovalOrderByWithAggregationInput[]
    by: VariationApprovalScalarFieldEnum[] | VariationApprovalScalarFieldEnum
    having?: VariationApprovalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VariationApprovalCountAggregateInputType | true
    _min?: VariationApprovalMinAggregateInputType
    _max?: VariationApprovalMaxAggregateInputType
  }

  export type VariationApprovalGroupByOutputType = {
    id: string
    orgId: string
    variationId: string
    approvedName: string
    approvedEmail: string | null
    approvedAt: Date
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date
    _count: VariationApprovalCountAggregateOutputType | null
    _min: VariationApprovalMinAggregateOutputType | null
    _max: VariationApprovalMaxAggregateOutputType | null
  }

  type GetVariationApprovalGroupByPayload<T extends VariationApprovalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VariationApprovalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VariationApprovalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VariationApprovalGroupByOutputType[P]>
            : GetScalarType<T[P], VariationApprovalGroupByOutputType[P]>
        }
      >
    >


  export type VariationApprovalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    variationId?: boolean
    approvedName?: boolean
    approvedEmail?: boolean
    approvedAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    variation?: boolean | VariationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["variationApproval"]>

  export type VariationApprovalSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    variationId?: boolean
    approvedName?: boolean
    approvedEmail?: boolean
    approvedAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    variation?: boolean | VariationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["variationApproval"]>

  export type VariationApprovalSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    variationId?: boolean
    approvedName?: boolean
    approvedEmail?: boolean
    approvedAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    variation?: boolean | VariationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["variationApproval"]>

  export type VariationApprovalSelectScalar = {
    id?: boolean
    orgId?: boolean
    variationId?: boolean
    approvedName?: boolean
    approvedEmail?: boolean
    approvedAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
  }

  export type VariationApprovalOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orgId" | "variationId" | "approvedName" | "approvedEmail" | "approvedAt" | "ipAddress" | "userAgent" | "createdAt", ExtArgs["result"]["variationApproval"]>
  export type VariationApprovalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    variation?: boolean | VariationDefaultArgs<ExtArgs>
  }
  export type VariationApprovalIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    variation?: boolean | VariationDefaultArgs<ExtArgs>
  }
  export type VariationApprovalIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    variation?: boolean | VariationDefaultArgs<ExtArgs>
  }

  export type $VariationApprovalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VariationApproval"
    objects: {
      variation: Prisma.$VariationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orgId: string
      variationId: string
      approvedName: string
      approvedEmail: string | null
      approvedAt: Date
      ipAddress: string | null
      userAgent: string | null
      createdAt: Date
    }, ExtArgs["result"]["variationApproval"]>
    composites: {}
  }

  type VariationApprovalGetPayload<S extends boolean | null | undefined | VariationApprovalDefaultArgs> = $Result.GetResult<Prisma.$VariationApprovalPayload, S>

  type VariationApprovalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VariationApprovalFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VariationApprovalCountAggregateInputType | true
    }

  export interface VariationApprovalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VariationApproval'], meta: { name: 'VariationApproval' } }
    /**
     * Find zero or one VariationApproval that matches the filter.
     * @param {VariationApprovalFindUniqueArgs} args - Arguments to find a VariationApproval
     * @example
     * // Get one VariationApproval
     * const variationApproval = await prisma.variationApproval.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VariationApprovalFindUniqueArgs>(args: SelectSubset<T, VariationApprovalFindUniqueArgs<ExtArgs>>): Prisma__VariationApprovalClient<$Result.GetResult<Prisma.$VariationApprovalPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VariationApproval that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VariationApprovalFindUniqueOrThrowArgs} args - Arguments to find a VariationApproval
     * @example
     * // Get one VariationApproval
     * const variationApproval = await prisma.variationApproval.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VariationApprovalFindUniqueOrThrowArgs>(args: SelectSubset<T, VariationApprovalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VariationApprovalClient<$Result.GetResult<Prisma.$VariationApprovalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VariationApproval that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VariationApprovalFindFirstArgs} args - Arguments to find a VariationApproval
     * @example
     * // Get one VariationApproval
     * const variationApproval = await prisma.variationApproval.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VariationApprovalFindFirstArgs>(args?: SelectSubset<T, VariationApprovalFindFirstArgs<ExtArgs>>): Prisma__VariationApprovalClient<$Result.GetResult<Prisma.$VariationApprovalPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VariationApproval that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VariationApprovalFindFirstOrThrowArgs} args - Arguments to find a VariationApproval
     * @example
     * // Get one VariationApproval
     * const variationApproval = await prisma.variationApproval.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VariationApprovalFindFirstOrThrowArgs>(args?: SelectSubset<T, VariationApprovalFindFirstOrThrowArgs<ExtArgs>>): Prisma__VariationApprovalClient<$Result.GetResult<Prisma.$VariationApprovalPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VariationApprovals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VariationApprovalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VariationApprovals
     * const variationApprovals = await prisma.variationApproval.findMany()
     * 
     * // Get first 10 VariationApprovals
     * const variationApprovals = await prisma.variationApproval.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const variationApprovalWithIdOnly = await prisma.variationApproval.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VariationApprovalFindManyArgs>(args?: SelectSubset<T, VariationApprovalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VariationApprovalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VariationApproval.
     * @param {VariationApprovalCreateArgs} args - Arguments to create a VariationApproval.
     * @example
     * // Create one VariationApproval
     * const VariationApproval = await prisma.variationApproval.create({
     *   data: {
     *     // ... data to create a VariationApproval
     *   }
     * })
     * 
     */
    create<T extends VariationApprovalCreateArgs>(args: SelectSubset<T, VariationApprovalCreateArgs<ExtArgs>>): Prisma__VariationApprovalClient<$Result.GetResult<Prisma.$VariationApprovalPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VariationApprovals.
     * @param {VariationApprovalCreateManyArgs} args - Arguments to create many VariationApprovals.
     * @example
     * // Create many VariationApprovals
     * const variationApproval = await prisma.variationApproval.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VariationApprovalCreateManyArgs>(args?: SelectSubset<T, VariationApprovalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VariationApprovals and returns the data saved in the database.
     * @param {VariationApprovalCreateManyAndReturnArgs} args - Arguments to create many VariationApprovals.
     * @example
     * // Create many VariationApprovals
     * const variationApproval = await prisma.variationApproval.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VariationApprovals and only return the `id`
     * const variationApprovalWithIdOnly = await prisma.variationApproval.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VariationApprovalCreateManyAndReturnArgs>(args?: SelectSubset<T, VariationApprovalCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VariationApprovalPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VariationApproval.
     * @param {VariationApprovalDeleteArgs} args - Arguments to delete one VariationApproval.
     * @example
     * // Delete one VariationApproval
     * const VariationApproval = await prisma.variationApproval.delete({
     *   where: {
     *     // ... filter to delete one VariationApproval
     *   }
     * })
     * 
     */
    delete<T extends VariationApprovalDeleteArgs>(args: SelectSubset<T, VariationApprovalDeleteArgs<ExtArgs>>): Prisma__VariationApprovalClient<$Result.GetResult<Prisma.$VariationApprovalPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VariationApproval.
     * @param {VariationApprovalUpdateArgs} args - Arguments to update one VariationApproval.
     * @example
     * // Update one VariationApproval
     * const variationApproval = await prisma.variationApproval.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VariationApprovalUpdateArgs>(args: SelectSubset<T, VariationApprovalUpdateArgs<ExtArgs>>): Prisma__VariationApprovalClient<$Result.GetResult<Prisma.$VariationApprovalPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VariationApprovals.
     * @param {VariationApprovalDeleteManyArgs} args - Arguments to filter VariationApprovals to delete.
     * @example
     * // Delete a few VariationApprovals
     * const { count } = await prisma.variationApproval.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VariationApprovalDeleteManyArgs>(args?: SelectSubset<T, VariationApprovalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VariationApprovals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VariationApprovalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VariationApprovals
     * const variationApproval = await prisma.variationApproval.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VariationApprovalUpdateManyArgs>(args: SelectSubset<T, VariationApprovalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VariationApprovals and returns the data updated in the database.
     * @param {VariationApprovalUpdateManyAndReturnArgs} args - Arguments to update many VariationApprovals.
     * @example
     * // Update many VariationApprovals
     * const variationApproval = await prisma.variationApproval.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VariationApprovals and only return the `id`
     * const variationApprovalWithIdOnly = await prisma.variationApproval.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VariationApprovalUpdateManyAndReturnArgs>(args: SelectSubset<T, VariationApprovalUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VariationApprovalPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VariationApproval.
     * @param {VariationApprovalUpsertArgs} args - Arguments to update or create a VariationApproval.
     * @example
     * // Update or create a VariationApproval
     * const variationApproval = await prisma.variationApproval.upsert({
     *   create: {
     *     // ... data to create a VariationApproval
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VariationApproval we want to update
     *   }
     * })
     */
    upsert<T extends VariationApprovalUpsertArgs>(args: SelectSubset<T, VariationApprovalUpsertArgs<ExtArgs>>): Prisma__VariationApprovalClient<$Result.GetResult<Prisma.$VariationApprovalPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VariationApprovals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VariationApprovalCountArgs} args - Arguments to filter VariationApprovals to count.
     * @example
     * // Count the number of VariationApprovals
     * const count = await prisma.variationApproval.count({
     *   where: {
     *     // ... the filter for the VariationApprovals we want to count
     *   }
     * })
    **/
    count<T extends VariationApprovalCountArgs>(
      args?: Subset<T, VariationApprovalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VariationApprovalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VariationApproval.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VariationApprovalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VariationApprovalAggregateArgs>(args: Subset<T, VariationApprovalAggregateArgs>): Prisma.PrismaPromise<GetVariationApprovalAggregateType<T>>

    /**
     * Group by VariationApproval.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VariationApprovalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VariationApprovalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VariationApprovalGroupByArgs['orderBy'] }
        : { orderBy?: VariationApprovalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VariationApprovalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVariationApprovalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VariationApproval model
   */
  readonly fields: VariationApprovalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VariationApproval.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VariationApprovalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    variation<T extends VariationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VariationDefaultArgs<ExtArgs>>): Prisma__VariationClient<$Result.GetResult<Prisma.$VariationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VariationApproval model
   */
  interface VariationApprovalFieldRefs {
    readonly id: FieldRef<"VariationApproval", 'String'>
    readonly orgId: FieldRef<"VariationApproval", 'String'>
    readonly variationId: FieldRef<"VariationApproval", 'String'>
    readonly approvedName: FieldRef<"VariationApproval", 'String'>
    readonly approvedEmail: FieldRef<"VariationApproval", 'String'>
    readonly approvedAt: FieldRef<"VariationApproval", 'DateTime'>
    readonly ipAddress: FieldRef<"VariationApproval", 'String'>
    readonly userAgent: FieldRef<"VariationApproval", 'String'>
    readonly createdAt: FieldRef<"VariationApproval", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VariationApproval findUnique
   */
  export type VariationApprovalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariationApproval
     */
    select?: VariationApprovalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VariationApproval
     */
    omit?: VariationApprovalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariationApprovalInclude<ExtArgs> | null
    /**
     * Filter, which VariationApproval to fetch.
     */
    where: VariationApprovalWhereUniqueInput
  }

  /**
   * VariationApproval findUniqueOrThrow
   */
  export type VariationApprovalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariationApproval
     */
    select?: VariationApprovalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VariationApproval
     */
    omit?: VariationApprovalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariationApprovalInclude<ExtArgs> | null
    /**
     * Filter, which VariationApproval to fetch.
     */
    where: VariationApprovalWhereUniqueInput
  }

  /**
   * VariationApproval findFirst
   */
  export type VariationApprovalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariationApproval
     */
    select?: VariationApprovalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VariationApproval
     */
    omit?: VariationApprovalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariationApprovalInclude<ExtArgs> | null
    /**
     * Filter, which VariationApproval to fetch.
     */
    where?: VariationApprovalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VariationApprovals to fetch.
     */
    orderBy?: VariationApprovalOrderByWithRelationInput | VariationApprovalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VariationApprovals.
     */
    cursor?: VariationApprovalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VariationApprovals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VariationApprovals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VariationApprovals.
     */
    distinct?: VariationApprovalScalarFieldEnum | VariationApprovalScalarFieldEnum[]
  }

  /**
   * VariationApproval findFirstOrThrow
   */
  export type VariationApprovalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariationApproval
     */
    select?: VariationApprovalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VariationApproval
     */
    omit?: VariationApprovalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariationApprovalInclude<ExtArgs> | null
    /**
     * Filter, which VariationApproval to fetch.
     */
    where?: VariationApprovalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VariationApprovals to fetch.
     */
    orderBy?: VariationApprovalOrderByWithRelationInput | VariationApprovalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VariationApprovals.
     */
    cursor?: VariationApprovalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VariationApprovals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VariationApprovals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VariationApprovals.
     */
    distinct?: VariationApprovalScalarFieldEnum | VariationApprovalScalarFieldEnum[]
  }

  /**
   * VariationApproval findMany
   */
  export type VariationApprovalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariationApproval
     */
    select?: VariationApprovalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VariationApproval
     */
    omit?: VariationApprovalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariationApprovalInclude<ExtArgs> | null
    /**
     * Filter, which VariationApprovals to fetch.
     */
    where?: VariationApprovalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VariationApprovals to fetch.
     */
    orderBy?: VariationApprovalOrderByWithRelationInput | VariationApprovalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VariationApprovals.
     */
    cursor?: VariationApprovalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VariationApprovals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VariationApprovals.
     */
    skip?: number
    distinct?: VariationApprovalScalarFieldEnum | VariationApprovalScalarFieldEnum[]
  }

  /**
   * VariationApproval create
   */
  export type VariationApprovalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariationApproval
     */
    select?: VariationApprovalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VariationApproval
     */
    omit?: VariationApprovalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariationApprovalInclude<ExtArgs> | null
    /**
     * The data needed to create a VariationApproval.
     */
    data: XOR<VariationApprovalCreateInput, VariationApprovalUncheckedCreateInput>
  }

  /**
   * VariationApproval createMany
   */
  export type VariationApprovalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VariationApprovals.
     */
    data: VariationApprovalCreateManyInput | VariationApprovalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VariationApproval createManyAndReturn
   */
  export type VariationApprovalCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariationApproval
     */
    select?: VariationApprovalSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VariationApproval
     */
    omit?: VariationApprovalOmit<ExtArgs> | null
    /**
     * The data used to create many VariationApprovals.
     */
    data: VariationApprovalCreateManyInput | VariationApprovalCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariationApprovalIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VariationApproval update
   */
  export type VariationApprovalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariationApproval
     */
    select?: VariationApprovalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VariationApproval
     */
    omit?: VariationApprovalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariationApprovalInclude<ExtArgs> | null
    /**
     * The data needed to update a VariationApproval.
     */
    data: XOR<VariationApprovalUpdateInput, VariationApprovalUncheckedUpdateInput>
    /**
     * Choose, which VariationApproval to update.
     */
    where: VariationApprovalWhereUniqueInput
  }

  /**
   * VariationApproval updateMany
   */
  export type VariationApprovalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VariationApprovals.
     */
    data: XOR<VariationApprovalUpdateManyMutationInput, VariationApprovalUncheckedUpdateManyInput>
    /**
     * Filter which VariationApprovals to update
     */
    where?: VariationApprovalWhereInput
    /**
     * Limit how many VariationApprovals to update.
     */
    limit?: number
  }

  /**
   * VariationApproval updateManyAndReturn
   */
  export type VariationApprovalUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariationApproval
     */
    select?: VariationApprovalSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VariationApproval
     */
    omit?: VariationApprovalOmit<ExtArgs> | null
    /**
     * The data used to update VariationApprovals.
     */
    data: XOR<VariationApprovalUpdateManyMutationInput, VariationApprovalUncheckedUpdateManyInput>
    /**
     * Filter which VariationApprovals to update
     */
    where?: VariationApprovalWhereInput
    /**
     * Limit how many VariationApprovals to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariationApprovalIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * VariationApproval upsert
   */
  export type VariationApprovalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariationApproval
     */
    select?: VariationApprovalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VariationApproval
     */
    omit?: VariationApprovalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariationApprovalInclude<ExtArgs> | null
    /**
     * The filter to search for the VariationApproval to update in case it exists.
     */
    where: VariationApprovalWhereUniqueInput
    /**
     * In case the VariationApproval found by the `where` argument doesn't exist, create a new VariationApproval with this data.
     */
    create: XOR<VariationApprovalCreateInput, VariationApprovalUncheckedCreateInput>
    /**
     * In case the VariationApproval was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VariationApprovalUpdateInput, VariationApprovalUncheckedUpdateInput>
  }

  /**
   * VariationApproval delete
   */
  export type VariationApprovalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariationApproval
     */
    select?: VariationApprovalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VariationApproval
     */
    omit?: VariationApprovalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariationApprovalInclude<ExtArgs> | null
    /**
     * Filter which VariationApproval to delete.
     */
    where: VariationApprovalWhereUniqueInput
  }

  /**
   * VariationApproval deleteMany
   */
  export type VariationApprovalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VariationApprovals to delete
     */
    where?: VariationApprovalWhereInput
    /**
     * Limit how many VariationApprovals to delete.
     */
    limit?: number
  }

  /**
   * VariationApproval without action
   */
  export type VariationApprovalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariationApproval
     */
    select?: VariationApprovalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VariationApproval
     */
    omit?: VariationApprovalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariationApprovalInclude<ExtArgs> | null
  }


  /**
   * Model VariationPublicLink
   */

  export type AggregateVariationPublicLink = {
    _count: VariationPublicLinkCountAggregateOutputType | null
    _avg: VariationPublicLinkAvgAggregateOutputType | null
    _sum: VariationPublicLinkSumAggregateOutputType | null
    _min: VariationPublicLinkMinAggregateOutputType | null
    _max: VariationPublicLinkMaxAggregateOutputType | null
  }

  export type VariationPublicLinkAvgAggregateOutputType = {
    viewCount: number | null
  }

  export type VariationPublicLinkSumAggregateOutputType = {
    viewCount: number | null
  }

  export type VariationPublicLinkMinAggregateOutputType = {
    id: string | null
    orgId: string | null
    variationId: string | null
    tokenHash: string | null
    tokenPrefix: string | null
    isActive: boolean | null
    expiresAt: Date | null
    revokedAt: Date | null
    firstViewedAt: Date | null
    lastViewedAt: Date | null
    viewCount: number | null
    createdByUserId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VariationPublicLinkMaxAggregateOutputType = {
    id: string | null
    orgId: string | null
    variationId: string | null
    tokenHash: string | null
    tokenPrefix: string | null
    isActive: boolean | null
    expiresAt: Date | null
    revokedAt: Date | null
    firstViewedAt: Date | null
    lastViewedAt: Date | null
    viewCount: number | null
    createdByUserId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VariationPublicLinkCountAggregateOutputType = {
    id: number
    orgId: number
    variationId: number
    tokenHash: number
    tokenPrefix: number
    isActive: number
    expiresAt: number
    revokedAt: number
    firstViewedAt: number
    lastViewedAt: number
    viewCount: number
    createdByUserId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VariationPublicLinkAvgAggregateInputType = {
    viewCount?: true
  }

  export type VariationPublicLinkSumAggregateInputType = {
    viewCount?: true
  }

  export type VariationPublicLinkMinAggregateInputType = {
    id?: true
    orgId?: true
    variationId?: true
    tokenHash?: true
    tokenPrefix?: true
    isActive?: true
    expiresAt?: true
    revokedAt?: true
    firstViewedAt?: true
    lastViewedAt?: true
    viewCount?: true
    createdByUserId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VariationPublicLinkMaxAggregateInputType = {
    id?: true
    orgId?: true
    variationId?: true
    tokenHash?: true
    tokenPrefix?: true
    isActive?: true
    expiresAt?: true
    revokedAt?: true
    firstViewedAt?: true
    lastViewedAt?: true
    viewCount?: true
    createdByUserId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VariationPublicLinkCountAggregateInputType = {
    id?: true
    orgId?: true
    variationId?: true
    tokenHash?: true
    tokenPrefix?: true
    isActive?: true
    expiresAt?: true
    revokedAt?: true
    firstViewedAt?: true
    lastViewedAt?: true
    viewCount?: true
    createdByUserId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VariationPublicLinkAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VariationPublicLink to aggregate.
     */
    where?: VariationPublicLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VariationPublicLinks to fetch.
     */
    orderBy?: VariationPublicLinkOrderByWithRelationInput | VariationPublicLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VariationPublicLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VariationPublicLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VariationPublicLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VariationPublicLinks
    **/
    _count?: true | VariationPublicLinkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VariationPublicLinkAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VariationPublicLinkSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VariationPublicLinkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VariationPublicLinkMaxAggregateInputType
  }

  export type GetVariationPublicLinkAggregateType<T extends VariationPublicLinkAggregateArgs> = {
        [P in keyof T & keyof AggregateVariationPublicLink]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVariationPublicLink[P]>
      : GetScalarType<T[P], AggregateVariationPublicLink[P]>
  }




  export type VariationPublicLinkGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VariationPublicLinkWhereInput
    orderBy?: VariationPublicLinkOrderByWithAggregationInput | VariationPublicLinkOrderByWithAggregationInput[]
    by: VariationPublicLinkScalarFieldEnum[] | VariationPublicLinkScalarFieldEnum
    having?: VariationPublicLinkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VariationPublicLinkCountAggregateInputType | true
    _avg?: VariationPublicLinkAvgAggregateInputType
    _sum?: VariationPublicLinkSumAggregateInputType
    _min?: VariationPublicLinkMinAggregateInputType
    _max?: VariationPublicLinkMaxAggregateInputType
  }

  export type VariationPublicLinkGroupByOutputType = {
    id: string
    orgId: string
    variationId: string
    tokenHash: string
    tokenPrefix: string | null
    isActive: boolean
    expiresAt: Date | null
    revokedAt: Date | null
    firstViewedAt: Date | null
    lastViewedAt: Date | null
    viewCount: number
    createdByUserId: string | null
    createdAt: Date
    updatedAt: Date
    _count: VariationPublicLinkCountAggregateOutputType | null
    _avg: VariationPublicLinkAvgAggregateOutputType | null
    _sum: VariationPublicLinkSumAggregateOutputType | null
    _min: VariationPublicLinkMinAggregateOutputType | null
    _max: VariationPublicLinkMaxAggregateOutputType | null
  }

  type GetVariationPublicLinkGroupByPayload<T extends VariationPublicLinkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VariationPublicLinkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VariationPublicLinkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VariationPublicLinkGroupByOutputType[P]>
            : GetScalarType<T[P], VariationPublicLinkGroupByOutputType[P]>
        }
      >
    >


  export type VariationPublicLinkSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    variationId?: boolean
    tokenHash?: boolean
    tokenPrefix?: boolean
    isActive?: boolean
    expiresAt?: boolean
    revokedAt?: boolean
    firstViewedAt?: boolean
    lastViewedAt?: boolean
    viewCount?: boolean
    createdByUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    variation?: boolean | VariationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["variationPublicLink"]>

  export type VariationPublicLinkSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    variationId?: boolean
    tokenHash?: boolean
    tokenPrefix?: boolean
    isActive?: boolean
    expiresAt?: boolean
    revokedAt?: boolean
    firstViewedAt?: boolean
    lastViewedAt?: boolean
    viewCount?: boolean
    createdByUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    variation?: boolean | VariationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["variationPublicLink"]>

  export type VariationPublicLinkSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    variationId?: boolean
    tokenHash?: boolean
    tokenPrefix?: boolean
    isActive?: boolean
    expiresAt?: boolean
    revokedAt?: boolean
    firstViewedAt?: boolean
    lastViewedAt?: boolean
    viewCount?: boolean
    createdByUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    variation?: boolean | VariationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["variationPublicLink"]>

  export type VariationPublicLinkSelectScalar = {
    id?: boolean
    orgId?: boolean
    variationId?: boolean
    tokenHash?: boolean
    tokenPrefix?: boolean
    isActive?: boolean
    expiresAt?: boolean
    revokedAt?: boolean
    firstViewedAt?: boolean
    lastViewedAt?: boolean
    viewCount?: boolean
    createdByUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VariationPublicLinkOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orgId" | "variationId" | "tokenHash" | "tokenPrefix" | "isActive" | "expiresAt" | "revokedAt" | "firstViewedAt" | "lastViewedAt" | "viewCount" | "createdByUserId" | "createdAt" | "updatedAt", ExtArgs["result"]["variationPublicLink"]>
  export type VariationPublicLinkInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    variation?: boolean | VariationDefaultArgs<ExtArgs>
  }
  export type VariationPublicLinkIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    variation?: boolean | VariationDefaultArgs<ExtArgs>
  }
  export type VariationPublicLinkIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    variation?: boolean | VariationDefaultArgs<ExtArgs>
  }

  export type $VariationPublicLinkPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VariationPublicLink"
    objects: {
      variation: Prisma.$VariationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orgId: string
      variationId: string
      tokenHash: string
      tokenPrefix: string | null
      isActive: boolean
      expiresAt: Date | null
      revokedAt: Date | null
      firstViewedAt: Date | null
      lastViewedAt: Date | null
      viewCount: number
      createdByUserId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["variationPublicLink"]>
    composites: {}
  }

  type VariationPublicLinkGetPayload<S extends boolean | null | undefined | VariationPublicLinkDefaultArgs> = $Result.GetResult<Prisma.$VariationPublicLinkPayload, S>

  type VariationPublicLinkCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VariationPublicLinkFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VariationPublicLinkCountAggregateInputType | true
    }

  export interface VariationPublicLinkDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VariationPublicLink'], meta: { name: 'VariationPublicLink' } }
    /**
     * Find zero or one VariationPublicLink that matches the filter.
     * @param {VariationPublicLinkFindUniqueArgs} args - Arguments to find a VariationPublicLink
     * @example
     * // Get one VariationPublicLink
     * const variationPublicLink = await prisma.variationPublicLink.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VariationPublicLinkFindUniqueArgs>(args: SelectSubset<T, VariationPublicLinkFindUniqueArgs<ExtArgs>>): Prisma__VariationPublicLinkClient<$Result.GetResult<Prisma.$VariationPublicLinkPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VariationPublicLink that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VariationPublicLinkFindUniqueOrThrowArgs} args - Arguments to find a VariationPublicLink
     * @example
     * // Get one VariationPublicLink
     * const variationPublicLink = await prisma.variationPublicLink.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VariationPublicLinkFindUniqueOrThrowArgs>(args: SelectSubset<T, VariationPublicLinkFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VariationPublicLinkClient<$Result.GetResult<Prisma.$VariationPublicLinkPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VariationPublicLink that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VariationPublicLinkFindFirstArgs} args - Arguments to find a VariationPublicLink
     * @example
     * // Get one VariationPublicLink
     * const variationPublicLink = await prisma.variationPublicLink.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VariationPublicLinkFindFirstArgs>(args?: SelectSubset<T, VariationPublicLinkFindFirstArgs<ExtArgs>>): Prisma__VariationPublicLinkClient<$Result.GetResult<Prisma.$VariationPublicLinkPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VariationPublicLink that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VariationPublicLinkFindFirstOrThrowArgs} args - Arguments to find a VariationPublicLink
     * @example
     * // Get one VariationPublicLink
     * const variationPublicLink = await prisma.variationPublicLink.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VariationPublicLinkFindFirstOrThrowArgs>(args?: SelectSubset<T, VariationPublicLinkFindFirstOrThrowArgs<ExtArgs>>): Prisma__VariationPublicLinkClient<$Result.GetResult<Prisma.$VariationPublicLinkPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VariationPublicLinks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VariationPublicLinkFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VariationPublicLinks
     * const variationPublicLinks = await prisma.variationPublicLink.findMany()
     * 
     * // Get first 10 VariationPublicLinks
     * const variationPublicLinks = await prisma.variationPublicLink.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const variationPublicLinkWithIdOnly = await prisma.variationPublicLink.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VariationPublicLinkFindManyArgs>(args?: SelectSubset<T, VariationPublicLinkFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VariationPublicLinkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VariationPublicLink.
     * @param {VariationPublicLinkCreateArgs} args - Arguments to create a VariationPublicLink.
     * @example
     * // Create one VariationPublicLink
     * const VariationPublicLink = await prisma.variationPublicLink.create({
     *   data: {
     *     // ... data to create a VariationPublicLink
     *   }
     * })
     * 
     */
    create<T extends VariationPublicLinkCreateArgs>(args: SelectSubset<T, VariationPublicLinkCreateArgs<ExtArgs>>): Prisma__VariationPublicLinkClient<$Result.GetResult<Prisma.$VariationPublicLinkPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VariationPublicLinks.
     * @param {VariationPublicLinkCreateManyArgs} args - Arguments to create many VariationPublicLinks.
     * @example
     * // Create many VariationPublicLinks
     * const variationPublicLink = await prisma.variationPublicLink.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VariationPublicLinkCreateManyArgs>(args?: SelectSubset<T, VariationPublicLinkCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VariationPublicLinks and returns the data saved in the database.
     * @param {VariationPublicLinkCreateManyAndReturnArgs} args - Arguments to create many VariationPublicLinks.
     * @example
     * // Create many VariationPublicLinks
     * const variationPublicLink = await prisma.variationPublicLink.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VariationPublicLinks and only return the `id`
     * const variationPublicLinkWithIdOnly = await prisma.variationPublicLink.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VariationPublicLinkCreateManyAndReturnArgs>(args?: SelectSubset<T, VariationPublicLinkCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VariationPublicLinkPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VariationPublicLink.
     * @param {VariationPublicLinkDeleteArgs} args - Arguments to delete one VariationPublicLink.
     * @example
     * // Delete one VariationPublicLink
     * const VariationPublicLink = await prisma.variationPublicLink.delete({
     *   where: {
     *     // ... filter to delete one VariationPublicLink
     *   }
     * })
     * 
     */
    delete<T extends VariationPublicLinkDeleteArgs>(args: SelectSubset<T, VariationPublicLinkDeleteArgs<ExtArgs>>): Prisma__VariationPublicLinkClient<$Result.GetResult<Prisma.$VariationPublicLinkPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VariationPublicLink.
     * @param {VariationPublicLinkUpdateArgs} args - Arguments to update one VariationPublicLink.
     * @example
     * // Update one VariationPublicLink
     * const variationPublicLink = await prisma.variationPublicLink.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VariationPublicLinkUpdateArgs>(args: SelectSubset<T, VariationPublicLinkUpdateArgs<ExtArgs>>): Prisma__VariationPublicLinkClient<$Result.GetResult<Prisma.$VariationPublicLinkPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VariationPublicLinks.
     * @param {VariationPublicLinkDeleteManyArgs} args - Arguments to filter VariationPublicLinks to delete.
     * @example
     * // Delete a few VariationPublicLinks
     * const { count } = await prisma.variationPublicLink.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VariationPublicLinkDeleteManyArgs>(args?: SelectSubset<T, VariationPublicLinkDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VariationPublicLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VariationPublicLinkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VariationPublicLinks
     * const variationPublicLink = await prisma.variationPublicLink.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VariationPublicLinkUpdateManyArgs>(args: SelectSubset<T, VariationPublicLinkUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VariationPublicLinks and returns the data updated in the database.
     * @param {VariationPublicLinkUpdateManyAndReturnArgs} args - Arguments to update many VariationPublicLinks.
     * @example
     * // Update many VariationPublicLinks
     * const variationPublicLink = await prisma.variationPublicLink.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VariationPublicLinks and only return the `id`
     * const variationPublicLinkWithIdOnly = await prisma.variationPublicLink.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VariationPublicLinkUpdateManyAndReturnArgs>(args: SelectSubset<T, VariationPublicLinkUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VariationPublicLinkPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VariationPublicLink.
     * @param {VariationPublicLinkUpsertArgs} args - Arguments to update or create a VariationPublicLink.
     * @example
     * // Update or create a VariationPublicLink
     * const variationPublicLink = await prisma.variationPublicLink.upsert({
     *   create: {
     *     // ... data to create a VariationPublicLink
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VariationPublicLink we want to update
     *   }
     * })
     */
    upsert<T extends VariationPublicLinkUpsertArgs>(args: SelectSubset<T, VariationPublicLinkUpsertArgs<ExtArgs>>): Prisma__VariationPublicLinkClient<$Result.GetResult<Prisma.$VariationPublicLinkPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VariationPublicLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VariationPublicLinkCountArgs} args - Arguments to filter VariationPublicLinks to count.
     * @example
     * // Count the number of VariationPublicLinks
     * const count = await prisma.variationPublicLink.count({
     *   where: {
     *     // ... the filter for the VariationPublicLinks we want to count
     *   }
     * })
    **/
    count<T extends VariationPublicLinkCountArgs>(
      args?: Subset<T, VariationPublicLinkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VariationPublicLinkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VariationPublicLink.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VariationPublicLinkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VariationPublicLinkAggregateArgs>(args: Subset<T, VariationPublicLinkAggregateArgs>): Prisma.PrismaPromise<GetVariationPublicLinkAggregateType<T>>

    /**
     * Group by VariationPublicLink.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VariationPublicLinkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VariationPublicLinkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VariationPublicLinkGroupByArgs['orderBy'] }
        : { orderBy?: VariationPublicLinkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VariationPublicLinkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVariationPublicLinkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VariationPublicLink model
   */
  readonly fields: VariationPublicLinkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VariationPublicLink.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VariationPublicLinkClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    variation<T extends VariationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VariationDefaultArgs<ExtArgs>>): Prisma__VariationClient<$Result.GetResult<Prisma.$VariationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VariationPublicLink model
   */
  interface VariationPublicLinkFieldRefs {
    readonly id: FieldRef<"VariationPublicLink", 'String'>
    readonly orgId: FieldRef<"VariationPublicLink", 'String'>
    readonly variationId: FieldRef<"VariationPublicLink", 'String'>
    readonly tokenHash: FieldRef<"VariationPublicLink", 'String'>
    readonly tokenPrefix: FieldRef<"VariationPublicLink", 'String'>
    readonly isActive: FieldRef<"VariationPublicLink", 'Boolean'>
    readonly expiresAt: FieldRef<"VariationPublicLink", 'DateTime'>
    readonly revokedAt: FieldRef<"VariationPublicLink", 'DateTime'>
    readonly firstViewedAt: FieldRef<"VariationPublicLink", 'DateTime'>
    readonly lastViewedAt: FieldRef<"VariationPublicLink", 'DateTime'>
    readonly viewCount: FieldRef<"VariationPublicLink", 'Int'>
    readonly createdByUserId: FieldRef<"VariationPublicLink", 'String'>
    readonly createdAt: FieldRef<"VariationPublicLink", 'DateTime'>
    readonly updatedAt: FieldRef<"VariationPublicLink", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VariationPublicLink findUnique
   */
  export type VariationPublicLinkFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariationPublicLink
     */
    select?: VariationPublicLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VariationPublicLink
     */
    omit?: VariationPublicLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariationPublicLinkInclude<ExtArgs> | null
    /**
     * Filter, which VariationPublicLink to fetch.
     */
    where: VariationPublicLinkWhereUniqueInput
  }

  /**
   * VariationPublicLink findUniqueOrThrow
   */
  export type VariationPublicLinkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariationPublicLink
     */
    select?: VariationPublicLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VariationPublicLink
     */
    omit?: VariationPublicLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariationPublicLinkInclude<ExtArgs> | null
    /**
     * Filter, which VariationPublicLink to fetch.
     */
    where: VariationPublicLinkWhereUniqueInput
  }

  /**
   * VariationPublicLink findFirst
   */
  export type VariationPublicLinkFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariationPublicLink
     */
    select?: VariationPublicLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VariationPublicLink
     */
    omit?: VariationPublicLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariationPublicLinkInclude<ExtArgs> | null
    /**
     * Filter, which VariationPublicLink to fetch.
     */
    where?: VariationPublicLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VariationPublicLinks to fetch.
     */
    orderBy?: VariationPublicLinkOrderByWithRelationInput | VariationPublicLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VariationPublicLinks.
     */
    cursor?: VariationPublicLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VariationPublicLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VariationPublicLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VariationPublicLinks.
     */
    distinct?: VariationPublicLinkScalarFieldEnum | VariationPublicLinkScalarFieldEnum[]
  }

  /**
   * VariationPublicLink findFirstOrThrow
   */
  export type VariationPublicLinkFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariationPublicLink
     */
    select?: VariationPublicLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VariationPublicLink
     */
    omit?: VariationPublicLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariationPublicLinkInclude<ExtArgs> | null
    /**
     * Filter, which VariationPublicLink to fetch.
     */
    where?: VariationPublicLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VariationPublicLinks to fetch.
     */
    orderBy?: VariationPublicLinkOrderByWithRelationInput | VariationPublicLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VariationPublicLinks.
     */
    cursor?: VariationPublicLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VariationPublicLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VariationPublicLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VariationPublicLinks.
     */
    distinct?: VariationPublicLinkScalarFieldEnum | VariationPublicLinkScalarFieldEnum[]
  }

  /**
   * VariationPublicLink findMany
   */
  export type VariationPublicLinkFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariationPublicLink
     */
    select?: VariationPublicLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VariationPublicLink
     */
    omit?: VariationPublicLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariationPublicLinkInclude<ExtArgs> | null
    /**
     * Filter, which VariationPublicLinks to fetch.
     */
    where?: VariationPublicLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VariationPublicLinks to fetch.
     */
    orderBy?: VariationPublicLinkOrderByWithRelationInput | VariationPublicLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VariationPublicLinks.
     */
    cursor?: VariationPublicLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VariationPublicLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VariationPublicLinks.
     */
    skip?: number
    distinct?: VariationPublicLinkScalarFieldEnum | VariationPublicLinkScalarFieldEnum[]
  }

  /**
   * VariationPublicLink create
   */
  export type VariationPublicLinkCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariationPublicLink
     */
    select?: VariationPublicLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VariationPublicLink
     */
    omit?: VariationPublicLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariationPublicLinkInclude<ExtArgs> | null
    /**
     * The data needed to create a VariationPublicLink.
     */
    data: XOR<VariationPublicLinkCreateInput, VariationPublicLinkUncheckedCreateInput>
  }

  /**
   * VariationPublicLink createMany
   */
  export type VariationPublicLinkCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VariationPublicLinks.
     */
    data: VariationPublicLinkCreateManyInput | VariationPublicLinkCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VariationPublicLink createManyAndReturn
   */
  export type VariationPublicLinkCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariationPublicLink
     */
    select?: VariationPublicLinkSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VariationPublicLink
     */
    omit?: VariationPublicLinkOmit<ExtArgs> | null
    /**
     * The data used to create many VariationPublicLinks.
     */
    data: VariationPublicLinkCreateManyInput | VariationPublicLinkCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariationPublicLinkIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VariationPublicLink update
   */
  export type VariationPublicLinkUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariationPublicLink
     */
    select?: VariationPublicLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VariationPublicLink
     */
    omit?: VariationPublicLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariationPublicLinkInclude<ExtArgs> | null
    /**
     * The data needed to update a VariationPublicLink.
     */
    data: XOR<VariationPublicLinkUpdateInput, VariationPublicLinkUncheckedUpdateInput>
    /**
     * Choose, which VariationPublicLink to update.
     */
    where: VariationPublicLinkWhereUniqueInput
  }

  /**
   * VariationPublicLink updateMany
   */
  export type VariationPublicLinkUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VariationPublicLinks.
     */
    data: XOR<VariationPublicLinkUpdateManyMutationInput, VariationPublicLinkUncheckedUpdateManyInput>
    /**
     * Filter which VariationPublicLinks to update
     */
    where?: VariationPublicLinkWhereInput
    /**
     * Limit how many VariationPublicLinks to update.
     */
    limit?: number
  }

  /**
   * VariationPublicLink updateManyAndReturn
   */
  export type VariationPublicLinkUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariationPublicLink
     */
    select?: VariationPublicLinkSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VariationPublicLink
     */
    omit?: VariationPublicLinkOmit<ExtArgs> | null
    /**
     * The data used to update VariationPublicLinks.
     */
    data: XOR<VariationPublicLinkUpdateManyMutationInput, VariationPublicLinkUncheckedUpdateManyInput>
    /**
     * Filter which VariationPublicLinks to update
     */
    where?: VariationPublicLinkWhereInput
    /**
     * Limit how many VariationPublicLinks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariationPublicLinkIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * VariationPublicLink upsert
   */
  export type VariationPublicLinkUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariationPublicLink
     */
    select?: VariationPublicLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VariationPublicLink
     */
    omit?: VariationPublicLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariationPublicLinkInclude<ExtArgs> | null
    /**
     * The filter to search for the VariationPublicLink to update in case it exists.
     */
    where: VariationPublicLinkWhereUniqueInput
    /**
     * In case the VariationPublicLink found by the `where` argument doesn't exist, create a new VariationPublicLink with this data.
     */
    create: XOR<VariationPublicLinkCreateInput, VariationPublicLinkUncheckedCreateInput>
    /**
     * In case the VariationPublicLink was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VariationPublicLinkUpdateInput, VariationPublicLinkUncheckedUpdateInput>
  }

  /**
   * VariationPublicLink delete
   */
  export type VariationPublicLinkDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariationPublicLink
     */
    select?: VariationPublicLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VariationPublicLink
     */
    omit?: VariationPublicLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariationPublicLinkInclude<ExtArgs> | null
    /**
     * Filter which VariationPublicLink to delete.
     */
    where: VariationPublicLinkWhereUniqueInput
  }

  /**
   * VariationPublicLink deleteMany
   */
  export type VariationPublicLinkDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VariationPublicLinks to delete
     */
    where?: VariationPublicLinkWhereInput
    /**
     * Limit how many VariationPublicLinks to delete.
     */
    limit?: number
  }

  /**
   * VariationPublicLink without action
   */
  export type VariationPublicLinkDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariationPublicLink
     */
    select?: VariationPublicLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VariationPublicLink
     */
    omit?: VariationPublicLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariationPublicLinkInclude<ExtArgs> | null
  }


  /**
   * Model VariationPdf
   */

  export type AggregateVariationPdf = {
    _count: VariationPdfCountAggregateOutputType | null
    _min: VariationPdfMinAggregateOutputType | null
    _max: VariationPdfMaxAggregateOutputType | null
  }

  export type VariationPdfMinAggregateOutputType = {
    id: string | null
    orgId: string | null
    variationId: string | null
    stage: $Enums.VariationPdfStage | null
    fileUrl: string | null
    createdAt: Date | null
  }

  export type VariationPdfMaxAggregateOutputType = {
    id: string | null
    orgId: string | null
    variationId: string | null
    stage: $Enums.VariationPdfStage | null
    fileUrl: string | null
    createdAt: Date | null
  }

  export type VariationPdfCountAggregateOutputType = {
    id: number
    orgId: number
    variationId: number
    stage: number
    fileUrl: number
    createdAt: number
    _all: number
  }


  export type VariationPdfMinAggregateInputType = {
    id?: true
    orgId?: true
    variationId?: true
    stage?: true
    fileUrl?: true
    createdAt?: true
  }

  export type VariationPdfMaxAggregateInputType = {
    id?: true
    orgId?: true
    variationId?: true
    stage?: true
    fileUrl?: true
    createdAt?: true
  }

  export type VariationPdfCountAggregateInputType = {
    id?: true
    orgId?: true
    variationId?: true
    stage?: true
    fileUrl?: true
    createdAt?: true
    _all?: true
  }

  export type VariationPdfAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VariationPdf to aggregate.
     */
    where?: VariationPdfWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VariationPdfs to fetch.
     */
    orderBy?: VariationPdfOrderByWithRelationInput | VariationPdfOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VariationPdfWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VariationPdfs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VariationPdfs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VariationPdfs
    **/
    _count?: true | VariationPdfCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VariationPdfMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VariationPdfMaxAggregateInputType
  }

  export type GetVariationPdfAggregateType<T extends VariationPdfAggregateArgs> = {
        [P in keyof T & keyof AggregateVariationPdf]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVariationPdf[P]>
      : GetScalarType<T[P], AggregateVariationPdf[P]>
  }




  export type VariationPdfGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VariationPdfWhereInput
    orderBy?: VariationPdfOrderByWithAggregationInput | VariationPdfOrderByWithAggregationInput[]
    by: VariationPdfScalarFieldEnum[] | VariationPdfScalarFieldEnum
    having?: VariationPdfScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VariationPdfCountAggregateInputType | true
    _min?: VariationPdfMinAggregateInputType
    _max?: VariationPdfMaxAggregateInputType
  }

  export type VariationPdfGroupByOutputType = {
    id: string
    orgId: string
    variationId: string
    stage: $Enums.VariationPdfStage
    fileUrl: string
    createdAt: Date
    _count: VariationPdfCountAggregateOutputType | null
    _min: VariationPdfMinAggregateOutputType | null
    _max: VariationPdfMaxAggregateOutputType | null
  }

  type GetVariationPdfGroupByPayload<T extends VariationPdfGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VariationPdfGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VariationPdfGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VariationPdfGroupByOutputType[P]>
            : GetScalarType<T[P], VariationPdfGroupByOutputType[P]>
        }
      >
    >


  export type VariationPdfSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    variationId?: boolean
    stage?: boolean
    fileUrl?: boolean
    createdAt?: boolean
    variation?: boolean | VariationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["variationPdf"]>

  export type VariationPdfSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    variationId?: boolean
    stage?: boolean
    fileUrl?: boolean
    createdAt?: boolean
    variation?: boolean | VariationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["variationPdf"]>

  export type VariationPdfSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orgId?: boolean
    variationId?: boolean
    stage?: boolean
    fileUrl?: boolean
    createdAt?: boolean
    variation?: boolean | VariationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["variationPdf"]>

  export type VariationPdfSelectScalar = {
    id?: boolean
    orgId?: boolean
    variationId?: boolean
    stage?: boolean
    fileUrl?: boolean
    createdAt?: boolean
  }

  export type VariationPdfOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orgId" | "variationId" | "stage" | "fileUrl" | "createdAt", ExtArgs["result"]["variationPdf"]>
  export type VariationPdfInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    variation?: boolean | VariationDefaultArgs<ExtArgs>
  }
  export type VariationPdfIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    variation?: boolean | VariationDefaultArgs<ExtArgs>
  }
  export type VariationPdfIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    variation?: boolean | VariationDefaultArgs<ExtArgs>
  }

  export type $VariationPdfPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VariationPdf"
    objects: {
      variation: Prisma.$VariationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orgId: string
      variationId: string
      stage: $Enums.VariationPdfStage
      fileUrl: string
      createdAt: Date
    }, ExtArgs["result"]["variationPdf"]>
    composites: {}
  }

  type VariationPdfGetPayload<S extends boolean | null | undefined | VariationPdfDefaultArgs> = $Result.GetResult<Prisma.$VariationPdfPayload, S>

  type VariationPdfCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VariationPdfFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VariationPdfCountAggregateInputType | true
    }

  export interface VariationPdfDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VariationPdf'], meta: { name: 'VariationPdf' } }
    /**
     * Find zero or one VariationPdf that matches the filter.
     * @param {VariationPdfFindUniqueArgs} args - Arguments to find a VariationPdf
     * @example
     * // Get one VariationPdf
     * const variationPdf = await prisma.variationPdf.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VariationPdfFindUniqueArgs>(args: SelectSubset<T, VariationPdfFindUniqueArgs<ExtArgs>>): Prisma__VariationPdfClient<$Result.GetResult<Prisma.$VariationPdfPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VariationPdf that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VariationPdfFindUniqueOrThrowArgs} args - Arguments to find a VariationPdf
     * @example
     * // Get one VariationPdf
     * const variationPdf = await prisma.variationPdf.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VariationPdfFindUniqueOrThrowArgs>(args: SelectSubset<T, VariationPdfFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VariationPdfClient<$Result.GetResult<Prisma.$VariationPdfPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VariationPdf that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VariationPdfFindFirstArgs} args - Arguments to find a VariationPdf
     * @example
     * // Get one VariationPdf
     * const variationPdf = await prisma.variationPdf.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VariationPdfFindFirstArgs>(args?: SelectSubset<T, VariationPdfFindFirstArgs<ExtArgs>>): Prisma__VariationPdfClient<$Result.GetResult<Prisma.$VariationPdfPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VariationPdf that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VariationPdfFindFirstOrThrowArgs} args - Arguments to find a VariationPdf
     * @example
     * // Get one VariationPdf
     * const variationPdf = await prisma.variationPdf.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VariationPdfFindFirstOrThrowArgs>(args?: SelectSubset<T, VariationPdfFindFirstOrThrowArgs<ExtArgs>>): Prisma__VariationPdfClient<$Result.GetResult<Prisma.$VariationPdfPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VariationPdfs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VariationPdfFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VariationPdfs
     * const variationPdfs = await prisma.variationPdf.findMany()
     * 
     * // Get first 10 VariationPdfs
     * const variationPdfs = await prisma.variationPdf.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const variationPdfWithIdOnly = await prisma.variationPdf.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VariationPdfFindManyArgs>(args?: SelectSubset<T, VariationPdfFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VariationPdfPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VariationPdf.
     * @param {VariationPdfCreateArgs} args - Arguments to create a VariationPdf.
     * @example
     * // Create one VariationPdf
     * const VariationPdf = await prisma.variationPdf.create({
     *   data: {
     *     // ... data to create a VariationPdf
     *   }
     * })
     * 
     */
    create<T extends VariationPdfCreateArgs>(args: SelectSubset<T, VariationPdfCreateArgs<ExtArgs>>): Prisma__VariationPdfClient<$Result.GetResult<Prisma.$VariationPdfPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VariationPdfs.
     * @param {VariationPdfCreateManyArgs} args - Arguments to create many VariationPdfs.
     * @example
     * // Create many VariationPdfs
     * const variationPdf = await prisma.variationPdf.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VariationPdfCreateManyArgs>(args?: SelectSubset<T, VariationPdfCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VariationPdfs and returns the data saved in the database.
     * @param {VariationPdfCreateManyAndReturnArgs} args - Arguments to create many VariationPdfs.
     * @example
     * // Create many VariationPdfs
     * const variationPdf = await prisma.variationPdf.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VariationPdfs and only return the `id`
     * const variationPdfWithIdOnly = await prisma.variationPdf.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VariationPdfCreateManyAndReturnArgs>(args?: SelectSubset<T, VariationPdfCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VariationPdfPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VariationPdf.
     * @param {VariationPdfDeleteArgs} args - Arguments to delete one VariationPdf.
     * @example
     * // Delete one VariationPdf
     * const VariationPdf = await prisma.variationPdf.delete({
     *   where: {
     *     // ... filter to delete one VariationPdf
     *   }
     * })
     * 
     */
    delete<T extends VariationPdfDeleteArgs>(args: SelectSubset<T, VariationPdfDeleteArgs<ExtArgs>>): Prisma__VariationPdfClient<$Result.GetResult<Prisma.$VariationPdfPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VariationPdf.
     * @param {VariationPdfUpdateArgs} args - Arguments to update one VariationPdf.
     * @example
     * // Update one VariationPdf
     * const variationPdf = await prisma.variationPdf.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VariationPdfUpdateArgs>(args: SelectSubset<T, VariationPdfUpdateArgs<ExtArgs>>): Prisma__VariationPdfClient<$Result.GetResult<Prisma.$VariationPdfPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VariationPdfs.
     * @param {VariationPdfDeleteManyArgs} args - Arguments to filter VariationPdfs to delete.
     * @example
     * // Delete a few VariationPdfs
     * const { count } = await prisma.variationPdf.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VariationPdfDeleteManyArgs>(args?: SelectSubset<T, VariationPdfDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VariationPdfs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VariationPdfUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VariationPdfs
     * const variationPdf = await prisma.variationPdf.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VariationPdfUpdateManyArgs>(args: SelectSubset<T, VariationPdfUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VariationPdfs and returns the data updated in the database.
     * @param {VariationPdfUpdateManyAndReturnArgs} args - Arguments to update many VariationPdfs.
     * @example
     * // Update many VariationPdfs
     * const variationPdf = await prisma.variationPdf.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VariationPdfs and only return the `id`
     * const variationPdfWithIdOnly = await prisma.variationPdf.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VariationPdfUpdateManyAndReturnArgs>(args: SelectSubset<T, VariationPdfUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VariationPdfPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VariationPdf.
     * @param {VariationPdfUpsertArgs} args - Arguments to update or create a VariationPdf.
     * @example
     * // Update or create a VariationPdf
     * const variationPdf = await prisma.variationPdf.upsert({
     *   create: {
     *     // ... data to create a VariationPdf
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VariationPdf we want to update
     *   }
     * })
     */
    upsert<T extends VariationPdfUpsertArgs>(args: SelectSubset<T, VariationPdfUpsertArgs<ExtArgs>>): Prisma__VariationPdfClient<$Result.GetResult<Prisma.$VariationPdfPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VariationPdfs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VariationPdfCountArgs} args - Arguments to filter VariationPdfs to count.
     * @example
     * // Count the number of VariationPdfs
     * const count = await prisma.variationPdf.count({
     *   where: {
     *     // ... the filter for the VariationPdfs we want to count
     *   }
     * })
    **/
    count<T extends VariationPdfCountArgs>(
      args?: Subset<T, VariationPdfCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VariationPdfCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VariationPdf.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VariationPdfAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VariationPdfAggregateArgs>(args: Subset<T, VariationPdfAggregateArgs>): Prisma.PrismaPromise<GetVariationPdfAggregateType<T>>

    /**
     * Group by VariationPdf.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VariationPdfGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VariationPdfGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VariationPdfGroupByArgs['orderBy'] }
        : { orderBy?: VariationPdfGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VariationPdfGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVariationPdfGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VariationPdf model
   */
  readonly fields: VariationPdfFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VariationPdf.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VariationPdfClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    variation<T extends VariationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VariationDefaultArgs<ExtArgs>>): Prisma__VariationClient<$Result.GetResult<Prisma.$VariationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VariationPdf model
   */
  interface VariationPdfFieldRefs {
    readonly id: FieldRef<"VariationPdf", 'String'>
    readonly orgId: FieldRef<"VariationPdf", 'String'>
    readonly variationId: FieldRef<"VariationPdf", 'String'>
    readonly stage: FieldRef<"VariationPdf", 'VariationPdfStage'>
    readonly fileUrl: FieldRef<"VariationPdf", 'String'>
    readonly createdAt: FieldRef<"VariationPdf", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VariationPdf findUnique
   */
  export type VariationPdfFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariationPdf
     */
    select?: VariationPdfSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VariationPdf
     */
    omit?: VariationPdfOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariationPdfInclude<ExtArgs> | null
    /**
     * Filter, which VariationPdf to fetch.
     */
    where: VariationPdfWhereUniqueInput
  }

  /**
   * VariationPdf findUniqueOrThrow
   */
  export type VariationPdfFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariationPdf
     */
    select?: VariationPdfSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VariationPdf
     */
    omit?: VariationPdfOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariationPdfInclude<ExtArgs> | null
    /**
     * Filter, which VariationPdf to fetch.
     */
    where: VariationPdfWhereUniqueInput
  }

  /**
   * VariationPdf findFirst
   */
  export type VariationPdfFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariationPdf
     */
    select?: VariationPdfSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VariationPdf
     */
    omit?: VariationPdfOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariationPdfInclude<ExtArgs> | null
    /**
     * Filter, which VariationPdf to fetch.
     */
    where?: VariationPdfWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VariationPdfs to fetch.
     */
    orderBy?: VariationPdfOrderByWithRelationInput | VariationPdfOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VariationPdfs.
     */
    cursor?: VariationPdfWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VariationPdfs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VariationPdfs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VariationPdfs.
     */
    distinct?: VariationPdfScalarFieldEnum | VariationPdfScalarFieldEnum[]
  }

  /**
   * VariationPdf findFirstOrThrow
   */
  export type VariationPdfFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariationPdf
     */
    select?: VariationPdfSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VariationPdf
     */
    omit?: VariationPdfOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariationPdfInclude<ExtArgs> | null
    /**
     * Filter, which VariationPdf to fetch.
     */
    where?: VariationPdfWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VariationPdfs to fetch.
     */
    orderBy?: VariationPdfOrderByWithRelationInput | VariationPdfOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VariationPdfs.
     */
    cursor?: VariationPdfWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VariationPdfs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VariationPdfs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VariationPdfs.
     */
    distinct?: VariationPdfScalarFieldEnum | VariationPdfScalarFieldEnum[]
  }

  /**
   * VariationPdf findMany
   */
  export type VariationPdfFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariationPdf
     */
    select?: VariationPdfSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VariationPdf
     */
    omit?: VariationPdfOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariationPdfInclude<ExtArgs> | null
    /**
     * Filter, which VariationPdfs to fetch.
     */
    where?: VariationPdfWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VariationPdfs to fetch.
     */
    orderBy?: VariationPdfOrderByWithRelationInput | VariationPdfOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VariationPdfs.
     */
    cursor?: VariationPdfWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VariationPdfs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VariationPdfs.
     */
    skip?: number
    distinct?: VariationPdfScalarFieldEnum | VariationPdfScalarFieldEnum[]
  }

  /**
   * VariationPdf create
   */
  export type VariationPdfCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariationPdf
     */
    select?: VariationPdfSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VariationPdf
     */
    omit?: VariationPdfOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariationPdfInclude<ExtArgs> | null
    /**
     * The data needed to create a VariationPdf.
     */
    data: XOR<VariationPdfCreateInput, VariationPdfUncheckedCreateInput>
  }

  /**
   * VariationPdf createMany
   */
  export type VariationPdfCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VariationPdfs.
     */
    data: VariationPdfCreateManyInput | VariationPdfCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VariationPdf createManyAndReturn
   */
  export type VariationPdfCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariationPdf
     */
    select?: VariationPdfSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VariationPdf
     */
    omit?: VariationPdfOmit<ExtArgs> | null
    /**
     * The data used to create many VariationPdfs.
     */
    data: VariationPdfCreateManyInput | VariationPdfCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariationPdfIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VariationPdf update
   */
  export type VariationPdfUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariationPdf
     */
    select?: VariationPdfSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VariationPdf
     */
    omit?: VariationPdfOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariationPdfInclude<ExtArgs> | null
    /**
     * The data needed to update a VariationPdf.
     */
    data: XOR<VariationPdfUpdateInput, VariationPdfUncheckedUpdateInput>
    /**
     * Choose, which VariationPdf to update.
     */
    where: VariationPdfWhereUniqueInput
  }

  /**
   * VariationPdf updateMany
   */
  export type VariationPdfUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VariationPdfs.
     */
    data: XOR<VariationPdfUpdateManyMutationInput, VariationPdfUncheckedUpdateManyInput>
    /**
     * Filter which VariationPdfs to update
     */
    where?: VariationPdfWhereInput
    /**
     * Limit how many VariationPdfs to update.
     */
    limit?: number
  }

  /**
   * VariationPdf updateManyAndReturn
   */
  export type VariationPdfUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariationPdf
     */
    select?: VariationPdfSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VariationPdf
     */
    omit?: VariationPdfOmit<ExtArgs> | null
    /**
     * The data used to update VariationPdfs.
     */
    data: XOR<VariationPdfUpdateManyMutationInput, VariationPdfUncheckedUpdateManyInput>
    /**
     * Filter which VariationPdfs to update
     */
    where?: VariationPdfWhereInput
    /**
     * Limit how many VariationPdfs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariationPdfIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * VariationPdf upsert
   */
  export type VariationPdfUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariationPdf
     */
    select?: VariationPdfSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VariationPdf
     */
    omit?: VariationPdfOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariationPdfInclude<ExtArgs> | null
    /**
     * The filter to search for the VariationPdf to update in case it exists.
     */
    where: VariationPdfWhereUniqueInput
    /**
     * In case the VariationPdf found by the `where` argument doesn't exist, create a new VariationPdf with this data.
     */
    create: XOR<VariationPdfCreateInput, VariationPdfUncheckedCreateInput>
    /**
     * In case the VariationPdf was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VariationPdfUpdateInput, VariationPdfUncheckedUpdateInput>
  }

  /**
   * VariationPdf delete
   */
  export type VariationPdfDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariationPdf
     */
    select?: VariationPdfSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VariationPdf
     */
    omit?: VariationPdfOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariationPdfInclude<ExtArgs> | null
    /**
     * Filter which VariationPdf to delete.
     */
    where: VariationPdfWhereUniqueInput
  }

  /**
   * VariationPdf deleteMany
   */
  export type VariationPdfDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VariationPdfs to delete
     */
    where?: VariationPdfWhereInput
    /**
     * Limit how many VariationPdfs to delete.
     */
    limit?: number
  }

  /**
   * VariationPdf without action
   */
  export type VariationPdfDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariationPdf
     */
    select?: VariationPdfSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VariationPdf
     */
    omit?: VariationPdfOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariationPdfInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const CompanySettingsScalarFieldEnum: {
    id: 'id',
    orgId: 'orgId',
    companyName: 'companyName',
    logoUrl: 'logoUrl',
    addressLine1: 'addressLine1',
    addressLine2: 'addressLine2',
    city: 'city',
    postcode: 'postcode',
    country: 'country',
    phone: 'phone',
    email: 'email',
    website: 'website',
    defaultVatMode: 'defaultVatMode',
    defaultVatRateBps: 'defaultVatRateBps',
    defaultGrouping: 'defaultGrouping',
    defaultShowQtyToClient: 'defaultShowQtyToClient',
    defaultShowUnitRatesToClient: 'defaultShowUnitRatesToClient',
    defaultTermsJson: 'defaultTermsJson',
    defaultScopeOverviewJson: 'defaultScopeOverviewJson',
    createdByUserId: 'createdByUserId',
    updatedByUserId: 'updatedByUserId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CompanySettingsScalarFieldEnum = (typeof CompanySettingsScalarFieldEnum)[keyof typeof CompanySettingsScalarFieldEnum]


  export const ClientScalarFieldEnum: {
    id: 'id',
    orgId: 'orgId',
    name: 'name',
    email: 'email',
    phone: 'phone',
    addressLine1: 'addressLine1',
    addressLine2: 'addressLine2',
    city: 'city',
    postcode: 'postcode',
    country: 'country',
    notes: 'notes',
    createdByUserId: 'createdByUserId',
    updatedByUserId: 'updatedByUserId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ClientScalarFieldEnum = (typeof ClientScalarFieldEnum)[keyof typeof ClientScalarFieldEnum]


  export const QuoteScalarFieldEnum: {
    id: 'id',
    orgId: 'orgId',
    clientId: 'clientId',
    title: 'title',
    referenceNo: 'referenceNo',
    projectAddress: 'projectAddress',
    status: 'status',
    currentVersion: 'currentVersion',
    sentAt: 'sentAt',
    acceptedAt: 'acceptedAt',
    vatMode: 'vatMode',
    vatRateBps: 'vatRateBps',
    depositType: 'depositType',
    depositAmountPence: 'depositAmountPence',
    depositPercentBps: 'depositPercentBps',
    paymentScheduleJson: 'paymentScheduleJson',
    showQtyToClient: 'showQtyToClient',
    showUnitRatesToClient: 'showUnitRatesToClient',
    scopeOverviewJson: 'scopeOverviewJson',
    termsJson: 'termsJson',
    estimatedStartDate: 'estimatedStartDate',
    estimatedDurationWeeks: 'estimatedDurationWeeks',
    createdByUserId: 'createdByUserId',
    updatedByUserId: 'updatedByUserId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type QuoteScalarFieldEnum = (typeof QuoteScalarFieldEnum)[keyof typeof QuoteScalarFieldEnum]


  export const QuoteItemScalarFieldEnum: {
    id: 'id',
    orgId: 'orgId',
    quoteId: 'quoteId',
    parentId: 'parentId',
    rowType: 'rowType',
    title: 'title',
    description: 'description',
    sortOrder: 'sortOrder',
    roomTag: 'roomTag',
    tradeTag: 'tradeTag',
    phaseTag: 'phaseTag',
    calcType: 'calcType',
    qty: 'qty',
    unit: 'unit',
    unitPricePence: 'unitPricePence',
    hours: 'hours',
    hourlyRatePence: 'hourlyRatePence',
    sellPricePence: 'sellPricePence',
    isAllowance: 'isAllowance',
    costPence: 'costPence',
    markupPercentBps: 'markupPercentBps',
    createdByUserId: 'createdByUserId',
    updatedByUserId: 'updatedByUserId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type QuoteItemScalarFieldEnum = (typeof QuoteItemScalarFieldEnum)[keyof typeof QuoteItemScalarFieldEnum]


  export const QuoteVersionScalarFieldEnum: {
    id: 'id',
    orgId: 'orgId',
    quoteId: 'quoteId',
    version: 'version',
    status: 'status',
    vatMode: 'vatMode',
    vatRateBps: 'vatRateBps',
    depositType: 'depositType',
    depositAmountPence: 'depositAmountPence',
    depositPercentBps: 'depositPercentBps',
    showQtyToClient: 'showQtyToClient',
    showUnitRatesToClient: 'showUnitRatesToClient',
    title: 'title',
    referenceNo: 'referenceNo',
    projectAddress: 'projectAddress',
    scopeOverviewJson: 'scopeOverviewJson',
    termsJson: 'termsJson',
    paymentScheduleJson: 'paymentScheduleJson',
    subtotalPence: 'subtotalPence',
    vatPence: 'vatPence',
    totalPence: 'totalPence',
    sentAt: 'sentAt',
    createdByUserId: 'createdByUserId',
    createdAt: 'createdAt'
  };

  export type QuoteVersionScalarFieldEnum = (typeof QuoteVersionScalarFieldEnum)[keyof typeof QuoteVersionScalarFieldEnum]


  export const QuoteVersionItemScalarFieldEnum: {
    id: 'id',
    orgId: 'orgId',
    quoteVersionId: 'quoteVersionId',
    parentId: 'parentId',
    sourceQuoteItemId: 'sourceQuoteItemId',
    rowType: 'rowType',
    title: 'title',
    description: 'description',
    sortOrder: 'sortOrder',
    roomTag: 'roomTag',
    tradeTag: 'tradeTag',
    phaseTag: 'phaseTag',
    calcType: 'calcType',
    qty: 'qty',
    unit: 'unit',
    unitPricePence: 'unitPricePence',
    hours: 'hours',
    hourlyRatePence: 'hourlyRatePence',
    sellPricePence: 'sellPricePence',
    isAllowance: 'isAllowance',
    lineTotalPence: 'lineTotalPence',
    createdAt: 'createdAt'
  };

  export type QuoteVersionItemScalarFieldEnum = (typeof QuoteVersionItemScalarFieldEnum)[keyof typeof QuoteVersionItemScalarFieldEnum]


  export const QuotePublicLinkScalarFieldEnum: {
    id: 'id',
    orgId: 'orgId',
    quoteId: 'quoteId',
    tokenHash: 'tokenHash',
    tokenPrefix: 'tokenPrefix',
    isActive: 'isActive',
    expiresAt: 'expiresAt',
    revokedAt: 'revokedAt',
    firstViewedAt: 'firstViewedAt',
    lastViewedAt: 'lastViewedAt',
    viewCount: 'viewCount',
    createdByUserId: 'createdByUserId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type QuotePublicLinkScalarFieldEnum = (typeof QuotePublicLinkScalarFieldEnum)[keyof typeof QuotePublicLinkScalarFieldEnum]


  export const QuotePdfScalarFieldEnum: {
    id: 'id',
    orgId: 'orgId',
    quoteId: 'quoteId',
    version: 'version',
    fileUrl: 'fileUrl',
    createdAt: 'createdAt'
  };

  export type QuotePdfScalarFieldEnum = (typeof QuotePdfScalarFieldEnum)[keyof typeof QuotePdfScalarFieldEnum]


  export const QuoteAcceptanceScalarFieldEnum: {
    id: 'id',
    orgId: 'orgId',
    quoteId: 'quoteId',
    acceptedName: 'acceptedName',
    acceptedEmail: 'acceptedEmail',
    acceptedAt: 'acceptedAt',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    createdAt: 'createdAt'
  };

  export type QuoteAcceptanceScalarFieldEnum = (typeof QuoteAcceptanceScalarFieldEnum)[keyof typeof QuoteAcceptanceScalarFieldEnum]


  export const PriceBookItemScalarFieldEnum: {
    id: 'id',
    orgId: 'orgId',
    title: 'title',
    description: 'description',
    calcType: 'calcType',
    defaultQty: 'defaultQty',
    defaultUnit: 'defaultUnit',
    defaultUnitPricePence: 'defaultUnitPricePence',
    defaultHours: 'defaultHours',
    defaultHourlyRatePence: 'defaultHourlyRatePence',
    defaultSellPricePence: 'defaultSellPricePence',
    defaultIsAllowance: 'defaultIsAllowance',
    roomTag: 'roomTag',
    tradeTag: 'tradeTag',
    phaseTag: 'phaseTag',
    isFavorite: 'isFavorite',
    createdByUserId: 'createdByUserId',
    updatedByUserId: 'updatedByUserId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PriceBookItemScalarFieldEnum = (typeof PriceBookItemScalarFieldEnum)[keyof typeof PriceBookItemScalarFieldEnum]


  export const TemplateSectionScalarFieldEnum: {
    id: 'id',
    orgId: 'orgId',
    name: 'name',
    description: 'description',
    createdByUserId: 'createdByUserId',
    updatedByUserId: 'updatedByUserId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TemplateSectionScalarFieldEnum = (typeof TemplateSectionScalarFieldEnum)[keyof typeof TemplateSectionScalarFieldEnum]


  export const TemplateSectionItemScalarFieldEnum: {
    id: 'id',
    orgId: 'orgId',
    templateSectionId: 'templateSectionId',
    title: 'title',
    description: 'description',
    sortOrder: 'sortOrder',
    calcType: 'calcType',
    qty: 'qty',
    unit: 'unit',
    unitPricePence: 'unitPricePence',
    hours: 'hours',
    hourlyRatePence: 'hourlyRatePence',
    sellPricePence: 'sellPricePence',
    isAllowance: 'isAllowance',
    roomTag: 'roomTag',
    tradeTag: 'tradeTag',
    phaseTag: 'phaseTag',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TemplateSectionItemScalarFieldEnum = (typeof TemplateSectionItemScalarFieldEnum)[keyof typeof TemplateSectionItemScalarFieldEnum]


  export const VariationScalarFieldEnum: {
    id: 'id',
    orgId: 'orgId',
    quoteId: 'quoteId',
    number: 'number',
    title: 'title',
    description: 'description',
    status: 'status',
    sentAt: 'sentAt',
    approvedAt: 'approvedAt',
    vatMode: 'vatMode',
    vatRateBps: 'vatRateBps',
    createdByUserId: 'createdByUserId',
    updatedByUserId: 'updatedByUserId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VariationScalarFieldEnum = (typeof VariationScalarFieldEnum)[keyof typeof VariationScalarFieldEnum]


  export const VariationItemScalarFieldEnum: {
    id: 'id',
    orgId: 'orgId',
    variationId: 'variationId',
    parentId: 'parentId',
    rowType: 'rowType',
    title: 'title',
    description: 'description',
    sortOrder: 'sortOrder',
    calcType: 'calcType',
    qty: 'qty',
    unit: 'unit',
    unitPricePence: 'unitPricePence',
    hours: 'hours',
    hourlyRatePence: 'hourlyRatePence',
    sellPricePence: 'sellPricePence',
    isAllowance: 'isAllowance',
    roomTag: 'roomTag',
    tradeTag: 'tradeTag',
    phaseTag: 'phaseTag',
    costPence: 'costPence',
    markupPercentBps: 'markupPercentBps',
    createdByUserId: 'createdByUserId',
    updatedByUserId: 'updatedByUserId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VariationItemScalarFieldEnum = (typeof VariationItemScalarFieldEnum)[keyof typeof VariationItemScalarFieldEnum]


  export const VariationApprovalScalarFieldEnum: {
    id: 'id',
    orgId: 'orgId',
    variationId: 'variationId',
    approvedName: 'approvedName',
    approvedEmail: 'approvedEmail',
    approvedAt: 'approvedAt',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    createdAt: 'createdAt'
  };

  export type VariationApprovalScalarFieldEnum = (typeof VariationApprovalScalarFieldEnum)[keyof typeof VariationApprovalScalarFieldEnum]


  export const VariationPublicLinkScalarFieldEnum: {
    id: 'id',
    orgId: 'orgId',
    variationId: 'variationId',
    tokenHash: 'tokenHash',
    tokenPrefix: 'tokenPrefix',
    isActive: 'isActive',
    expiresAt: 'expiresAt',
    revokedAt: 'revokedAt',
    firstViewedAt: 'firstViewedAt',
    lastViewedAt: 'lastViewedAt',
    viewCount: 'viewCount',
    createdByUserId: 'createdByUserId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VariationPublicLinkScalarFieldEnum = (typeof VariationPublicLinkScalarFieldEnum)[keyof typeof VariationPublicLinkScalarFieldEnum]


  export const VariationPdfScalarFieldEnum: {
    id: 'id',
    orgId: 'orgId',
    variationId: 'variationId',
    stage: 'stage',
    fileUrl: 'fileUrl',
    createdAt: 'createdAt'
  };

  export type VariationPdfScalarFieldEnum = (typeof VariationPdfScalarFieldEnum)[keyof typeof VariationPdfScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'VatMode'
   */
  export type EnumVatModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VatMode'>
    


  /**
   * Reference to a field of type 'VatMode[]'
   */
  export type ListEnumVatModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VatMode[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'QuoteStatus'
   */
  export type EnumQuoteStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QuoteStatus'>
    


  /**
   * Reference to a field of type 'QuoteStatus[]'
   */
  export type ListEnumQuoteStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QuoteStatus[]'>
    


  /**
   * Reference to a field of type 'DepositType'
   */
  export type EnumDepositTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DepositType'>
    


  /**
   * Reference to a field of type 'DepositType[]'
   */
  export type ListEnumDepositTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DepositType[]'>
    


  /**
   * Reference to a field of type 'ItemRowType'
   */
  export type EnumItemRowTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ItemRowType'>
    


  /**
   * Reference to a field of type 'ItemRowType[]'
   */
  export type ListEnumItemRowTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ItemRowType[]'>
    


  /**
   * Reference to a field of type 'CalcType'
   */
  export type EnumCalcTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CalcType'>
    


  /**
   * Reference to a field of type 'CalcType[]'
   */
  export type ListEnumCalcTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CalcType[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'VariationStatus'
   */
  export type EnumVariationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VariationStatus'>
    


  /**
   * Reference to a field of type 'VariationStatus[]'
   */
  export type ListEnumVariationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VariationStatus[]'>
    


  /**
   * Reference to a field of type 'VariationPdfStage'
   */
  export type EnumVariationPdfStageFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VariationPdfStage'>
    


  /**
   * Reference to a field of type 'VariationPdfStage[]'
   */
  export type ListEnumVariationPdfStageFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VariationPdfStage[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type CompanySettingsWhereInput = {
    AND?: CompanySettingsWhereInput | CompanySettingsWhereInput[]
    OR?: CompanySettingsWhereInput[]
    NOT?: CompanySettingsWhereInput | CompanySettingsWhereInput[]
    id?: StringFilter<"CompanySettings"> | string
    orgId?: StringFilter<"CompanySettings"> | string
    companyName?: StringFilter<"CompanySettings"> | string
    logoUrl?: StringNullableFilter<"CompanySettings"> | string | null
    addressLine1?: StringNullableFilter<"CompanySettings"> | string | null
    addressLine2?: StringNullableFilter<"CompanySettings"> | string | null
    city?: StringNullableFilter<"CompanySettings"> | string | null
    postcode?: StringNullableFilter<"CompanySettings"> | string | null
    country?: StringNullableFilter<"CompanySettings"> | string | null
    phone?: StringNullableFilter<"CompanySettings"> | string | null
    email?: StringNullableFilter<"CompanySettings"> | string | null
    website?: StringNullableFilter<"CompanySettings"> | string | null
    defaultVatMode?: EnumVatModeFilter<"CompanySettings"> | $Enums.VatMode
    defaultVatRateBps?: IntFilter<"CompanySettings"> | number
    defaultGrouping?: StringFilter<"CompanySettings"> | string
    defaultShowQtyToClient?: BoolFilter<"CompanySettings"> | boolean
    defaultShowUnitRatesToClient?: BoolFilter<"CompanySettings"> | boolean
    defaultTermsJson?: JsonNullableFilter<"CompanySettings">
    defaultScopeOverviewJson?: JsonNullableFilter<"CompanySettings">
    createdByUserId?: StringNullableFilter<"CompanySettings"> | string | null
    updatedByUserId?: StringNullableFilter<"CompanySettings"> | string | null
    createdAt?: DateTimeFilter<"CompanySettings"> | Date | string
    updatedAt?: DateTimeFilter<"CompanySettings"> | Date | string
  }

  export type CompanySettingsOrderByWithRelationInput = {
    id?: SortOrder
    orgId?: SortOrder
    companyName?: SortOrder
    logoUrl?: SortOrderInput | SortOrder
    addressLine1?: SortOrderInput | SortOrder
    addressLine2?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    postcode?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    defaultVatMode?: SortOrder
    defaultVatRateBps?: SortOrder
    defaultGrouping?: SortOrder
    defaultShowQtyToClient?: SortOrder
    defaultShowUnitRatesToClient?: SortOrder
    defaultTermsJson?: SortOrderInput | SortOrder
    defaultScopeOverviewJson?: SortOrderInput | SortOrder
    createdByUserId?: SortOrderInput | SortOrder
    updatedByUserId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanySettingsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    orgId?: string
    AND?: CompanySettingsWhereInput | CompanySettingsWhereInput[]
    OR?: CompanySettingsWhereInput[]
    NOT?: CompanySettingsWhereInput | CompanySettingsWhereInput[]
    companyName?: StringFilter<"CompanySettings"> | string
    logoUrl?: StringNullableFilter<"CompanySettings"> | string | null
    addressLine1?: StringNullableFilter<"CompanySettings"> | string | null
    addressLine2?: StringNullableFilter<"CompanySettings"> | string | null
    city?: StringNullableFilter<"CompanySettings"> | string | null
    postcode?: StringNullableFilter<"CompanySettings"> | string | null
    country?: StringNullableFilter<"CompanySettings"> | string | null
    phone?: StringNullableFilter<"CompanySettings"> | string | null
    email?: StringNullableFilter<"CompanySettings"> | string | null
    website?: StringNullableFilter<"CompanySettings"> | string | null
    defaultVatMode?: EnumVatModeFilter<"CompanySettings"> | $Enums.VatMode
    defaultVatRateBps?: IntFilter<"CompanySettings"> | number
    defaultGrouping?: StringFilter<"CompanySettings"> | string
    defaultShowQtyToClient?: BoolFilter<"CompanySettings"> | boolean
    defaultShowUnitRatesToClient?: BoolFilter<"CompanySettings"> | boolean
    defaultTermsJson?: JsonNullableFilter<"CompanySettings">
    defaultScopeOverviewJson?: JsonNullableFilter<"CompanySettings">
    createdByUserId?: StringNullableFilter<"CompanySettings"> | string | null
    updatedByUserId?: StringNullableFilter<"CompanySettings"> | string | null
    createdAt?: DateTimeFilter<"CompanySettings"> | Date | string
    updatedAt?: DateTimeFilter<"CompanySettings"> | Date | string
  }, "id" | "orgId">

  export type CompanySettingsOrderByWithAggregationInput = {
    id?: SortOrder
    orgId?: SortOrder
    companyName?: SortOrder
    logoUrl?: SortOrderInput | SortOrder
    addressLine1?: SortOrderInput | SortOrder
    addressLine2?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    postcode?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    defaultVatMode?: SortOrder
    defaultVatRateBps?: SortOrder
    defaultGrouping?: SortOrder
    defaultShowQtyToClient?: SortOrder
    defaultShowUnitRatesToClient?: SortOrder
    defaultTermsJson?: SortOrderInput | SortOrder
    defaultScopeOverviewJson?: SortOrderInput | SortOrder
    createdByUserId?: SortOrderInput | SortOrder
    updatedByUserId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CompanySettingsCountOrderByAggregateInput
    _avg?: CompanySettingsAvgOrderByAggregateInput
    _max?: CompanySettingsMaxOrderByAggregateInput
    _min?: CompanySettingsMinOrderByAggregateInput
    _sum?: CompanySettingsSumOrderByAggregateInput
  }

  export type CompanySettingsScalarWhereWithAggregatesInput = {
    AND?: CompanySettingsScalarWhereWithAggregatesInput | CompanySettingsScalarWhereWithAggregatesInput[]
    OR?: CompanySettingsScalarWhereWithAggregatesInput[]
    NOT?: CompanySettingsScalarWhereWithAggregatesInput | CompanySettingsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CompanySettings"> | string
    orgId?: StringWithAggregatesFilter<"CompanySettings"> | string
    companyName?: StringWithAggregatesFilter<"CompanySettings"> | string
    logoUrl?: StringNullableWithAggregatesFilter<"CompanySettings"> | string | null
    addressLine1?: StringNullableWithAggregatesFilter<"CompanySettings"> | string | null
    addressLine2?: StringNullableWithAggregatesFilter<"CompanySettings"> | string | null
    city?: StringNullableWithAggregatesFilter<"CompanySettings"> | string | null
    postcode?: StringNullableWithAggregatesFilter<"CompanySettings"> | string | null
    country?: StringNullableWithAggregatesFilter<"CompanySettings"> | string | null
    phone?: StringNullableWithAggregatesFilter<"CompanySettings"> | string | null
    email?: StringNullableWithAggregatesFilter<"CompanySettings"> | string | null
    website?: StringNullableWithAggregatesFilter<"CompanySettings"> | string | null
    defaultVatMode?: EnumVatModeWithAggregatesFilter<"CompanySettings"> | $Enums.VatMode
    defaultVatRateBps?: IntWithAggregatesFilter<"CompanySettings"> | number
    defaultGrouping?: StringWithAggregatesFilter<"CompanySettings"> | string
    defaultShowQtyToClient?: BoolWithAggregatesFilter<"CompanySettings"> | boolean
    defaultShowUnitRatesToClient?: BoolWithAggregatesFilter<"CompanySettings"> | boolean
    defaultTermsJson?: JsonNullableWithAggregatesFilter<"CompanySettings">
    defaultScopeOverviewJson?: JsonNullableWithAggregatesFilter<"CompanySettings">
    createdByUserId?: StringNullableWithAggregatesFilter<"CompanySettings"> | string | null
    updatedByUserId?: StringNullableWithAggregatesFilter<"CompanySettings"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CompanySettings"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CompanySettings"> | Date | string
  }

  export type ClientWhereInput = {
    AND?: ClientWhereInput | ClientWhereInput[]
    OR?: ClientWhereInput[]
    NOT?: ClientWhereInput | ClientWhereInput[]
    id?: StringFilter<"Client"> | string
    orgId?: StringFilter<"Client"> | string
    name?: StringFilter<"Client"> | string
    email?: StringNullableFilter<"Client"> | string | null
    phone?: StringNullableFilter<"Client"> | string | null
    addressLine1?: StringNullableFilter<"Client"> | string | null
    addressLine2?: StringNullableFilter<"Client"> | string | null
    city?: StringNullableFilter<"Client"> | string | null
    postcode?: StringNullableFilter<"Client"> | string | null
    country?: StringNullableFilter<"Client"> | string | null
    notes?: StringNullableFilter<"Client"> | string | null
    createdByUserId?: StringNullableFilter<"Client"> | string | null
    updatedByUserId?: StringNullableFilter<"Client"> | string | null
    createdAt?: DateTimeFilter<"Client"> | Date | string
    updatedAt?: DateTimeFilter<"Client"> | Date | string
    quotes?: QuoteListRelationFilter
  }

  export type ClientOrderByWithRelationInput = {
    id?: SortOrder
    orgId?: SortOrder
    name?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    addressLine1?: SortOrderInput | SortOrder
    addressLine2?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    postcode?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdByUserId?: SortOrderInput | SortOrder
    updatedByUserId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    quotes?: QuoteOrderByRelationAggregateInput
  }

  export type ClientWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    id_orgId?: ClientIdOrgIdCompoundUniqueInput
    AND?: ClientWhereInput | ClientWhereInput[]
    OR?: ClientWhereInput[]
    NOT?: ClientWhereInput | ClientWhereInput[]
    orgId?: StringFilter<"Client"> | string
    name?: StringFilter<"Client"> | string
    email?: StringNullableFilter<"Client"> | string | null
    phone?: StringNullableFilter<"Client"> | string | null
    addressLine1?: StringNullableFilter<"Client"> | string | null
    addressLine2?: StringNullableFilter<"Client"> | string | null
    city?: StringNullableFilter<"Client"> | string | null
    postcode?: StringNullableFilter<"Client"> | string | null
    country?: StringNullableFilter<"Client"> | string | null
    notes?: StringNullableFilter<"Client"> | string | null
    createdByUserId?: StringNullableFilter<"Client"> | string | null
    updatedByUserId?: StringNullableFilter<"Client"> | string | null
    createdAt?: DateTimeFilter<"Client"> | Date | string
    updatedAt?: DateTimeFilter<"Client"> | Date | string
    quotes?: QuoteListRelationFilter
  }, "id" | "id_orgId">

  export type ClientOrderByWithAggregationInput = {
    id?: SortOrder
    orgId?: SortOrder
    name?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    addressLine1?: SortOrderInput | SortOrder
    addressLine2?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    postcode?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdByUserId?: SortOrderInput | SortOrder
    updatedByUserId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ClientCountOrderByAggregateInput
    _max?: ClientMaxOrderByAggregateInput
    _min?: ClientMinOrderByAggregateInput
  }

  export type ClientScalarWhereWithAggregatesInput = {
    AND?: ClientScalarWhereWithAggregatesInput | ClientScalarWhereWithAggregatesInput[]
    OR?: ClientScalarWhereWithAggregatesInput[]
    NOT?: ClientScalarWhereWithAggregatesInput | ClientScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Client"> | string
    orgId?: StringWithAggregatesFilter<"Client"> | string
    name?: StringWithAggregatesFilter<"Client"> | string
    email?: StringNullableWithAggregatesFilter<"Client"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Client"> | string | null
    addressLine1?: StringNullableWithAggregatesFilter<"Client"> | string | null
    addressLine2?: StringNullableWithAggregatesFilter<"Client"> | string | null
    city?: StringNullableWithAggregatesFilter<"Client"> | string | null
    postcode?: StringNullableWithAggregatesFilter<"Client"> | string | null
    country?: StringNullableWithAggregatesFilter<"Client"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Client"> | string | null
    createdByUserId?: StringNullableWithAggregatesFilter<"Client"> | string | null
    updatedByUserId?: StringNullableWithAggregatesFilter<"Client"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Client"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Client"> | Date | string
  }

  export type QuoteWhereInput = {
    AND?: QuoteWhereInput | QuoteWhereInput[]
    OR?: QuoteWhereInput[]
    NOT?: QuoteWhereInput | QuoteWhereInput[]
    id?: StringFilter<"Quote"> | string
    orgId?: StringFilter<"Quote"> | string
    clientId?: StringNullableFilter<"Quote"> | string | null
    title?: StringFilter<"Quote"> | string
    referenceNo?: StringNullableFilter<"Quote"> | string | null
    projectAddress?: StringNullableFilter<"Quote"> | string | null
    status?: EnumQuoteStatusFilter<"Quote"> | $Enums.QuoteStatus
    currentVersion?: IntFilter<"Quote"> | number
    sentAt?: DateTimeNullableFilter<"Quote"> | Date | string | null
    acceptedAt?: DateTimeNullableFilter<"Quote"> | Date | string | null
    vatMode?: EnumVatModeFilter<"Quote"> | $Enums.VatMode
    vatRateBps?: IntFilter<"Quote"> | number
    depositType?: EnumDepositTypeFilter<"Quote"> | $Enums.DepositType
    depositAmountPence?: IntNullableFilter<"Quote"> | number | null
    depositPercentBps?: IntNullableFilter<"Quote"> | number | null
    paymentScheduleJson?: JsonNullableFilter<"Quote">
    showQtyToClient?: BoolFilter<"Quote"> | boolean
    showUnitRatesToClient?: BoolFilter<"Quote"> | boolean
    scopeOverviewJson?: JsonNullableFilter<"Quote">
    termsJson?: JsonNullableFilter<"Quote">
    estimatedStartDate?: DateTimeNullableFilter<"Quote"> | Date | string | null
    estimatedDurationWeeks?: IntNullableFilter<"Quote"> | number | null
    createdByUserId?: StringNullableFilter<"Quote"> | string | null
    updatedByUserId?: StringNullableFilter<"Quote"> | string | null
    createdAt?: DateTimeFilter<"Quote"> | Date | string
    updatedAt?: DateTimeFilter<"Quote"> | Date | string
    client?: XOR<ClientNullableScalarRelationFilter, ClientWhereInput> | null
    items?: QuoteItemListRelationFilter
    publicLinks?: QuotePublicLinkListRelationFilter
    pdfs?: QuotePdfListRelationFilter
    acceptance?: XOR<QuoteAcceptanceNullableScalarRelationFilter, QuoteAcceptanceWhereInput> | null
    variations?: VariationListRelationFilter
    versions?: QuoteVersionListRelationFilter
  }

  export type QuoteOrderByWithRelationInput = {
    id?: SortOrder
    orgId?: SortOrder
    clientId?: SortOrderInput | SortOrder
    title?: SortOrder
    referenceNo?: SortOrderInput | SortOrder
    projectAddress?: SortOrderInput | SortOrder
    status?: SortOrder
    currentVersion?: SortOrder
    sentAt?: SortOrderInput | SortOrder
    acceptedAt?: SortOrderInput | SortOrder
    vatMode?: SortOrder
    vatRateBps?: SortOrder
    depositType?: SortOrder
    depositAmountPence?: SortOrderInput | SortOrder
    depositPercentBps?: SortOrderInput | SortOrder
    paymentScheduleJson?: SortOrderInput | SortOrder
    showQtyToClient?: SortOrder
    showUnitRatesToClient?: SortOrder
    scopeOverviewJson?: SortOrderInput | SortOrder
    termsJson?: SortOrderInput | SortOrder
    estimatedStartDate?: SortOrderInput | SortOrder
    estimatedDurationWeeks?: SortOrderInput | SortOrder
    createdByUserId?: SortOrderInput | SortOrder
    updatedByUserId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    client?: ClientOrderByWithRelationInput
    items?: QuoteItemOrderByRelationAggregateInput
    publicLinks?: QuotePublicLinkOrderByRelationAggregateInput
    pdfs?: QuotePdfOrderByRelationAggregateInput
    acceptance?: QuoteAcceptanceOrderByWithRelationInput
    variations?: VariationOrderByRelationAggregateInput
    versions?: QuoteVersionOrderByRelationAggregateInput
  }

  export type QuoteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    id_orgId?: QuoteIdOrgIdCompoundUniqueInput
    AND?: QuoteWhereInput | QuoteWhereInput[]
    OR?: QuoteWhereInput[]
    NOT?: QuoteWhereInput | QuoteWhereInput[]
    orgId?: StringFilter<"Quote"> | string
    clientId?: StringNullableFilter<"Quote"> | string | null
    title?: StringFilter<"Quote"> | string
    referenceNo?: StringNullableFilter<"Quote"> | string | null
    projectAddress?: StringNullableFilter<"Quote"> | string | null
    status?: EnumQuoteStatusFilter<"Quote"> | $Enums.QuoteStatus
    currentVersion?: IntFilter<"Quote"> | number
    sentAt?: DateTimeNullableFilter<"Quote"> | Date | string | null
    acceptedAt?: DateTimeNullableFilter<"Quote"> | Date | string | null
    vatMode?: EnumVatModeFilter<"Quote"> | $Enums.VatMode
    vatRateBps?: IntFilter<"Quote"> | number
    depositType?: EnumDepositTypeFilter<"Quote"> | $Enums.DepositType
    depositAmountPence?: IntNullableFilter<"Quote"> | number | null
    depositPercentBps?: IntNullableFilter<"Quote"> | number | null
    paymentScheduleJson?: JsonNullableFilter<"Quote">
    showQtyToClient?: BoolFilter<"Quote"> | boolean
    showUnitRatesToClient?: BoolFilter<"Quote"> | boolean
    scopeOverviewJson?: JsonNullableFilter<"Quote">
    termsJson?: JsonNullableFilter<"Quote">
    estimatedStartDate?: DateTimeNullableFilter<"Quote"> | Date | string | null
    estimatedDurationWeeks?: IntNullableFilter<"Quote"> | number | null
    createdByUserId?: StringNullableFilter<"Quote"> | string | null
    updatedByUserId?: StringNullableFilter<"Quote"> | string | null
    createdAt?: DateTimeFilter<"Quote"> | Date | string
    updatedAt?: DateTimeFilter<"Quote"> | Date | string
    client?: XOR<ClientNullableScalarRelationFilter, ClientWhereInput> | null
    items?: QuoteItemListRelationFilter
    publicLinks?: QuotePublicLinkListRelationFilter
    pdfs?: QuotePdfListRelationFilter
    acceptance?: XOR<QuoteAcceptanceNullableScalarRelationFilter, QuoteAcceptanceWhereInput> | null
    variations?: VariationListRelationFilter
    versions?: QuoteVersionListRelationFilter
  }, "id" | "id_orgId">

  export type QuoteOrderByWithAggregationInput = {
    id?: SortOrder
    orgId?: SortOrder
    clientId?: SortOrderInput | SortOrder
    title?: SortOrder
    referenceNo?: SortOrderInput | SortOrder
    projectAddress?: SortOrderInput | SortOrder
    status?: SortOrder
    currentVersion?: SortOrder
    sentAt?: SortOrderInput | SortOrder
    acceptedAt?: SortOrderInput | SortOrder
    vatMode?: SortOrder
    vatRateBps?: SortOrder
    depositType?: SortOrder
    depositAmountPence?: SortOrderInput | SortOrder
    depositPercentBps?: SortOrderInput | SortOrder
    paymentScheduleJson?: SortOrderInput | SortOrder
    showQtyToClient?: SortOrder
    showUnitRatesToClient?: SortOrder
    scopeOverviewJson?: SortOrderInput | SortOrder
    termsJson?: SortOrderInput | SortOrder
    estimatedStartDate?: SortOrderInput | SortOrder
    estimatedDurationWeeks?: SortOrderInput | SortOrder
    createdByUserId?: SortOrderInput | SortOrder
    updatedByUserId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: QuoteCountOrderByAggregateInput
    _avg?: QuoteAvgOrderByAggregateInput
    _max?: QuoteMaxOrderByAggregateInput
    _min?: QuoteMinOrderByAggregateInput
    _sum?: QuoteSumOrderByAggregateInput
  }

  export type QuoteScalarWhereWithAggregatesInput = {
    AND?: QuoteScalarWhereWithAggregatesInput | QuoteScalarWhereWithAggregatesInput[]
    OR?: QuoteScalarWhereWithAggregatesInput[]
    NOT?: QuoteScalarWhereWithAggregatesInput | QuoteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Quote"> | string
    orgId?: StringWithAggregatesFilter<"Quote"> | string
    clientId?: StringNullableWithAggregatesFilter<"Quote"> | string | null
    title?: StringWithAggregatesFilter<"Quote"> | string
    referenceNo?: StringNullableWithAggregatesFilter<"Quote"> | string | null
    projectAddress?: StringNullableWithAggregatesFilter<"Quote"> | string | null
    status?: EnumQuoteStatusWithAggregatesFilter<"Quote"> | $Enums.QuoteStatus
    currentVersion?: IntWithAggregatesFilter<"Quote"> | number
    sentAt?: DateTimeNullableWithAggregatesFilter<"Quote"> | Date | string | null
    acceptedAt?: DateTimeNullableWithAggregatesFilter<"Quote"> | Date | string | null
    vatMode?: EnumVatModeWithAggregatesFilter<"Quote"> | $Enums.VatMode
    vatRateBps?: IntWithAggregatesFilter<"Quote"> | number
    depositType?: EnumDepositTypeWithAggregatesFilter<"Quote"> | $Enums.DepositType
    depositAmountPence?: IntNullableWithAggregatesFilter<"Quote"> | number | null
    depositPercentBps?: IntNullableWithAggregatesFilter<"Quote"> | number | null
    paymentScheduleJson?: JsonNullableWithAggregatesFilter<"Quote">
    showQtyToClient?: BoolWithAggregatesFilter<"Quote"> | boolean
    showUnitRatesToClient?: BoolWithAggregatesFilter<"Quote"> | boolean
    scopeOverviewJson?: JsonNullableWithAggregatesFilter<"Quote">
    termsJson?: JsonNullableWithAggregatesFilter<"Quote">
    estimatedStartDate?: DateTimeNullableWithAggregatesFilter<"Quote"> | Date | string | null
    estimatedDurationWeeks?: IntNullableWithAggregatesFilter<"Quote"> | number | null
    createdByUserId?: StringNullableWithAggregatesFilter<"Quote"> | string | null
    updatedByUserId?: StringNullableWithAggregatesFilter<"Quote"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Quote"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Quote"> | Date | string
  }

  export type QuoteItemWhereInput = {
    AND?: QuoteItemWhereInput | QuoteItemWhereInput[]
    OR?: QuoteItemWhereInput[]
    NOT?: QuoteItemWhereInput | QuoteItemWhereInput[]
    id?: StringFilter<"QuoteItem"> | string
    orgId?: StringFilter<"QuoteItem"> | string
    quoteId?: StringFilter<"QuoteItem"> | string
    parentId?: StringNullableFilter<"QuoteItem"> | string | null
    rowType?: EnumItemRowTypeFilter<"QuoteItem"> | $Enums.ItemRowType
    title?: StringFilter<"QuoteItem"> | string
    description?: StringNullableFilter<"QuoteItem"> | string | null
    sortOrder?: IntFilter<"QuoteItem"> | number
    roomTag?: StringNullableFilter<"QuoteItem"> | string | null
    tradeTag?: StringNullableFilter<"QuoteItem"> | string | null
    phaseTag?: StringNullableFilter<"QuoteItem"> | string | null
    calcType?: EnumCalcTypeFilter<"QuoteItem"> | $Enums.CalcType
    qty?: DecimalNullableFilter<"QuoteItem"> | Decimal | DecimalJsLike | number | string | null
    unit?: StringNullableFilter<"QuoteItem"> | string | null
    unitPricePence?: IntNullableFilter<"QuoteItem"> | number | null
    hours?: DecimalNullableFilter<"QuoteItem"> | Decimal | DecimalJsLike | number | string | null
    hourlyRatePence?: IntNullableFilter<"QuoteItem"> | number | null
    sellPricePence?: IntNullableFilter<"QuoteItem"> | number | null
    isAllowance?: BoolFilter<"QuoteItem"> | boolean
    costPence?: IntNullableFilter<"QuoteItem"> | number | null
    markupPercentBps?: IntNullableFilter<"QuoteItem"> | number | null
    createdByUserId?: StringNullableFilter<"QuoteItem"> | string | null
    updatedByUserId?: StringNullableFilter<"QuoteItem"> | string | null
    createdAt?: DateTimeFilter<"QuoteItem"> | Date | string
    updatedAt?: DateTimeFilter<"QuoteItem"> | Date | string
    quote?: XOR<QuoteScalarRelationFilter, QuoteWhereInput>
    parent?: XOR<QuoteItemNullableScalarRelationFilter, QuoteItemWhereInput> | null
    children?: QuoteItemListRelationFilter
  }

  export type QuoteItemOrderByWithRelationInput = {
    id?: SortOrder
    orgId?: SortOrder
    quoteId?: SortOrder
    parentId?: SortOrderInput | SortOrder
    rowType?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    roomTag?: SortOrderInput | SortOrder
    tradeTag?: SortOrderInput | SortOrder
    phaseTag?: SortOrderInput | SortOrder
    calcType?: SortOrder
    qty?: SortOrderInput | SortOrder
    unit?: SortOrderInput | SortOrder
    unitPricePence?: SortOrderInput | SortOrder
    hours?: SortOrderInput | SortOrder
    hourlyRatePence?: SortOrderInput | SortOrder
    sellPricePence?: SortOrderInput | SortOrder
    isAllowance?: SortOrder
    costPence?: SortOrderInput | SortOrder
    markupPercentBps?: SortOrderInput | SortOrder
    createdByUserId?: SortOrderInput | SortOrder
    updatedByUserId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    quote?: QuoteOrderByWithRelationInput
    parent?: QuoteItemOrderByWithRelationInput
    children?: QuoteItemOrderByRelationAggregateInput
  }

  export type QuoteItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    id_orgId?: QuoteItemIdOrgIdCompoundUniqueInput
    AND?: QuoteItemWhereInput | QuoteItemWhereInput[]
    OR?: QuoteItemWhereInput[]
    NOT?: QuoteItemWhereInput | QuoteItemWhereInput[]
    orgId?: StringFilter<"QuoteItem"> | string
    quoteId?: StringFilter<"QuoteItem"> | string
    parentId?: StringNullableFilter<"QuoteItem"> | string | null
    rowType?: EnumItemRowTypeFilter<"QuoteItem"> | $Enums.ItemRowType
    title?: StringFilter<"QuoteItem"> | string
    description?: StringNullableFilter<"QuoteItem"> | string | null
    sortOrder?: IntFilter<"QuoteItem"> | number
    roomTag?: StringNullableFilter<"QuoteItem"> | string | null
    tradeTag?: StringNullableFilter<"QuoteItem"> | string | null
    phaseTag?: StringNullableFilter<"QuoteItem"> | string | null
    calcType?: EnumCalcTypeFilter<"QuoteItem"> | $Enums.CalcType
    qty?: DecimalNullableFilter<"QuoteItem"> | Decimal | DecimalJsLike | number | string | null
    unit?: StringNullableFilter<"QuoteItem"> | string | null
    unitPricePence?: IntNullableFilter<"QuoteItem"> | number | null
    hours?: DecimalNullableFilter<"QuoteItem"> | Decimal | DecimalJsLike | number | string | null
    hourlyRatePence?: IntNullableFilter<"QuoteItem"> | number | null
    sellPricePence?: IntNullableFilter<"QuoteItem"> | number | null
    isAllowance?: BoolFilter<"QuoteItem"> | boolean
    costPence?: IntNullableFilter<"QuoteItem"> | number | null
    markupPercentBps?: IntNullableFilter<"QuoteItem"> | number | null
    createdByUserId?: StringNullableFilter<"QuoteItem"> | string | null
    updatedByUserId?: StringNullableFilter<"QuoteItem"> | string | null
    createdAt?: DateTimeFilter<"QuoteItem"> | Date | string
    updatedAt?: DateTimeFilter<"QuoteItem"> | Date | string
    quote?: XOR<QuoteScalarRelationFilter, QuoteWhereInput>
    parent?: XOR<QuoteItemNullableScalarRelationFilter, QuoteItemWhereInput> | null
    children?: QuoteItemListRelationFilter
  }, "id" | "id_orgId">

  export type QuoteItemOrderByWithAggregationInput = {
    id?: SortOrder
    orgId?: SortOrder
    quoteId?: SortOrder
    parentId?: SortOrderInput | SortOrder
    rowType?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    roomTag?: SortOrderInput | SortOrder
    tradeTag?: SortOrderInput | SortOrder
    phaseTag?: SortOrderInput | SortOrder
    calcType?: SortOrder
    qty?: SortOrderInput | SortOrder
    unit?: SortOrderInput | SortOrder
    unitPricePence?: SortOrderInput | SortOrder
    hours?: SortOrderInput | SortOrder
    hourlyRatePence?: SortOrderInput | SortOrder
    sellPricePence?: SortOrderInput | SortOrder
    isAllowance?: SortOrder
    costPence?: SortOrderInput | SortOrder
    markupPercentBps?: SortOrderInput | SortOrder
    createdByUserId?: SortOrderInput | SortOrder
    updatedByUserId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: QuoteItemCountOrderByAggregateInput
    _avg?: QuoteItemAvgOrderByAggregateInput
    _max?: QuoteItemMaxOrderByAggregateInput
    _min?: QuoteItemMinOrderByAggregateInput
    _sum?: QuoteItemSumOrderByAggregateInput
  }

  export type QuoteItemScalarWhereWithAggregatesInput = {
    AND?: QuoteItemScalarWhereWithAggregatesInput | QuoteItemScalarWhereWithAggregatesInput[]
    OR?: QuoteItemScalarWhereWithAggregatesInput[]
    NOT?: QuoteItemScalarWhereWithAggregatesInput | QuoteItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"QuoteItem"> | string
    orgId?: StringWithAggregatesFilter<"QuoteItem"> | string
    quoteId?: StringWithAggregatesFilter<"QuoteItem"> | string
    parentId?: StringNullableWithAggregatesFilter<"QuoteItem"> | string | null
    rowType?: EnumItemRowTypeWithAggregatesFilter<"QuoteItem"> | $Enums.ItemRowType
    title?: StringWithAggregatesFilter<"QuoteItem"> | string
    description?: StringNullableWithAggregatesFilter<"QuoteItem"> | string | null
    sortOrder?: IntWithAggregatesFilter<"QuoteItem"> | number
    roomTag?: StringNullableWithAggregatesFilter<"QuoteItem"> | string | null
    tradeTag?: StringNullableWithAggregatesFilter<"QuoteItem"> | string | null
    phaseTag?: StringNullableWithAggregatesFilter<"QuoteItem"> | string | null
    calcType?: EnumCalcTypeWithAggregatesFilter<"QuoteItem"> | $Enums.CalcType
    qty?: DecimalNullableWithAggregatesFilter<"QuoteItem"> | Decimal | DecimalJsLike | number | string | null
    unit?: StringNullableWithAggregatesFilter<"QuoteItem"> | string | null
    unitPricePence?: IntNullableWithAggregatesFilter<"QuoteItem"> | number | null
    hours?: DecimalNullableWithAggregatesFilter<"QuoteItem"> | Decimal | DecimalJsLike | number | string | null
    hourlyRatePence?: IntNullableWithAggregatesFilter<"QuoteItem"> | number | null
    sellPricePence?: IntNullableWithAggregatesFilter<"QuoteItem"> | number | null
    isAllowance?: BoolWithAggregatesFilter<"QuoteItem"> | boolean
    costPence?: IntNullableWithAggregatesFilter<"QuoteItem"> | number | null
    markupPercentBps?: IntNullableWithAggregatesFilter<"QuoteItem"> | number | null
    createdByUserId?: StringNullableWithAggregatesFilter<"QuoteItem"> | string | null
    updatedByUserId?: StringNullableWithAggregatesFilter<"QuoteItem"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"QuoteItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"QuoteItem"> | Date | string
  }

  export type QuoteVersionWhereInput = {
    AND?: QuoteVersionWhereInput | QuoteVersionWhereInput[]
    OR?: QuoteVersionWhereInput[]
    NOT?: QuoteVersionWhereInput | QuoteVersionWhereInput[]
    id?: StringFilter<"QuoteVersion"> | string
    orgId?: StringFilter<"QuoteVersion"> | string
    quoteId?: StringFilter<"QuoteVersion"> | string
    version?: IntFilter<"QuoteVersion"> | number
    status?: EnumQuoteStatusFilter<"QuoteVersion"> | $Enums.QuoteStatus
    vatMode?: EnumVatModeFilter<"QuoteVersion"> | $Enums.VatMode
    vatRateBps?: IntFilter<"QuoteVersion"> | number
    depositType?: EnumDepositTypeFilter<"QuoteVersion"> | $Enums.DepositType
    depositAmountPence?: IntNullableFilter<"QuoteVersion"> | number | null
    depositPercentBps?: IntNullableFilter<"QuoteVersion"> | number | null
    showQtyToClient?: BoolFilter<"QuoteVersion"> | boolean
    showUnitRatesToClient?: BoolFilter<"QuoteVersion"> | boolean
    title?: StringFilter<"QuoteVersion"> | string
    referenceNo?: StringNullableFilter<"QuoteVersion"> | string | null
    projectAddress?: StringNullableFilter<"QuoteVersion"> | string | null
    scopeOverviewJson?: JsonNullableFilter<"QuoteVersion">
    termsJson?: JsonNullableFilter<"QuoteVersion">
    paymentScheduleJson?: JsonNullableFilter<"QuoteVersion">
    subtotalPence?: IntNullableFilter<"QuoteVersion"> | number | null
    vatPence?: IntNullableFilter<"QuoteVersion"> | number | null
    totalPence?: IntNullableFilter<"QuoteVersion"> | number | null
    sentAt?: DateTimeNullableFilter<"QuoteVersion"> | Date | string | null
    createdByUserId?: StringNullableFilter<"QuoteVersion"> | string | null
    createdAt?: DateTimeFilter<"QuoteVersion"> | Date | string
    quote?: XOR<QuoteScalarRelationFilter, QuoteWhereInput>
    items?: QuoteVersionItemListRelationFilter
  }

  export type QuoteVersionOrderByWithRelationInput = {
    id?: SortOrder
    orgId?: SortOrder
    quoteId?: SortOrder
    version?: SortOrder
    status?: SortOrder
    vatMode?: SortOrder
    vatRateBps?: SortOrder
    depositType?: SortOrder
    depositAmountPence?: SortOrderInput | SortOrder
    depositPercentBps?: SortOrderInput | SortOrder
    showQtyToClient?: SortOrder
    showUnitRatesToClient?: SortOrder
    title?: SortOrder
    referenceNo?: SortOrderInput | SortOrder
    projectAddress?: SortOrderInput | SortOrder
    scopeOverviewJson?: SortOrderInput | SortOrder
    termsJson?: SortOrderInput | SortOrder
    paymentScheduleJson?: SortOrderInput | SortOrder
    subtotalPence?: SortOrderInput | SortOrder
    vatPence?: SortOrderInput | SortOrder
    totalPence?: SortOrderInput | SortOrder
    sentAt?: SortOrderInput | SortOrder
    createdByUserId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    quote?: QuoteOrderByWithRelationInput
    items?: QuoteVersionItemOrderByRelationAggregateInput
  }

  export type QuoteVersionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    id_orgId?: QuoteVersionIdOrgIdCompoundUniqueInput
    quoteId_version?: QuoteVersionQuoteIdVersionCompoundUniqueInput
    AND?: QuoteVersionWhereInput | QuoteVersionWhereInput[]
    OR?: QuoteVersionWhereInput[]
    NOT?: QuoteVersionWhereInput | QuoteVersionWhereInput[]
    orgId?: StringFilter<"QuoteVersion"> | string
    quoteId?: StringFilter<"QuoteVersion"> | string
    version?: IntFilter<"QuoteVersion"> | number
    status?: EnumQuoteStatusFilter<"QuoteVersion"> | $Enums.QuoteStatus
    vatMode?: EnumVatModeFilter<"QuoteVersion"> | $Enums.VatMode
    vatRateBps?: IntFilter<"QuoteVersion"> | number
    depositType?: EnumDepositTypeFilter<"QuoteVersion"> | $Enums.DepositType
    depositAmountPence?: IntNullableFilter<"QuoteVersion"> | number | null
    depositPercentBps?: IntNullableFilter<"QuoteVersion"> | number | null
    showQtyToClient?: BoolFilter<"QuoteVersion"> | boolean
    showUnitRatesToClient?: BoolFilter<"QuoteVersion"> | boolean
    title?: StringFilter<"QuoteVersion"> | string
    referenceNo?: StringNullableFilter<"QuoteVersion"> | string | null
    projectAddress?: StringNullableFilter<"QuoteVersion"> | string | null
    scopeOverviewJson?: JsonNullableFilter<"QuoteVersion">
    termsJson?: JsonNullableFilter<"QuoteVersion">
    paymentScheduleJson?: JsonNullableFilter<"QuoteVersion">
    subtotalPence?: IntNullableFilter<"QuoteVersion"> | number | null
    vatPence?: IntNullableFilter<"QuoteVersion"> | number | null
    totalPence?: IntNullableFilter<"QuoteVersion"> | number | null
    sentAt?: DateTimeNullableFilter<"QuoteVersion"> | Date | string | null
    createdByUserId?: StringNullableFilter<"QuoteVersion"> | string | null
    createdAt?: DateTimeFilter<"QuoteVersion"> | Date | string
    quote?: XOR<QuoteScalarRelationFilter, QuoteWhereInput>
    items?: QuoteVersionItemListRelationFilter
  }, "id" | "id_orgId" | "quoteId_version">

  export type QuoteVersionOrderByWithAggregationInput = {
    id?: SortOrder
    orgId?: SortOrder
    quoteId?: SortOrder
    version?: SortOrder
    status?: SortOrder
    vatMode?: SortOrder
    vatRateBps?: SortOrder
    depositType?: SortOrder
    depositAmountPence?: SortOrderInput | SortOrder
    depositPercentBps?: SortOrderInput | SortOrder
    showQtyToClient?: SortOrder
    showUnitRatesToClient?: SortOrder
    title?: SortOrder
    referenceNo?: SortOrderInput | SortOrder
    projectAddress?: SortOrderInput | SortOrder
    scopeOverviewJson?: SortOrderInput | SortOrder
    termsJson?: SortOrderInput | SortOrder
    paymentScheduleJson?: SortOrderInput | SortOrder
    subtotalPence?: SortOrderInput | SortOrder
    vatPence?: SortOrderInput | SortOrder
    totalPence?: SortOrderInput | SortOrder
    sentAt?: SortOrderInput | SortOrder
    createdByUserId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: QuoteVersionCountOrderByAggregateInput
    _avg?: QuoteVersionAvgOrderByAggregateInput
    _max?: QuoteVersionMaxOrderByAggregateInput
    _min?: QuoteVersionMinOrderByAggregateInput
    _sum?: QuoteVersionSumOrderByAggregateInput
  }

  export type QuoteVersionScalarWhereWithAggregatesInput = {
    AND?: QuoteVersionScalarWhereWithAggregatesInput | QuoteVersionScalarWhereWithAggregatesInput[]
    OR?: QuoteVersionScalarWhereWithAggregatesInput[]
    NOT?: QuoteVersionScalarWhereWithAggregatesInput | QuoteVersionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"QuoteVersion"> | string
    orgId?: StringWithAggregatesFilter<"QuoteVersion"> | string
    quoteId?: StringWithAggregatesFilter<"QuoteVersion"> | string
    version?: IntWithAggregatesFilter<"QuoteVersion"> | number
    status?: EnumQuoteStatusWithAggregatesFilter<"QuoteVersion"> | $Enums.QuoteStatus
    vatMode?: EnumVatModeWithAggregatesFilter<"QuoteVersion"> | $Enums.VatMode
    vatRateBps?: IntWithAggregatesFilter<"QuoteVersion"> | number
    depositType?: EnumDepositTypeWithAggregatesFilter<"QuoteVersion"> | $Enums.DepositType
    depositAmountPence?: IntNullableWithAggregatesFilter<"QuoteVersion"> | number | null
    depositPercentBps?: IntNullableWithAggregatesFilter<"QuoteVersion"> | number | null
    showQtyToClient?: BoolWithAggregatesFilter<"QuoteVersion"> | boolean
    showUnitRatesToClient?: BoolWithAggregatesFilter<"QuoteVersion"> | boolean
    title?: StringWithAggregatesFilter<"QuoteVersion"> | string
    referenceNo?: StringNullableWithAggregatesFilter<"QuoteVersion"> | string | null
    projectAddress?: StringNullableWithAggregatesFilter<"QuoteVersion"> | string | null
    scopeOverviewJson?: JsonNullableWithAggregatesFilter<"QuoteVersion">
    termsJson?: JsonNullableWithAggregatesFilter<"QuoteVersion">
    paymentScheduleJson?: JsonNullableWithAggregatesFilter<"QuoteVersion">
    subtotalPence?: IntNullableWithAggregatesFilter<"QuoteVersion"> | number | null
    vatPence?: IntNullableWithAggregatesFilter<"QuoteVersion"> | number | null
    totalPence?: IntNullableWithAggregatesFilter<"QuoteVersion"> | number | null
    sentAt?: DateTimeNullableWithAggregatesFilter<"QuoteVersion"> | Date | string | null
    createdByUserId?: StringNullableWithAggregatesFilter<"QuoteVersion"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"QuoteVersion"> | Date | string
  }

  export type QuoteVersionItemWhereInput = {
    AND?: QuoteVersionItemWhereInput | QuoteVersionItemWhereInput[]
    OR?: QuoteVersionItemWhereInput[]
    NOT?: QuoteVersionItemWhereInput | QuoteVersionItemWhereInput[]
    id?: StringFilter<"QuoteVersionItem"> | string
    orgId?: StringFilter<"QuoteVersionItem"> | string
    quoteVersionId?: StringFilter<"QuoteVersionItem"> | string
    parentId?: StringNullableFilter<"QuoteVersionItem"> | string | null
    sourceQuoteItemId?: StringNullableFilter<"QuoteVersionItem"> | string | null
    rowType?: EnumItemRowTypeFilter<"QuoteVersionItem"> | $Enums.ItemRowType
    title?: StringFilter<"QuoteVersionItem"> | string
    description?: StringNullableFilter<"QuoteVersionItem"> | string | null
    sortOrder?: IntFilter<"QuoteVersionItem"> | number
    roomTag?: StringNullableFilter<"QuoteVersionItem"> | string | null
    tradeTag?: StringNullableFilter<"QuoteVersionItem"> | string | null
    phaseTag?: StringNullableFilter<"QuoteVersionItem"> | string | null
    calcType?: EnumCalcTypeFilter<"QuoteVersionItem"> | $Enums.CalcType
    qty?: DecimalNullableFilter<"QuoteVersionItem"> | Decimal | DecimalJsLike | number | string | null
    unit?: StringNullableFilter<"QuoteVersionItem"> | string | null
    unitPricePence?: IntNullableFilter<"QuoteVersionItem"> | number | null
    hours?: DecimalNullableFilter<"QuoteVersionItem"> | Decimal | DecimalJsLike | number | string | null
    hourlyRatePence?: IntNullableFilter<"QuoteVersionItem"> | number | null
    sellPricePence?: IntNullableFilter<"QuoteVersionItem"> | number | null
    isAllowance?: BoolFilter<"QuoteVersionItem"> | boolean
    lineTotalPence?: IntNullableFilter<"QuoteVersionItem"> | number | null
    createdAt?: DateTimeFilter<"QuoteVersionItem"> | Date | string
    quoteVersion?: XOR<QuoteVersionScalarRelationFilter, QuoteVersionWhereInput>
    parent?: XOR<QuoteVersionItemNullableScalarRelationFilter, QuoteVersionItemWhereInput> | null
    children?: QuoteVersionItemListRelationFilter
  }

  export type QuoteVersionItemOrderByWithRelationInput = {
    id?: SortOrder
    orgId?: SortOrder
    quoteVersionId?: SortOrder
    parentId?: SortOrderInput | SortOrder
    sourceQuoteItemId?: SortOrderInput | SortOrder
    rowType?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    roomTag?: SortOrderInput | SortOrder
    tradeTag?: SortOrderInput | SortOrder
    phaseTag?: SortOrderInput | SortOrder
    calcType?: SortOrder
    qty?: SortOrderInput | SortOrder
    unit?: SortOrderInput | SortOrder
    unitPricePence?: SortOrderInput | SortOrder
    hours?: SortOrderInput | SortOrder
    hourlyRatePence?: SortOrderInput | SortOrder
    sellPricePence?: SortOrderInput | SortOrder
    isAllowance?: SortOrder
    lineTotalPence?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    quoteVersion?: QuoteVersionOrderByWithRelationInput
    parent?: QuoteVersionItemOrderByWithRelationInput
    children?: QuoteVersionItemOrderByRelationAggregateInput
  }

  export type QuoteVersionItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    id_orgId?: QuoteVersionItemIdOrgIdCompoundUniqueInput
    AND?: QuoteVersionItemWhereInput | QuoteVersionItemWhereInput[]
    OR?: QuoteVersionItemWhereInput[]
    NOT?: QuoteVersionItemWhereInput | QuoteVersionItemWhereInput[]
    orgId?: StringFilter<"QuoteVersionItem"> | string
    quoteVersionId?: StringFilter<"QuoteVersionItem"> | string
    parentId?: StringNullableFilter<"QuoteVersionItem"> | string | null
    sourceQuoteItemId?: StringNullableFilter<"QuoteVersionItem"> | string | null
    rowType?: EnumItemRowTypeFilter<"QuoteVersionItem"> | $Enums.ItemRowType
    title?: StringFilter<"QuoteVersionItem"> | string
    description?: StringNullableFilter<"QuoteVersionItem"> | string | null
    sortOrder?: IntFilter<"QuoteVersionItem"> | number
    roomTag?: StringNullableFilter<"QuoteVersionItem"> | string | null
    tradeTag?: StringNullableFilter<"QuoteVersionItem"> | string | null
    phaseTag?: StringNullableFilter<"QuoteVersionItem"> | string | null
    calcType?: EnumCalcTypeFilter<"QuoteVersionItem"> | $Enums.CalcType
    qty?: DecimalNullableFilter<"QuoteVersionItem"> | Decimal | DecimalJsLike | number | string | null
    unit?: StringNullableFilter<"QuoteVersionItem"> | string | null
    unitPricePence?: IntNullableFilter<"QuoteVersionItem"> | number | null
    hours?: DecimalNullableFilter<"QuoteVersionItem"> | Decimal | DecimalJsLike | number | string | null
    hourlyRatePence?: IntNullableFilter<"QuoteVersionItem"> | number | null
    sellPricePence?: IntNullableFilter<"QuoteVersionItem"> | number | null
    isAllowance?: BoolFilter<"QuoteVersionItem"> | boolean
    lineTotalPence?: IntNullableFilter<"QuoteVersionItem"> | number | null
    createdAt?: DateTimeFilter<"QuoteVersionItem"> | Date | string
    quoteVersion?: XOR<QuoteVersionScalarRelationFilter, QuoteVersionWhereInput>
    parent?: XOR<QuoteVersionItemNullableScalarRelationFilter, QuoteVersionItemWhereInput> | null
    children?: QuoteVersionItemListRelationFilter
  }, "id" | "id_orgId">

  export type QuoteVersionItemOrderByWithAggregationInput = {
    id?: SortOrder
    orgId?: SortOrder
    quoteVersionId?: SortOrder
    parentId?: SortOrderInput | SortOrder
    sourceQuoteItemId?: SortOrderInput | SortOrder
    rowType?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    roomTag?: SortOrderInput | SortOrder
    tradeTag?: SortOrderInput | SortOrder
    phaseTag?: SortOrderInput | SortOrder
    calcType?: SortOrder
    qty?: SortOrderInput | SortOrder
    unit?: SortOrderInput | SortOrder
    unitPricePence?: SortOrderInput | SortOrder
    hours?: SortOrderInput | SortOrder
    hourlyRatePence?: SortOrderInput | SortOrder
    sellPricePence?: SortOrderInput | SortOrder
    isAllowance?: SortOrder
    lineTotalPence?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: QuoteVersionItemCountOrderByAggregateInput
    _avg?: QuoteVersionItemAvgOrderByAggregateInput
    _max?: QuoteVersionItemMaxOrderByAggregateInput
    _min?: QuoteVersionItemMinOrderByAggregateInput
    _sum?: QuoteVersionItemSumOrderByAggregateInput
  }

  export type QuoteVersionItemScalarWhereWithAggregatesInput = {
    AND?: QuoteVersionItemScalarWhereWithAggregatesInput | QuoteVersionItemScalarWhereWithAggregatesInput[]
    OR?: QuoteVersionItemScalarWhereWithAggregatesInput[]
    NOT?: QuoteVersionItemScalarWhereWithAggregatesInput | QuoteVersionItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"QuoteVersionItem"> | string
    orgId?: StringWithAggregatesFilter<"QuoteVersionItem"> | string
    quoteVersionId?: StringWithAggregatesFilter<"QuoteVersionItem"> | string
    parentId?: StringNullableWithAggregatesFilter<"QuoteVersionItem"> | string | null
    sourceQuoteItemId?: StringNullableWithAggregatesFilter<"QuoteVersionItem"> | string | null
    rowType?: EnumItemRowTypeWithAggregatesFilter<"QuoteVersionItem"> | $Enums.ItemRowType
    title?: StringWithAggregatesFilter<"QuoteVersionItem"> | string
    description?: StringNullableWithAggregatesFilter<"QuoteVersionItem"> | string | null
    sortOrder?: IntWithAggregatesFilter<"QuoteVersionItem"> | number
    roomTag?: StringNullableWithAggregatesFilter<"QuoteVersionItem"> | string | null
    tradeTag?: StringNullableWithAggregatesFilter<"QuoteVersionItem"> | string | null
    phaseTag?: StringNullableWithAggregatesFilter<"QuoteVersionItem"> | string | null
    calcType?: EnumCalcTypeWithAggregatesFilter<"QuoteVersionItem"> | $Enums.CalcType
    qty?: DecimalNullableWithAggregatesFilter<"QuoteVersionItem"> | Decimal | DecimalJsLike | number | string | null
    unit?: StringNullableWithAggregatesFilter<"QuoteVersionItem"> | string | null
    unitPricePence?: IntNullableWithAggregatesFilter<"QuoteVersionItem"> | number | null
    hours?: DecimalNullableWithAggregatesFilter<"QuoteVersionItem"> | Decimal | DecimalJsLike | number | string | null
    hourlyRatePence?: IntNullableWithAggregatesFilter<"QuoteVersionItem"> | number | null
    sellPricePence?: IntNullableWithAggregatesFilter<"QuoteVersionItem"> | number | null
    isAllowance?: BoolWithAggregatesFilter<"QuoteVersionItem"> | boolean
    lineTotalPence?: IntNullableWithAggregatesFilter<"QuoteVersionItem"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"QuoteVersionItem"> | Date | string
  }

  export type QuotePublicLinkWhereInput = {
    AND?: QuotePublicLinkWhereInput | QuotePublicLinkWhereInput[]
    OR?: QuotePublicLinkWhereInput[]
    NOT?: QuotePublicLinkWhereInput | QuotePublicLinkWhereInput[]
    id?: StringFilter<"QuotePublicLink"> | string
    orgId?: StringFilter<"QuotePublicLink"> | string
    quoteId?: StringFilter<"QuotePublicLink"> | string
    tokenHash?: StringFilter<"QuotePublicLink"> | string
    tokenPrefix?: StringNullableFilter<"QuotePublicLink"> | string | null
    isActive?: BoolFilter<"QuotePublicLink"> | boolean
    expiresAt?: DateTimeNullableFilter<"QuotePublicLink"> | Date | string | null
    revokedAt?: DateTimeNullableFilter<"QuotePublicLink"> | Date | string | null
    firstViewedAt?: DateTimeNullableFilter<"QuotePublicLink"> | Date | string | null
    lastViewedAt?: DateTimeNullableFilter<"QuotePublicLink"> | Date | string | null
    viewCount?: IntFilter<"QuotePublicLink"> | number
    createdByUserId?: StringNullableFilter<"QuotePublicLink"> | string | null
    createdAt?: DateTimeFilter<"QuotePublicLink"> | Date | string
    updatedAt?: DateTimeFilter<"QuotePublicLink"> | Date | string
    quote?: XOR<QuoteScalarRelationFilter, QuoteWhereInput>
  }

  export type QuotePublicLinkOrderByWithRelationInput = {
    id?: SortOrder
    orgId?: SortOrder
    quoteId?: SortOrder
    tokenHash?: SortOrder
    tokenPrefix?: SortOrderInput | SortOrder
    isActive?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    revokedAt?: SortOrderInput | SortOrder
    firstViewedAt?: SortOrderInput | SortOrder
    lastViewedAt?: SortOrderInput | SortOrder
    viewCount?: SortOrder
    createdByUserId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    quote?: QuoteOrderByWithRelationInput
  }

  export type QuotePublicLinkWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tokenHash?: string
    AND?: QuotePublicLinkWhereInput | QuotePublicLinkWhereInput[]
    OR?: QuotePublicLinkWhereInput[]
    NOT?: QuotePublicLinkWhereInput | QuotePublicLinkWhereInput[]
    orgId?: StringFilter<"QuotePublicLink"> | string
    quoteId?: StringFilter<"QuotePublicLink"> | string
    tokenPrefix?: StringNullableFilter<"QuotePublicLink"> | string | null
    isActive?: BoolFilter<"QuotePublicLink"> | boolean
    expiresAt?: DateTimeNullableFilter<"QuotePublicLink"> | Date | string | null
    revokedAt?: DateTimeNullableFilter<"QuotePublicLink"> | Date | string | null
    firstViewedAt?: DateTimeNullableFilter<"QuotePublicLink"> | Date | string | null
    lastViewedAt?: DateTimeNullableFilter<"QuotePublicLink"> | Date | string | null
    viewCount?: IntFilter<"QuotePublicLink"> | number
    createdByUserId?: StringNullableFilter<"QuotePublicLink"> | string | null
    createdAt?: DateTimeFilter<"QuotePublicLink"> | Date | string
    updatedAt?: DateTimeFilter<"QuotePublicLink"> | Date | string
    quote?: XOR<QuoteScalarRelationFilter, QuoteWhereInput>
  }, "id" | "tokenHash">

  export type QuotePublicLinkOrderByWithAggregationInput = {
    id?: SortOrder
    orgId?: SortOrder
    quoteId?: SortOrder
    tokenHash?: SortOrder
    tokenPrefix?: SortOrderInput | SortOrder
    isActive?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    revokedAt?: SortOrderInput | SortOrder
    firstViewedAt?: SortOrderInput | SortOrder
    lastViewedAt?: SortOrderInput | SortOrder
    viewCount?: SortOrder
    createdByUserId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: QuotePublicLinkCountOrderByAggregateInput
    _avg?: QuotePublicLinkAvgOrderByAggregateInput
    _max?: QuotePublicLinkMaxOrderByAggregateInput
    _min?: QuotePublicLinkMinOrderByAggregateInput
    _sum?: QuotePublicLinkSumOrderByAggregateInput
  }

  export type QuotePublicLinkScalarWhereWithAggregatesInput = {
    AND?: QuotePublicLinkScalarWhereWithAggregatesInput | QuotePublicLinkScalarWhereWithAggregatesInput[]
    OR?: QuotePublicLinkScalarWhereWithAggregatesInput[]
    NOT?: QuotePublicLinkScalarWhereWithAggregatesInput | QuotePublicLinkScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"QuotePublicLink"> | string
    orgId?: StringWithAggregatesFilter<"QuotePublicLink"> | string
    quoteId?: StringWithAggregatesFilter<"QuotePublicLink"> | string
    tokenHash?: StringWithAggregatesFilter<"QuotePublicLink"> | string
    tokenPrefix?: StringNullableWithAggregatesFilter<"QuotePublicLink"> | string | null
    isActive?: BoolWithAggregatesFilter<"QuotePublicLink"> | boolean
    expiresAt?: DateTimeNullableWithAggregatesFilter<"QuotePublicLink"> | Date | string | null
    revokedAt?: DateTimeNullableWithAggregatesFilter<"QuotePublicLink"> | Date | string | null
    firstViewedAt?: DateTimeNullableWithAggregatesFilter<"QuotePublicLink"> | Date | string | null
    lastViewedAt?: DateTimeNullableWithAggregatesFilter<"QuotePublicLink"> | Date | string | null
    viewCount?: IntWithAggregatesFilter<"QuotePublicLink"> | number
    createdByUserId?: StringNullableWithAggregatesFilter<"QuotePublicLink"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"QuotePublicLink"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"QuotePublicLink"> | Date | string
  }

  export type QuotePdfWhereInput = {
    AND?: QuotePdfWhereInput | QuotePdfWhereInput[]
    OR?: QuotePdfWhereInput[]
    NOT?: QuotePdfWhereInput | QuotePdfWhereInput[]
    id?: StringFilter<"QuotePdf"> | string
    orgId?: StringFilter<"QuotePdf"> | string
    quoteId?: StringFilter<"QuotePdf"> | string
    version?: IntFilter<"QuotePdf"> | number
    fileUrl?: StringFilter<"QuotePdf"> | string
    createdAt?: DateTimeFilter<"QuotePdf"> | Date | string
    quote?: XOR<QuoteScalarRelationFilter, QuoteWhereInput>
  }

  export type QuotePdfOrderByWithRelationInput = {
    id?: SortOrder
    orgId?: SortOrder
    quoteId?: SortOrder
    version?: SortOrder
    fileUrl?: SortOrder
    createdAt?: SortOrder
    quote?: QuoteOrderByWithRelationInput
  }

  export type QuotePdfWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    quoteId_version?: QuotePdfQuoteIdVersionCompoundUniqueInput
    AND?: QuotePdfWhereInput | QuotePdfWhereInput[]
    OR?: QuotePdfWhereInput[]
    NOT?: QuotePdfWhereInput | QuotePdfWhereInput[]
    orgId?: StringFilter<"QuotePdf"> | string
    quoteId?: StringFilter<"QuotePdf"> | string
    version?: IntFilter<"QuotePdf"> | number
    fileUrl?: StringFilter<"QuotePdf"> | string
    createdAt?: DateTimeFilter<"QuotePdf"> | Date | string
    quote?: XOR<QuoteScalarRelationFilter, QuoteWhereInput>
  }, "id" | "quoteId_version">

  export type QuotePdfOrderByWithAggregationInput = {
    id?: SortOrder
    orgId?: SortOrder
    quoteId?: SortOrder
    version?: SortOrder
    fileUrl?: SortOrder
    createdAt?: SortOrder
    _count?: QuotePdfCountOrderByAggregateInput
    _avg?: QuotePdfAvgOrderByAggregateInput
    _max?: QuotePdfMaxOrderByAggregateInput
    _min?: QuotePdfMinOrderByAggregateInput
    _sum?: QuotePdfSumOrderByAggregateInput
  }

  export type QuotePdfScalarWhereWithAggregatesInput = {
    AND?: QuotePdfScalarWhereWithAggregatesInput | QuotePdfScalarWhereWithAggregatesInput[]
    OR?: QuotePdfScalarWhereWithAggregatesInput[]
    NOT?: QuotePdfScalarWhereWithAggregatesInput | QuotePdfScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"QuotePdf"> | string
    orgId?: StringWithAggregatesFilter<"QuotePdf"> | string
    quoteId?: StringWithAggregatesFilter<"QuotePdf"> | string
    version?: IntWithAggregatesFilter<"QuotePdf"> | number
    fileUrl?: StringWithAggregatesFilter<"QuotePdf"> | string
    createdAt?: DateTimeWithAggregatesFilter<"QuotePdf"> | Date | string
  }

  export type QuoteAcceptanceWhereInput = {
    AND?: QuoteAcceptanceWhereInput | QuoteAcceptanceWhereInput[]
    OR?: QuoteAcceptanceWhereInput[]
    NOT?: QuoteAcceptanceWhereInput | QuoteAcceptanceWhereInput[]
    id?: StringFilter<"QuoteAcceptance"> | string
    orgId?: StringFilter<"QuoteAcceptance"> | string
    quoteId?: StringFilter<"QuoteAcceptance"> | string
    acceptedName?: StringFilter<"QuoteAcceptance"> | string
    acceptedEmail?: StringNullableFilter<"QuoteAcceptance"> | string | null
    acceptedAt?: DateTimeFilter<"QuoteAcceptance"> | Date | string
    ipAddress?: StringNullableFilter<"QuoteAcceptance"> | string | null
    userAgent?: StringNullableFilter<"QuoteAcceptance"> | string | null
    createdAt?: DateTimeFilter<"QuoteAcceptance"> | Date | string
    quote?: XOR<QuoteScalarRelationFilter, QuoteWhereInput>
  }

  export type QuoteAcceptanceOrderByWithRelationInput = {
    id?: SortOrder
    orgId?: SortOrder
    quoteId?: SortOrder
    acceptedName?: SortOrder
    acceptedEmail?: SortOrderInput | SortOrder
    acceptedAt?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    quote?: QuoteOrderByWithRelationInput
  }

  export type QuoteAcceptanceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    quoteId_orgId?: QuoteAcceptanceQuoteIdOrgIdCompoundUniqueInput
    AND?: QuoteAcceptanceWhereInput | QuoteAcceptanceWhereInput[]
    OR?: QuoteAcceptanceWhereInput[]
    NOT?: QuoteAcceptanceWhereInput | QuoteAcceptanceWhereInput[]
    orgId?: StringFilter<"QuoteAcceptance"> | string
    quoteId?: StringFilter<"QuoteAcceptance"> | string
    acceptedName?: StringFilter<"QuoteAcceptance"> | string
    acceptedEmail?: StringNullableFilter<"QuoteAcceptance"> | string | null
    acceptedAt?: DateTimeFilter<"QuoteAcceptance"> | Date | string
    ipAddress?: StringNullableFilter<"QuoteAcceptance"> | string | null
    userAgent?: StringNullableFilter<"QuoteAcceptance"> | string | null
    createdAt?: DateTimeFilter<"QuoteAcceptance"> | Date | string
    quote?: XOR<QuoteScalarRelationFilter, QuoteWhereInput>
  }, "id" | "quoteId_orgId">

  export type QuoteAcceptanceOrderByWithAggregationInput = {
    id?: SortOrder
    orgId?: SortOrder
    quoteId?: SortOrder
    acceptedName?: SortOrder
    acceptedEmail?: SortOrderInput | SortOrder
    acceptedAt?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: QuoteAcceptanceCountOrderByAggregateInput
    _max?: QuoteAcceptanceMaxOrderByAggregateInput
    _min?: QuoteAcceptanceMinOrderByAggregateInput
  }

  export type QuoteAcceptanceScalarWhereWithAggregatesInput = {
    AND?: QuoteAcceptanceScalarWhereWithAggregatesInput | QuoteAcceptanceScalarWhereWithAggregatesInput[]
    OR?: QuoteAcceptanceScalarWhereWithAggregatesInput[]
    NOT?: QuoteAcceptanceScalarWhereWithAggregatesInput | QuoteAcceptanceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"QuoteAcceptance"> | string
    orgId?: StringWithAggregatesFilter<"QuoteAcceptance"> | string
    quoteId?: StringWithAggregatesFilter<"QuoteAcceptance"> | string
    acceptedName?: StringWithAggregatesFilter<"QuoteAcceptance"> | string
    acceptedEmail?: StringNullableWithAggregatesFilter<"QuoteAcceptance"> | string | null
    acceptedAt?: DateTimeWithAggregatesFilter<"QuoteAcceptance"> | Date | string
    ipAddress?: StringNullableWithAggregatesFilter<"QuoteAcceptance"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"QuoteAcceptance"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"QuoteAcceptance"> | Date | string
  }

  export type PriceBookItemWhereInput = {
    AND?: PriceBookItemWhereInput | PriceBookItemWhereInput[]
    OR?: PriceBookItemWhereInput[]
    NOT?: PriceBookItemWhereInput | PriceBookItemWhereInput[]
    id?: StringFilter<"PriceBookItem"> | string
    orgId?: StringFilter<"PriceBookItem"> | string
    title?: StringFilter<"PriceBookItem"> | string
    description?: StringNullableFilter<"PriceBookItem"> | string | null
    calcType?: EnumCalcTypeFilter<"PriceBookItem"> | $Enums.CalcType
    defaultQty?: DecimalNullableFilter<"PriceBookItem"> | Decimal | DecimalJsLike | number | string | null
    defaultUnit?: StringNullableFilter<"PriceBookItem"> | string | null
    defaultUnitPricePence?: IntNullableFilter<"PriceBookItem"> | number | null
    defaultHours?: DecimalNullableFilter<"PriceBookItem"> | Decimal | DecimalJsLike | number | string | null
    defaultHourlyRatePence?: IntNullableFilter<"PriceBookItem"> | number | null
    defaultSellPricePence?: IntNullableFilter<"PriceBookItem"> | number | null
    defaultIsAllowance?: BoolFilter<"PriceBookItem"> | boolean
    roomTag?: StringNullableFilter<"PriceBookItem"> | string | null
    tradeTag?: StringNullableFilter<"PriceBookItem"> | string | null
    phaseTag?: StringNullableFilter<"PriceBookItem"> | string | null
    isFavorite?: BoolFilter<"PriceBookItem"> | boolean
    createdByUserId?: StringNullableFilter<"PriceBookItem"> | string | null
    updatedByUserId?: StringNullableFilter<"PriceBookItem"> | string | null
    createdAt?: DateTimeFilter<"PriceBookItem"> | Date | string
    updatedAt?: DateTimeFilter<"PriceBookItem"> | Date | string
  }

  export type PriceBookItemOrderByWithRelationInput = {
    id?: SortOrder
    orgId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    calcType?: SortOrder
    defaultQty?: SortOrderInput | SortOrder
    defaultUnit?: SortOrderInput | SortOrder
    defaultUnitPricePence?: SortOrderInput | SortOrder
    defaultHours?: SortOrderInput | SortOrder
    defaultHourlyRatePence?: SortOrderInput | SortOrder
    defaultSellPricePence?: SortOrderInput | SortOrder
    defaultIsAllowance?: SortOrder
    roomTag?: SortOrderInput | SortOrder
    tradeTag?: SortOrderInput | SortOrder
    phaseTag?: SortOrderInput | SortOrder
    isFavorite?: SortOrder
    createdByUserId?: SortOrderInput | SortOrder
    updatedByUserId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PriceBookItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PriceBookItemWhereInput | PriceBookItemWhereInput[]
    OR?: PriceBookItemWhereInput[]
    NOT?: PriceBookItemWhereInput | PriceBookItemWhereInput[]
    orgId?: StringFilter<"PriceBookItem"> | string
    title?: StringFilter<"PriceBookItem"> | string
    description?: StringNullableFilter<"PriceBookItem"> | string | null
    calcType?: EnumCalcTypeFilter<"PriceBookItem"> | $Enums.CalcType
    defaultQty?: DecimalNullableFilter<"PriceBookItem"> | Decimal | DecimalJsLike | number | string | null
    defaultUnit?: StringNullableFilter<"PriceBookItem"> | string | null
    defaultUnitPricePence?: IntNullableFilter<"PriceBookItem"> | number | null
    defaultHours?: DecimalNullableFilter<"PriceBookItem"> | Decimal | DecimalJsLike | number | string | null
    defaultHourlyRatePence?: IntNullableFilter<"PriceBookItem"> | number | null
    defaultSellPricePence?: IntNullableFilter<"PriceBookItem"> | number | null
    defaultIsAllowance?: BoolFilter<"PriceBookItem"> | boolean
    roomTag?: StringNullableFilter<"PriceBookItem"> | string | null
    tradeTag?: StringNullableFilter<"PriceBookItem"> | string | null
    phaseTag?: StringNullableFilter<"PriceBookItem"> | string | null
    isFavorite?: BoolFilter<"PriceBookItem"> | boolean
    createdByUserId?: StringNullableFilter<"PriceBookItem"> | string | null
    updatedByUserId?: StringNullableFilter<"PriceBookItem"> | string | null
    createdAt?: DateTimeFilter<"PriceBookItem"> | Date | string
    updatedAt?: DateTimeFilter<"PriceBookItem"> | Date | string
  }, "id">

  export type PriceBookItemOrderByWithAggregationInput = {
    id?: SortOrder
    orgId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    calcType?: SortOrder
    defaultQty?: SortOrderInput | SortOrder
    defaultUnit?: SortOrderInput | SortOrder
    defaultUnitPricePence?: SortOrderInput | SortOrder
    defaultHours?: SortOrderInput | SortOrder
    defaultHourlyRatePence?: SortOrderInput | SortOrder
    defaultSellPricePence?: SortOrderInput | SortOrder
    defaultIsAllowance?: SortOrder
    roomTag?: SortOrderInput | SortOrder
    tradeTag?: SortOrderInput | SortOrder
    phaseTag?: SortOrderInput | SortOrder
    isFavorite?: SortOrder
    createdByUserId?: SortOrderInput | SortOrder
    updatedByUserId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PriceBookItemCountOrderByAggregateInput
    _avg?: PriceBookItemAvgOrderByAggregateInput
    _max?: PriceBookItemMaxOrderByAggregateInput
    _min?: PriceBookItemMinOrderByAggregateInput
    _sum?: PriceBookItemSumOrderByAggregateInput
  }

  export type PriceBookItemScalarWhereWithAggregatesInput = {
    AND?: PriceBookItemScalarWhereWithAggregatesInput | PriceBookItemScalarWhereWithAggregatesInput[]
    OR?: PriceBookItemScalarWhereWithAggregatesInput[]
    NOT?: PriceBookItemScalarWhereWithAggregatesInput | PriceBookItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PriceBookItem"> | string
    orgId?: StringWithAggregatesFilter<"PriceBookItem"> | string
    title?: StringWithAggregatesFilter<"PriceBookItem"> | string
    description?: StringNullableWithAggregatesFilter<"PriceBookItem"> | string | null
    calcType?: EnumCalcTypeWithAggregatesFilter<"PriceBookItem"> | $Enums.CalcType
    defaultQty?: DecimalNullableWithAggregatesFilter<"PriceBookItem"> | Decimal | DecimalJsLike | number | string | null
    defaultUnit?: StringNullableWithAggregatesFilter<"PriceBookItem"> | string | null
    defaultUnitPricePence?: IntNullableWithAggregatesFilter<"PriceBookItem"> | number | null
    defaultHours?: DecimalNullableWithAggregatesFilter<"PriceBookItem"> | Decimal | DecimalJsLike | number | string | null
    defaultHourlyRatePence?: IntNullableWithAggregatesFilter<"PriceBookItem"> | number | null
    defaultSellPricePence?: IntNullableWithAggregatesFilter<"PriceBookItem"> | number | null
    defaultIsAllowance?: BoolWithAggregatesFilter<"PriceBookItem"> | boolean
    roomTag?: StringNullableWithAggregatesFilter<"PriceBookItem"> | string | null
    tradeTag?: StringNullableWithAggregatesFilter<"PriceBookItem"> | string | null
    phaseTag?: StringNullableWithAggregatesFilter<"PriceBookItem"> | string | null
    isFavorite?: BoolWithAggregatesFilter<"PriceBookItem"> | boolean
    createdByUserId?: StringNullableWithAggregatesFilter<"PriceBookItem"> | string | null
    updatedByUserId?: StringNullableWithAggregatesFilter<"PriceBookItem"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PriceBookItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PriceBookItem"> | Date | string
  }

  export type TemplateSectionWhereInput = {
    AND?: TemplateSectionWhereInput | TemplateSectionWhereInput[]
    OR?: TemplateSectionWhereInput[]
    NOT?: TemplateSectionWhereInput | TemplateSectionWhereInput[]
    id?: StringFilter<"TemplateSection"> | string
    orgId?: StringFilter<"TemplateSection"> | string
    name?: StringFilter<"TemplateSection"> | string
    description?: StringNullableFilter<"TemplateSection"> | string | null
    createdByUserId?: StringNullableFilter<"TemplateSection"> | string | null
    updatedByUserId?: StringNullableFilter<"TemplateSection"> | string | null
    createdAt?: DateTimeFilter<"TemplateSection"> | Date | string
    updatedAt?: DateTimeFilter<"TemplateSection"> | Date | string
    items?: TemplateSectionItemListRelationFilter
  }

  export type TemplateSectionOrderByWithRelationInput = {
    id?: SortOrder
    orgId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdByUserId?: SortOrderInput | SortOrder
    updatedByUserId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    items?: TemplateSectionItemOrderByRelationAggregateInput
  }

  export type TemplateSectionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    id_orgId?: TemplateSectionIdOrgIdCompoundUniqueInput
    AND?: TemplateSectionWhereInput | TemplateSectionWhereInput[]
    OR?: TemplateSectionWhereInput[]
    NOT?: TemplateSectionWhereInput | TemplateSectionWhereInput[]
    orgId?: StringFilter<"TemplateSection"> | string
    name?: StringFilter<"TemplateSection"> | string
    description?: StringNullableFilter<"TemplateSection"> | string | null
    createdByUserId?: StringNullableFilter<"TemplateSection"> | string | null
    updatedByUserId?: StringNullableFilter<"TemplateSection"> | string | null
    createdAt?: DateTimeFilter<"TemplateSection"> | Date | string
    updatedAt?: DateTimeFilter<"TemplateSection"> | Date | string
    items?: TemplateSectionItemListRelationFilter
  }, "id" | "id_orgId">

  export type TemplateSectionOrderByWithAggregationInput = {
    id?: SortOrder
    orgId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdByUserId?: SortOrderInput | SortOrder
    updatedByUserId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TemplateSectionCountOrderByAggregateInput
    _max?: TemplateSectionMaxOrderByAggregateInput
    _min?: TemplateSectionMinOrderByAggregateInput
  }

  export type TemplateSectionScalarWhereWithAggregatesInput = {
    AND?: TemplateSectionScalarWhereWithAggregatesInput | TemplateSectionScalarWhereWithAggregatesInput[]
    OR?: TemplateSectionScalarWhereWithAggregatesInput[]
    NOT?: TemplateSectionScalarWhereWithAggregatesInput | TemplateSectionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TemplateSection"> | string
    orgId?: StringWithAggregatesFilter<"TemplateSection"> | string
    name?: StringWithAggregatesFilter<"TemplateSection"> | string
    description?: StringNullableWithAggregatesFilter<"TemplateSection"> | string | null
    createdByUserId?: StringNullableWithAggregatesFilter<"TemplateSection"> | string | null
    updatedByUserId?: StringNullableWithAggregatesFilter<"TemplateSection"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TemplateSection"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TemplateSection"> | Date | string
  }

  export type TemplateSectionItemWhereInput = {
    AND?: TemplateSectionItemWhereInput | TemplateSectionItemWhereInput[]
    OR?: TemplateSectionItemWhereInput[]
    NOT?: TemplateSectionItemWhereInput | TemplateSectionItemWhereInput[]
    id?: StringFilter<"TemplateSectionItem"> | string
    orgId?: StringFilter<"TemplateSectionItem"> | string
    templateSectionId?: StringFilter<"TemplateSectionItem"> | string
    title?: StringFilter<"TemplateSectionItem"> | string
    description?: StringNullableFilter<"TemplateSectionItem"> | string | null
    sortOrder?: IntFilter<"TemplateSectionItem"> | number
    calcType?: EnumCalcTypeFilter<"TemplateSectionItem"> | $Enums.CalcType
    qty?: DecimalNullableFilter<"TemplateSectionItem"> | Decimal | DecimalJsLike | number | string | null
    unit?: StringNullableFilter<"TemplateSectionItem"> | string | null
    unitPricePence?: IntNullableFilter<"TemplateSectionItem"> | number | null
    hours?: DecimalNullableFilter<"TemplateSectionItem"> | Decimal | DecimalJsLike | number | string | null
    hourlyRatePence?: IntNullableFilter<"TemplateSectionItem"> | number | null
    sellPricePence?: IntNullableFilter<"TemplateSectionItem"> | number | null
    isAllowance?: BoolFilter<"TemplateSectionItem"> | boolean
    roomTag?: StringNullableFilter<"TemplateSectionItem"> | string | null
    tradeTag?: StringNullableFilter<"TemplateSectionItem"> | string | null
    phaseTag?: StringNullableFilter<"TemplateSectionItem"> | string | null
    createdAt?: DateTimeFilter<"TemplateSectionItem"> | Date | string
    updatedAt?: DateTimeFilter<"TemplateSectionItem"> | Date | string
    templateSection?: XOR<TemplateSectionScalarRelationFilter, TemplateSectionWhereInput>
  }

  export type TemplateSectionItemOrderByWithRelationInput = {
    id?: SortOrder
    orgId?: SortOrder
    templateSectionId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    calcType?: SortOrder
    qty?: SortOrderInput | SortOrder
    unit?: SortOrderInput | SortOrder
    unitPricePence?: SortOrderInput | SortOrder
    hours?: SortOrderInput | SortOrder
    hourlyRatePence?: SortOrderInput | SortOrder
    sellPricePence?: SortOrderInput | SortOrder
    isAllowance?: SortOrder
    roomTag?: SortOrderInput | SortOrder
    tradeTag?: SortOrderInput | SortOrder
    phaseTag?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    templateSection?: TemplateSectionOrderByWithRelationInput
  }

  export type TemplateSectionItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TemplateSectionItemWhereInput | TemplateSectionItemWhereInput[]
    OR?: TemplateSectionItemWhereInput[]
    NOT?: TemplateSectionItemWhereInput | TemplateSectionItemWhereInput[]
    orgId?: StringFilter<"TemplateSectionItem"> | string
    templateSectionId?: StringFilter<"TemplateSectionItem"> | string
    title?: StringFilter<"TemplateSectionItem"> | string
    description?: StringNullableFilter<"TemplateSectionItem"> | string | null
    sortOrder?: IntFilter<"TemplateSectionItem"> | number
    calcType?: EnumCalcTypeFilter<"TemplateSectionItem"> | $Enums.CalcType
    qty?: DecimalNullableFilter<"TemplateSectionItem"> | Decimal | DecimalJsLike | number | string | null
    unit?: StringNullableFilter<"TemplateSectionItem"> | string | null
    unitPricePence?: IntNullableFilter<"TemplateSectionItem"> | number | null
    hours?: DecimalNullableFilter<"TemplateSectionItem"> | Decimal | DecimalJsLike | number | string | null
    hourlyRatePence?: IntNullableFilter<"TemplateSectionItem"> | number | null
    sellPricePence?: IntNullableFilter<"TemplateSectionItem"> | number | null
    isAllowance?: BoolFilter<"TemplateSectionItem"> | boolean
    roomTag?: StringNullableFilter<"TemplateSectionItem"> | string | null
    tradeTag?: StringNullableFilter<"TemplateSectionItem"> | string | null
    phaseTag?: StringNullableFilter<"TemplateSectionItem"> | string | null
    createdAt?: DateTimeFilter<"TemplateSectionItem"> | Date | string
    updatedAt?: DateTimeFilter<"TemplateSectionItem"> | Date | string
    templateSection?: XOR<TemplateSectionScalarRelationFilter, TemplateSectionWhereInput>
  }, "id">

  export type TemplateSectionItemOrderByWithAggregationInput = {
    id?: SortOrder
    orgId?: SortOrder
    templateSectionId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    calcType?: SortOrder
    qty?: SortOrderInput | SortOrder
    unit?: SortOrderInput | SortOrder
    unitPricePence?: SortOrderInput | SortOrder
    hours?: SortOrderInput | SortOrder
    hourlyRatePence?: SortOrderInput | SortOrder
    sellPricePence?: SortOrderInput | SortOrder
    isAllowance?: SortOrder
    roomTag?: SortOrderInput | SortOrder
    tradeTag?: SortOrderInput | SortOrder
    phaseTag?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TemplateSectionItemCountOrderByAggregateInput
    _avg?: TemplateSectionItemAvgOrderByAggregateInput
    _max?: TemplateSectionItemMaxOrderByAggregateInput
    _min?: TemplateSectionItemMinOrderByAggregateInput
    _sum?: TemplateSectionItemSumOrderByAggregateInput
  }

  export type TemplateSectionItemScalarWhereWithAggregatesInput = {
    AND?: TemplateSectionItemScalarWhereWithAggregatesInput | TemplateSectionItemScalarWhereWithAggregatesInput[]
    OR?: TemplateSectionItemScalarWhereWithAggregatesInput[]
    NOT?: TemplateSectionItemScalarWhereWithAggregatesInput | TemplateSectionItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TemplateSectionItem"> | string
    orgId?: StringWithAggregatesFilter<"TemplateSectionItem"> | string
    templateSectionId?: StringWithAggregatesFilter<"TemplateSectionItem"> | string
    title?: StringWithAggregatesFilter<"TemplateSectionItem"> | string
    description?: StringNullableWithAggregatesFilter<"TemplateSectionItem"> | string | null
    sortOrder?: IntWithAggregatesFilter<"TemplateSectionItem"> | number
    calcType?: EnumCalcTypeWithAggregatesFilter<"TemplateSectionItem"> | $Enums.CalcType
    qty?: DecimalNullableWithAggregatesFilter<"TemplateSectionItem"> | Decimal | DecimalJsLike | number | string | null
    unit?: StringNullableWithAggregatesFilter<"TemplateSectionItem"> | string | null
    unitPricePence?: IntNullableWithAggregatesFilter<"TemplateSectionItem"> | number | null
    hours?: DecimalNullableWithAggregatesFilter<"TemplateSectionItem"> | Decimal | DecimalJsLike | number | string | null
    hourlyRatePence?: IntNullableWithAggregatesFilter<"TemplateSectionItem"> | number | null
    sellPricePence?: IntNullableWithAggregatesFilter<"TemplateSectionItem"> | number | null
    isAllowance?: BoolWithAggregatesFilter<"TemplateSectionItem"> | boolean
    roomTag?: StringNullableWithAggregatesFilter<"TemplateSectionItem"> | string | null
    tradeTag?: StringNullableWithAggregatesFilter<"TemplateSectionItem"> | string | null
    phaseTag?: StringNullableWithAggregatesFilter<"TemplateSectionItem"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TemplateSectionItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TemplateSectionItem"> | Date | string
  }

  export type VariationWhereInput = {
    AND?: VariationWhereInput | VariationWhereInput[]
    OR?: VariationWhereInput[]
    NOT?: VariationWhereInput | VariationWhereInput[]
    id?: StringFilter<"Variation"> | string
    orgId?: StringFilter<"Variation"> | string
    quoteId?: StringFilter<"Variation"> | string
    number?: IntFilter<"Variation"> | number
    title?: StringFilter<"Variation"> | string
    description?: StringNullableFilter<"Variation"> | string | null
    status?: EnumVariationStatusFilter<"Variation"> | $Enums.VariationStatus
    sentAt?: DateTimeNullableFilter<"Variation"> | Date | string | null
    approvedAt?: DateTimeNullableFilter<"Variation"> | Date | string | null
    vatMode?: EnumVatModeFilter<"Variation"> | $Enums.VatMode
    vatRateBps?: IntFilter<"Variation"> | number
    createdByUserId?: StringNullableFilter<"Variation"> | string | null
    updatedByUserId?: StringNullableFilter<"Variation"> | string | null
    createdAt?: DateTimeFilter<"Variation"> | Date | string
    updatedAt?: DateTimeFilter<"Variation"> | Date | string
    quote?: XOR<QuoteScalarRelationFilter, QuoteWhereInput>
    publicLinks?: VariationPublicLinkListRelationFilter
    items?: VariationItemListRelationFilter
    approval?: XOR<VariationApprovalNullableScalarRelationFilter, VariationApprovalWhereInput> | null
    pdfs?: VariationPdfListRelationFilter
  }

  export type VariationOrderByWithRelationInput = {
    id?: SortOrder
    orgId?: SortOrder
    quoteId?: SortOrder
    number?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    sentAt?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    vatMode?: SortOrder
    vatRateBps?: SortOrder
    createdByUserId?: SortOrderInput | SortOrder
    updatedByUserId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    quote?: QuoteOrderByWithRelationInput
    publicLinks?: VariationPublicLinkOrderByRelationAggregateInput
    items?: VariationItemOrderByRelationAggregateInput
    approval?: VariationApprovalOrderByWithRelationInput
    pdfs?: VariationPdfOrderByRelationAggregateInput
  }

  export type VariationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    id_orgId?: VariationIdOrgIdCompoundUniqueInput
    quoteId_number?: VariationQuoteIdNumberCompoundUniqueInput
    AND?: VariationWhereInput | VariationWhereInput[]
    OR?: VariationWhereInput[]
    NOT?: VariationWhereInput | VariationWhereInput[]
    orgId?: StringFilter<"Variation"> | string
    quoteId?: StringFilter<"Variation"> | string
    number?: IntFilter<"Variation"> | number
    title?: StringFilter<"Variation"> | string
    description?: StringNullableFilter<"Variation"> | string | null
    status?: EnumVariationStatusFilter<"Variation"> | $Enums.VariationStatus
    sentAt?: DateTimeNullableFilter<"Variation"> | Date | string | null
    approvedAt?: DateTimeNullableFilter<"Variation"> | Date | string | null
    vatMode?: EnumVatModeFilter<"Variation"> | $Enums.VatMode
    vatRateBps?: IntFilter<"Variation"> | number
    createdByUserId?: StringNullableFilter<"Variation"> | string | null
    updatedByUserId?: StringNullableFilter<"Variation"> | string | null
    createdAt?: DateTimeFilter<"Variation"> | Date | string
    updatedAt?: DateTimeFilter<"Variation"> | Date | string
    quote?: XOR<QuoteScalarRelationFilter, QuoteWhereInput>
    publicLinks?: VariationPublicLinkListRelationFilter
    items?: VariationItemListRelationFilter
    approval?: XOR<VariationApprovalNullableScalarRelationFilter, VariationApprovalWhereInput> | null
    pdfs?: VariationPdfListRelationFilter
  }, "id" | "id_orgId" | "quoteId_number">

  export type VariationOrderByWithAggregationInput = {
    id?: SortOrder
    orgId?: SortOrder
    quoteId?: SortOrder
    number?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    sentAt?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    vatMode?: SortOrder
    vatRateBps?: SortOrder
    createdByUserId?: SortOrderInput | SortOrder
    updatedByUserId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VariationCountOrderByAggregateInput
    _avg?: VariationAvgOrderByAggregateInput
    _max?: VariationMaxOrderByAggregateInput
    _min?: VariationMinOrderByAggregateInput
    _sum?: VariationSumOrderByAggregateInput
  }

  export type VariationScalarWhereWithAggregatesInput = {
    AND?: VariationScalarWhereWithAggregatesInput | VariationScalarWhereWithAggregatesInput[]
    OR?: VariationScalarWhereWithAggregatesInput[]
    NOT?: VariationScalarWhereWithAggregatesInput | VariationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Variation"> | string
    orgId?: StringWithAggregatesFilter<"Variation"> | string
    quoteId?: StringWithAggregatesFilter<"Variation"> | string
    number?: IntWithAggregatesFilter<"Variation"> | number
    title?: StringWithAggregatesFilter<"Variation"> | string
    description?: StringNullableWithAggregatesFilter<"Variation"> | string | null
    status?: EnumVariationStatusWithAggregatesFilter<"Variation"> | $Enums.VariationStatus
    sentAt?: DateTimeNullableWithAggregatesFilter<"Variation"> | Date | string | null
    approvedAt?: DateTimeNullableWithAggregatesFilter<"Variation"> | Date | string | null
    vatMode?: EnumVatModeWithAggregatesFilter<"Variation"> | $Enums.VatMode
    vatRateBps?: IntWithAggregatesFilter<"Variation"> | number
    createdByUserId?: StringNullableWithAggregatesFilter<"Variation"> | string | null
    updatedByUserId?: StringNullableWithAggregatesFilter<"Variation"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Variation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Variation"> | Date | string
  }

  export type VariationItemWhereInput = {
    AND?: VariationItemWhereInput | VariationItemWhereInput[]
    OR?: VariationItemWhereInput[]
    NOT?: VariationItemWhereInput | VariationItemWhereInput[]
    id?: StringFilter<"VariationItem"> | string
    orgId?: StringFilter<"VariationItem"> | string
    variationId?: StringFilter<"VariationItem"> | string
    parentId?: StringNullableFilter<"VariationItem"> | string | null
    rowType?: EnumItemRowTypeFilter<"VariationItem"> | $Enums.ItemRowType
    title?: StringFilter<"VariationItem"> | string
    description?: StringNullableFilter<"VariationItem"> | string | null
    sortOrder?: IntFilter<"VariationItem"> | number
    calcType?: EnumCalcTypeFilter<"VariationItem"> | $Enums.CalcType
    qty?: DecimalNullableFilter<"VariationItem"> | Decimal | DecimalJsLike | number | string | null
    unit?: StringNullableFilter<"VariationItem"> | string | null
    unitPricePence?: IntNullableFilter<"VariationItem"> | number | null
    hours?: DecimalNullableFilter<"VariationItem"> | Decimal | DecimalJsLike | number | string | null
    hourlyRatePence?: IntNullableFilter<"VariationItem"> | number | null
    sellPricePence?: IntNullableFilter<"VariationItem"> | number | null
    isAllowance?: BoolFilter<"VariationItem"> | boolean
    roomTag?: StringNullableFilter<"VariationItem"> | string | null
    tradeTag?: StringNullableFilter<"VariationItem"> | string | null
    phaseTag?: StringNullableFilter<"VariationItem"> | string | null
    costPence?: IntNullableFilter<"VariationItem"> | number | null
    markupPercentBps?: IntNullableFilter<"VariationItem"> | number | null
    createdByUserId?: StringNullableFilter<"VariationItem"> | string | null
    updatedByUserId?: StringNullableFilter<"VariationItem"> | string | null
    createdAt?: DateTimeFilter<"VariationItem"> | Date | string
    updatedAt?: DateTimeFilter<"VariationItem"> | Date | string
    variation?: XOR<VariationScalarRelationFilter, VariationWhereInput>
    parent?: XOR<VariationItemNullableScalarRelationFilter, VariationItemWhereInput> | null
    children?: VariationItemListRelationFilter
  }

  export type VariationItemOrderByWithRelationInput = {
    id?: SortOrder
    orgId?: SortOrder
    variationId?: SortOrder
    parentId?: SortOrderInput | SortOrder
    rowType?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    calcType?: SortOrder
    qty?: SortOrderInput | SortOrder
    unit?: SortOrderInput | SortOrder
    unitPricePence?: SortOrderInput | SortOrder
    hours?: SortOrderInput | SortOrder
    hourlyRatePence?: SortOrderInput | SortOrder
    sellPricePence?: SortOrderInput | SortOrder
    isAllowance?: SortOrder
    roomTag?: SortOrderInput | SortOrder
    tradeTag?: SortOrderInput | SortOrder
    phaseTag?: SortOrderInput | SortOrder
    costPence?: SortOrderInput | SortOrder
    markupPercentBps?: SortOrderInput | SortOrder
    createdByUserId?: SortOrderInput | SortOrder
    updatedByUserId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    variation?: VariationOrderByWithRelationInput
    parent?: VariationItemOrderByWithRelationInput
    children?: VariationItemOrderByRelationAggregateInput
  }

  export type VariationItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    id_orgId?: VariationItemIdOrgIdCompoundUniqueInput
    AND?: VariationItemWhereInput | VariationItemWhereInput[]
    OR?: VariationItemWhereInput[]
    NOT?: VariationItemWhereInput | VariationItemWhereInput[]
    orgId?: StringFilter<"VariationItem"> | string
    variationId?: StringFilter<"VariationItem"> | string
    parentId?: StringNullableFilter<"VariationItem"> | string | null
    rowType?: EnumItemRowTypeFilter<"VariationItem"> | $Enums.ItemRowType
    title?: StringFilter<"VariationItem"> | string
    description?: StringNullableFilter<"VariationItem"> | string | null
    sortOrder?: IntFilter<"VariationItem"> | number
    calcType?: EnumCalcTypeFilter<"VariationItem"> | $Enums.CalcType
    qty?: DecimalNullableFilter<"VariationItem"> | Decimal | DecimalJsLike | number | string | null
    unit?: StringNullableFilter<"VariationItem"> | string | null
    unitPricePence?: IntNullableFilter<"VariationItem"> | number | null
    hours?: DecimalNullableFilter<"VariationItem"> | Decimal | DecimalJsLike | number | string | null
    hourlyRatePence?: IntNullableFilter<"VariationItem"> | number | null
    sellPricePence?: IntNullableFilter<"VariationItem"> | number | null
    isAllowance?: BoolFilter<"VariationItem"> | boolean
    roomTag?: StringNullableFilter<"VariationItem"> | string | null
    tradeTag?: StringNullableFilter<"VariationItem"> | string | null
    phaseTag?: StringNullableFilter<"VariationItem"> | string | null
    costPence?: IntNullableFilter<"VariationItem"> | number | null
    markupPercentBps?: IntNullableFilter<"VariationItem"> | number | null
    createdByUserId?: StringNullableFilter<"VariationItem"> | string | null
    updatedByUserId?: StringNullableFilter<"VariationItem"> | string | null
    createdAt?: DateTimeFilter<"VariationItem"> | Date | string
    updatedAt?: DateTimeFilter<"VariationItem"> | Date | string
    variation?: XOR<VariationScalarRelationFilter, VariationWhereInput>
    parent?: XOR<VariationItemNullableScalarRelationFilter, VariationItemWhereInput> | null
    children?: VariationItemListRelationFilter
  }, "id" | "id_orgId">

  export type VariationItemOrderByWithAggregationInput = {
    id?: SortOrder
    orgId?: SortOrder
    variationId?: SortOrder
    parentId?: SortOrderInput | SortOrder
    rowType?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    calcType?: SortOrder
    qty?: SortOrderInput | SortOrder
    unit?: SortOrderInput | SortOrder
    unitPricePence?: SortOrderInput | SortOrder
    hours?: SortOrderInput | SortOrder
    hourlyRatePence?: SortOrderInput | SortOrder
    sellPricePence?: SortOrderInput | SortOrder
    isAllowance?: SortOrder
    roomTag?: SortOrderInput | SortOrder
    tradeTag?: SortOrderInput | SortOrder
    phaseTag?: SortOrderInput | SortOrder
    costPence?: SortOrderInput | SortOrder
    markupPercentBps?: SortOrderInput | SortOrder
    createdByUserId?: SortOrderInput | SortOrder
    updatedByUserId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VariationItemCountOrderByAggregateInput
    _avg?: VariationItemAvgOrderByAggregateInput
    _max?: VariationItemMaxOrderByAggregateInput
    _min?: VariationItemMinOrderByAggregateInput
    _sum?: VariationItemSumOrderByAggregateInput
  }

  export type VariationItemScalarWhereWithAggregatesInput = {
    AND?: VariationItemScalarWhereWithAggregatesInput | VariationItemScalarWhereWithAggregatesInput[]
    OR?: VariationItemScalarWhereWithAggregatesInput[]
    NOT?: VariationItemScalarWhereWithAggregatesInput | VariationItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VariationItem"> | string
    orgId?: StringWithAggregatesFilter<"VariationItem"> | string
    variationId?: StringWithAggregatesFilter<"VariationItem"> | string
    parentId?: StringNullableWithAggregatesFilter<"VariationItem"> | string | null
    rowType?: EnumItemRowTypeWithAggregatesFilter<"VariationItem"> | $Enums.ItemRowType
    title?: StringWithAggregatesFilter<"VariationItem"> | string
    description?: StringNullableWithAggregatesFilter<"VariationItem"> | string | null
    sortOrder?: IntWithAggregatesFilter<"VariationItem"> | number
    calcType?: EnumCalcTypeWithAggregatesFilter<"VariationItem"> | $Enums.CalcType
    qty?: DecimalNullableWithAggregatesFilter<"VariationItem"> | Decimal | DecimalJsLike | number | string | null
    unit?: StringNullableWithAggregatesFilter<"VariationItem"> | string | null
    unitPricePence?: IntNullableWithAggregatesFilter<"VariationItem"> | number | null
    hours?: DecimalNullableWithAggregatesFilter<"VariationItem"> | Decimal | DecimalJsLike | number | string | null
    hourlyRatePence?: IntNullableWithAggregatesFilter<"VariationItem"> | number | null
    sellPricePence?: IntNullableWithAggregatesFilter<"VariationItem"> | number | null
    isAllowance?: BoolWithAggregatesFilter<"VariationItem"> | boolean
    roomTag?: StringNullableWithAggregatesFilter<"VariationItem"> | string | null
    tradeTag?: StringNullableWithAggregatesFilter<"VariationItem"> | string | null
    phaseTag?: StringNullableWithAggregatesFilter<"VariationItem"> | string | null
    costPence?: IntNullableWithAggregatesFilter<"VariationItem"> | number | null
    markupPercentBps?: IntNullableWithAggregatesFilter<"VariationItem"> | number | null
    createdByUserId?: StringNullableWithAggregatesFilter<"VariationItem"> | string | null
    updatedByUserId?: StringNullableWithAggregatesFilter<"VariationItem"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"VariationItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"VariationItem"> | Date | string
  }

  export type VariationApprovalWhereInput = {
    AND?: VariationApprovalWhereInput | VariationApprovalWhereInput[]
    OR?: VariationApprovalWhereInput[]
    NOT?: VariationApprovalWhereInput | VariationApprovalWhereInput[]
    id?: StringFilter<"VariationApproval"> | string
    orgId?: StringFilter<"VariationApproval"> | string
    variationId?: StringFilter<"VariationApproval"> | string
    approvedName?: StringFilter<"VariationApproval"> | string
    approvedEmail?: StringNullableFilter<"VariationApproval"> | string | null
    approvedAt?: DateTimeFilter<"VariationApproval"> | Date | string
    ipAddress?: StringNullableFilter<"VariationApproval"> | string | null
    userAgent?: StringNullableFilter<"VariationApproval"> | string | null
    createdAt?: DateTimeFilter<"VariationApproval"> | Date | string
    variation?: XOR<VariationScalarRelationFilter, VariationWhereInput>
  }

  export type VariationApprovalOrderByWithRelationInput = {
    id?: SortOrder
    orgId?: SortOrder
    variationId?: SortOrder
    approvedName?: SortOrder
    approvedEmail?: SortOrderInput | SortOrder
    approvedAt?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    variation?: VariationOrderByWithRelationInput
  }

  export type VariationApprovalWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    variationId_orgId?: VariationApprovalVariationIdOrgIdCompoundUniqueInput
    AND?: VariationApprovalWhereInput | VariationApprovalWhereInput[]
    OR?: VariationApprovalWhereInput[]
    NOT?: VariationApprovalWhereInput | VariationApprovalWhereInput[]
    orgId?: StringFilter<"VariationApproval"> | string
    variationId?: StringFilter<"VariationApproval"> | string
    approvedName?: StringFilter<"VariationApproval"> | string
    approvedEmail?: StringNullableFilter<"VariationApproval"> | string | null
    approvedAt?: DateTimeFilter<"VariationApproval"> | Date | string
    ipAddress?: StringNullableFilter<"VariationApproval"> | string | null
    userAgent?: StringNullableFilter<"VariationApproval"> | string | null
    createdAt?: DateTimeFilter<"VariationApproval"> | Date | string
    variation?: XOR<VariationScalarRelationFilter, VariationWhereInput>
  }, "id" | "variationId_orgId">

  export type VariationApprovalOrderByWithAggregationInput = {
    id?: SortOrder
    orgId?: SortOrder
    variationId?: SortOrder
    approvedName?: SortOrder
    approvedEmail?: SortOrderInput | SortOrder
    approvedAt?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: VariationApprovalCountOrderByAggregateInput
    _max?: VariationApprovalMaxOrderByAggregateInput
    _min?: VariationApprovalMinOrderByAggregateInput
  }

  export type VariationApprovalScalarWhereWithAggregatesInput = {
    AND?: VariationApprovalScalarWhereWithAggregatesInput | VariationApprovalScalarWhereWithAggregatesInput[]
    OR?: VariationApprovalScalarWhereWithAggregatesInput[]
    NOT?: VariationApprovalScalarWhereWithAggregatesInput | VariationApprovalScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VariationApproval"> | string
    orgId?: StringWithAggregatesFilter<"VariationApproval"> | string
    variationId?: StringWithAggregatesFilter<"VariationApproval"> | string
    approvedName?: StringWithAggregatesFilter<"VariationApproval"> | string
    approvedEmail?: StringNullableWithAggregatesFilter<"VariationApproval"> | string | null
    approvedAt?: DateTimeWithAggregatesFilter<"VariationApproval"> | Date | string
    ipAddress?: StringNullableWithAggregatesFilter<"VariationApproval"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"VariationApproval"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"VariationApproval"> | Date | string
  }

  export type VariationPublicLinkWhereInput = {
    AND?: VariationPublicLinkWhereInput | VariationPublicLinkWhereInput[]
    OR?: VariationPublicLinkWhereInput[]
    NOT?: VariationPublicLinkWhereInput | VariationPublicLinkWhereInput[]
    id?: StringFilter<"VariationPublicLink"> | string
    orgId?: StringFilter<"VariationPublicLink"> | string
    variationId?: StringFilter<"VariationPublicLink"> | string
    tokenHash?: StringFilter<"VariationPublicLink"> | string
    tokenPrefix?: StringNullableFilter<"VariationPublicLink"> | string | null
    isActive?: BoolFilter<"VariationPublicLink"> | boolean
    expiresAt?: DateTimeNullableFilter<"VariationPublicLink"> | Date | string | null
    revokedAt?: DateTimeNullableFilter<"VariationPublicLink"> | Date | string | null
    firstViewedAt?: DateTimeNullableFilter<"VariationPublicLink"> | Date | string | null
    lastViewedAt?: DateTimeNullableFilter<"VariationPublicLink"> | Date | string | null
    viewCount?: IntFilter<"VariationPublicLink"> | number
    createdByUserId?: StringNullableFilter<"VariationPublicLink"> | string | null
    createdAt?: DateTimeFilter<"VariationPublicLink"> | Date | string
    updatedAt?: DateTimeFilter<"VariationPublicLink"> | Date | string
    variation?: XOR<VariationScalarRelationFilter, VariationWhereInput>
  }

  export type VariationPublicLinkOrderByWithRelationInput = {
    id?: SortOrder
    orgId?: SortOrder
    variationId?: SortOrder
    tokenHash?: SortOrder
    tokenPrefix?: SortOrderInput | SortOrder
    isActive?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    revokedAt?: SortOrderInput | SortOrder
    firstViewedAt?: SortOrderInput | SortOrder
    lastViewedAt?: SortOrderInput | SortOrder
    viewCount?: SortOrder
    createdByUserId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    variation?: VariationOrderByWithRelationInput
  }

  export type VariationPublicLinkWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tokenHash?: string
    AND?: VariationPublicLinkWhereInput | VariationPublicLinkWhereInput[]
    OR?: VariationPublicLinkWhereInput[]
    NOT?: VariationPublicLinkWhereInput | VariationPublicLinkWhereInput[]
    orgId?: StringFilter<"VariationPublicLink"> | string
    variationId?: StringFilter<"VariationPublicLink"> | string
    tokenPrefix?: StringNullableFilter<"VariationPublicLink"> | string | null
    isActive?: BoolFilter<"VariationPublicLink"> | boolean
    expiresAt?: DateTimeNullableFilter<"VariationPublicLink"> | Date | string | null
    revokedAt?: DateTimeNullableFilter<"VariationPublicLink"> | Date | string | null
    firstViewedAt?: DateTimeNullableFilter<"VariationPublicLink"> | Date | string | null
    lastViewedAt?: DateTimeNullableFilter<"VariationPublicLink"> | Date | string | null
    viewCount?: IntFilter<"VariationPublicLink"> | number
    createdByUserId?: StringNullableFilter<"VariationPublicLink"> | string | null
    createdAt?: DateTimeFilter<"VariationPublicLink"> | Date | string
    updatedAt?: DateTimeFilter<"VariationPublicLink"> | Date | string
    variation?: XOR<VariationScalarRelationFilter, VariationWhereInput>
  }, "id" | "tokenHash">

  export type VariationPublicLinkOrderByWithAggregationInput = {
    id?: SortOrder
    orgId?: SortOrder
    variationId?: SortOrder
    tokenHash?: SortOrder
    tokenPrefix?: SortOrderInput | SortOrder
    isActive?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    revokedAt?: SortOrderInput | SortOrder
    firstViewedAt?: SortOrderInput | SortOrder
    lastViewedAt?: SortOrderInput | SortOrder
    viewCount?: SortOrder
    createdByUserId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VariationPublicLinkCountOrderByAggregateInput
    _avg?: VariationPublicLinkAvgOrderByAggregateInput
    _max?: VariationPublicLinkMaxOrderByAggregateInput
    _min?: VariationPublicLinkMinOrderByAggregateInput
    _sum?: VariationPublicLinkSumOrderByAggregateInput
  }

  export type VariationPublicLinkScalarWhereWithAggregatesInput = {
    AND?: VariationPublicLinkScalarWhereWithAggregatesInput | VariationPublicLinkScalarWhereWithAggregatesInput[]
    OR?: VariationPublicLinkScalarWhereWithAggregatesInput[]
    NOT?: VariationPublicLinkScalarWhereWithAggregatesInput | VariationPublicLinkScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VariationPublicLink"> | string
    orgId?: StringWithAggregatesFilter<"VariationPublicLink"> | string
    variationId?: StringWithAggregatesFilter<"VariationPublicLink"> | string
    tokenHash?: StringWithAggregatesFilter<"VariationPublicLink"> | string
    tokenPrefix?: StringNullableWithAggregatesFilter<"VariationPublicLink"> | string | null
    isActive?: BoolWithAggregatesFilter<"VariationPublicLink"> | boolean
    expiresAt?: DateTimeNullableWithAggregatesFilter<"VariationPublicLink"> | Date | string | null
    revokedAt?: DateTimeNullableWithAggregatesFilter<"VariationPublicLink"> | Date | string | null
    firstViewedAt?: DateTimeNullableWithAggregatesFilter<"VariationPublicLink"> | Date | string | null
    lastViewedAt?: DateTimeNullableWithAggregatesFilter<"VariationPublicLink"> | Date | string | null
    viewCount?: IntWithAggregatesFilter<"VariationPublicLink"> | number
    createdByUserId?: StringNullableWithAggregatesFilter<"VariationPublicLink"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"VariationPublicLink"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"VariationPublicLink"> | Date | string
  }

  export type VariationPdfWhereInput = {
    AND?: VariationPdfWhereInput | VariationPdfWhereInput[]
    OR?: VariationPdfWhereInput[]
    NOT?: VariationPdfWhereInput | VariationPdfWhereInput[]
    id?: StringFilter<"VariationPdf"> | string
    orgId?: StringFilter<"VariationPdf"> | string
    variationId?: StringFilter<"VariationPdf"> | string
    stage?: EnumVariationPdfStageFilter<"VariationPdf"> | $Enums.VariationPdfStage
    fileUrl?: StringFilter<"VariationPdf"> | string
    createdAt?: DateTimeFilter<"VariationPdf"> | Date | string
    variation?: XOR<VariationScalarRelationFilter, VariationWhereInput>
  }

  export type VariationPdfOrderByWithRelationInput = {
    id?: SortOrder
    orgId?: SortOrder
    variationId?: SortOrder
    stage?: SortOrder
    fileUrl?: SortOrder
    createdAt?: SortOrder
    variation?: VariationOrderByWithRelationInput
  }

  export type VariationPdfWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    variationId_stage?: VariationPdfVariationIdStageCompoundUniqueInput
    AND?: VariationPdfWhereInput | VariationPdfWhereInput[]
    OR?: VariationPdfWhereInput[]
    NOT?: VariationPdfWhereInput | VariationPdfWhereInput[]
    orgId?: StringFilter<"VariationPdf"> | string
    variationId?: StringFilter<"VariationPdf"> | string
    stage?: EnumVariationPdfStageFilter<"VariationPdf"> | $Enums.VariationPdfStage
    fileUrl?: StringFilter<"VariationPdf"> | string
    createdAt?: DateTimeFilter<"VariationPdf"> | Date | string
    variation?: XOR<VariationScalarRelationFilter, VariationWhereInput>
  }, "id" | "variationId_stage">

  export type VariationPdfOrderByWithAggregationInput = {
    id?: SortOrder
    orgId?: SortOrder
    variationId?: SortOrder
    stage?: SortOrder
    fileUrl?: SortOrder
    createdAt?: SortOrder
    _count?: VariationPdfCountOrderByAggregateInput
    _max?: VariationPdfMaxOrderByAggregateInput
    _min?: VariationPdfMinOrderByAggregateInput
  }

  export type VariationPdfScalarWhereWithAggregatesInput = {
    AND?: VariationPdfScalarWhereWithAggregatesInput | VariationPdfScalarWhereWithAggregatesInput[]
    OR?: VariationPdfScalarWhereWithAggregatesInput[]
    NOT?: VariationPdfScalarWhereWithAggregatesInput | VariationPdfScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VariationPdf"> | string
    orgId?: StringWithAggregatesFilter<"VariationPdf"> | string
    variationId?: StringWithAggregatesFilter<"VariationPdf"> | string
    stage?: EnumVariationPdfStageWithAggregatesFilter<"VariationPdf"> | $Enums.VariationPdfStage
    fileUrl?: StringWithAggregatesFilter<"VariationPdf"> | string
    createdAt?: DateTimeWithAggregatesFilter<"VariationPdf"> | Date | string
  }

  export type CompanySettingsCreateInput = {
    id?: string
    orgId: string
    companyName: string
    logoUrl?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    postcode?: string | null
    country?: string | null
    phone?: string | null
    email?: string | null
    website?: string | null
    defaultVatMode?: $Enums.VatMode
    defaultVatRateBps?: number
    defaultGrouping?: string
    defaultShowQtyToClient?: boolean
    defaultShowUnitRatesToClient?: boolean
    defaultTermsJson?: NullableJsonNullValueInput | InputJsonValue
    defaultScopeOverviewJson?: NullableJsonNullValueInput | InputJsonValue
    createdByUserId?: string | null
    updatedByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanySettingsUncheckedCreateInput = {
    id?: string
    orgId: string
    companyName: string
    logoUrl?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    postcode?: string | null
    country?: string | null
    phone?: string | null
    email?: string | null
    website?: string | null
    defaultVatMode?: $Enums.VatMode
    defaultVatRateBps?: number
    defaultGrouping?: string
    defaultShowQtyToClient?: boolean
    defaultShowUnitRatesToClient?: boolean
    defaultTermsJson?: NullableJsonNullValueInput | InputJsonValue
    defaultScopeOverviewJson?: NullableJsonNullValueInput | InputJsonValue
    createdByUserId?: string | null
    updatedByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanySettingsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postcode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    defaultVatMode?: EnumVatModeFieldUpdateOperationsInput | $Enums.VatMode
    defaultVatRateBps?: IntFieldUpdateOperationsInput | number
    defaultGrouping?: StringFieldUpdateOperationsInput | string
    defaultShowQtyToClient?: BoolFieldUpdateOperationsInput | boolean
    defaultShowUnitRatesToClient?: BoolFieldUpdateOperationsInput | boolean
    defaultTermsJson?: NullableJsonNullValueInput | InputJsonValue
    defaultScopeOverviewJson?: NullableJsonNullValueInput | InputJsonValue
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanySettingsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postcode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    defaultVatMode?: EnumVatModeFieldUpdateOperationsInput | $Enums.VatMode
    defaultVatRateBps?: IntFieldUpdateOperationsInput | number
    defaultGrouping?: StringFieldUpdateOperationsInput | string
    defaultShowQtyToClient?: BoolFieldUpdateOperationsInput | boolean
    defaultShowUnitRatesToClient?: BoolFieldUpdateOperationsInput | boolean
    defaultTermsJson?: NullableJsonNullValueInput | InputJsonValue
    defaultScopeOverviewJson?: NullableJsonNullValueInput | InputJsonValue
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanySettingsCreateManyInput = {
    id?: string
    orgId: string
    companyName: string
    logoUrl?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    postcode?: string | null
    country?: string | null
    phone?: string | null
    email?: string | null
    website?: string | null
    defaultVatMode?: $Enums.VatMode
    defaultVatRateBps?: number
    defaultGrouping?: string
    defaultShowQtyToClient?: boolean
    defaultShowUnitRatesToClient?: boolean
    defaultTermsJson?: NullableJsonNullValueInput | InputJsonValue
    defaultScopeOverviewJson?: NullableJsonNullValueInput | InputJsonValue
    createdByUserId?: string | null
    updatedByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanySettingsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postcode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    defaultVatMode?: EnumVatModeFieldUpdateOperationsInput | $Enums.VatMode
    defaultVatRateBps?: IntFieldUpdateOperationsInput | number
    defaultGrouping?: StringFieldUpdateOperationsInput | string
    defaultShowQtyToClient?: BoolFieldUpdateOperationsInput | boolean
    defaultShowUnitRatesToClient?: BoolFieldUpdateOperationsInput | boolean
    defaultTermsJson?: NullableJsonNullValueInput | InputJsonValue
    defaultScopeOverviewJson?: NullableJsonNullValueInput | InputJsonValue
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanySettingsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postcode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    defaultVatMode?: EnumVatModeFieldUpdateOperationsInput | $Enums.VatMode
    defaultVatRateBps?: IntFieldUpdateOperationsInput | number
    defaultGrouping?: StringFieldUpdateOperationsInput | string
    defaultShowQtyToClient?: BoolFieldUpdateOperationsInput | boolean
    defaultShowUnitRatesToClient?: BoolFieldUpdateOperationsInput | boolean
    defaultTermsJson?: NullableJsonNullValueInput | InputJsonValue
    defaultScopeOverviewJson?: NullableJsonNullValueInput | InputJsonValue
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientCreateInput = {
    id?: string
    orgId: string
    name: string
    email?: string | null
    phone?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    postcode?: string | null
    country?: string | null
    notes?: string | null
    createdByUserId?: string | null
    updatedByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    quotes?: QuoteCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateInput = {
    id?: string
    orgId: string
    name: string
    email?: string | null
    phone?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    postcode?: string | null
    country?: string | null
    notes?: string | null
    createdByUserId?: string | null
    updatedByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    quotes?: QuoteUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postcode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quotes?: QuoteUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postcode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quotes?: QuoteUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ClientCreateManyInput = {
    id?: string
    orgId: string
    name: string
    email?: string | null
    phone?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    postcode?: string | null
    country?: string | null
    notes?: string | null
    createdByUserId?: string | null
    updatedByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postcode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postcode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuoteCreateInput = {
    id?: string
    title: string
    referenceNo?: string | null
    projectAddress?: string | null
    status?: $Enums.QuoteStatus
    currentVersion?: number
    sentAt?: Date | string | null
    acceptedAt?: Date | string | null
    vatMode?: $Enums.VatMode
    vatRateBps?: number
    depositType?: $Enums.DepositType
    depositAmountPence?: number | null
    depositPercentBps?: number | null
    paymentScheduleJson?: NullableJsonNullValueInput | InputJsonValue
    showQtyToClient?: boolean
    showUnitRatesToClient?: boolean
    scopeOverviewJson?: NullableJsonNullValueInput | InputJsonValue
    termsJson?: NullableJsonNullValueInput | InputJsonValue
    estimatedStartDate?: Date | string | null
    estimatedDurationWeeks?: number | null
    createdByUserId?: string | null
    updatedByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client?: ClientCreateNestedOneWithoutQuotesInput
    items?: QuoteItemCreateNestedManyWithoutQuoteInput
    publicLinks?: QuotePublicLinkCreateNestedManyWithoutQuoteInput
    pdfs?: QuotePdfCreateNestedManyWithoutQuoteInput
    acceptance?: QuoteAcceptanceCreateNestedOneWithoutQuoteInput
    variations?: VariationCreateNestedManyWithoutQuoteInput
    versions?: QuoteVersionCreateNestedManyWithoutQuoteInput
  }

  export type QuoteUncheckedCreateInput = {
    id?: string
    orgId: string
    clientId?: string | null
    title: string
    referenceNo?: string | null
    projectAddress?: string | null
    status?: $Enums.QuoteStatus
    currentVersion?: number
    sentAt?: Date | string | null
    acceptedAt?: Date | string | null
    vatMode?: $Enums.VatMode
    vatRateBps?: number
    depositType?: $Enums.DepositType
    depositAmountPence?: number | null
    depositPercentBps?: number | null
    paymentScheduleJson?: NullableJsonNullValueInput | InputJsonValue
    showQtyToClient?: boolean
    showUnitRatesToClient?: boolean
    scopeOverviewJson?: NullableJsonNullValueInput | InputJsonValue
    termsJson?: NullableJsonNullValueInput | InputJsonValue
    estimatedStartDate?: Date | string | null
    estimatedDurationWeeks?: number | null
    createdByUserId?: string | null
    updatedByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: QuoteItemUncheckedCreateNestedManyWithoutQuoteInput
    publicLinks?: QuotePublicLinkUncheckedCreateNestedManyWithoutQuoteInput
    pdfs?: QuotePdfUncheckedCreateNestedManyWithoutQuoteInput
    acceptance?: QuoteAcceptanceUncheckedCreateNestedOneWithoutQuoteInput
    variations?: VariationUncheckedCreateNestedManyWithoutQuoteInput
    versions?: QuoteVersionUncheckedCreateNestedManyWithoutQuoteInput
  }

  export type QuoteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    referenceNo?: NullableStringFieldUpdateOperationsInput | string | null
    projectAddress?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQuoteStatusFieldUpdateOperationsInput | $Enums.QuoteStatus
    currentVersion?: IntFieldUpdateOperationsInput | number
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatMode?: EnumVatModeFieldUpdateOperationsInput | $Enums.VatMode
    vatRateBps?: IntFieldUpdateOperationsInput | number
    depositType?: EnumDepositTypeFieldUpdateOperationsInput | $Enums.DepositType
    depositAmountPence?: NullableIntFieldUpdateOperationsInput | number | null
    depositPercentBps?: NullableIntFieldUpdateOperationsInput | number | null
    paymentScheduleJson?: NullableJsonNullValueInput | InputJsonValue
    showQtyToClient?: BoolFieldUpdateOperationsInput | boolean
    showUnitRatesToClient?: BoolFieldUpdateOperationsInput | boolean
    scopeOverviewJson?: NullableJsonNullValueInput | InputJsonValue
    termsJson?: NullableJsonNullValueInput | InputJsonValue
    estimatedStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedDurationWeeks?: NullableIntFieldUpdateOperationsInput | number | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneWithoutQuotesNestedInput
    items?: QuoteItemUpdateManyWithoutQuoteNestedInput
    publicLinks?: QuotePublicLinkUpdateManyWithoutQuoteNestedInput
    pdfs?: QuotePdfUpdateManyWithoutQuoteNestedInput
    acceptance?: QuoteAcceptanceUpdateOneWithoutQuoteNestedInput
    variations?: VariationUpdateManyWithoutQuoteNestedInput
    versions?: QuoteVersionUpdateManyWithoutQuoteNestedInput
  }

  export type QuoteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    referenceNo?: NullableStringFieldUpdateOperationsInput | string | null
    projectAddress?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQuoteStatusFieldUpdateOperationsInput | $Enums.QuoteStatus
    currentVersion?: IntFieldUpdateOperationsInput | number
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatMode?: EnumVatModeFieldUpdateOperationsInput | $Enums.VatMode
    vatRateBps?: IntFieldUpdateOperationsInput | number
    depositType?: EnumDepositTypeFieldUpdateOperationsInput | $Enums.DepositType
    depositAmountPence?: NullableIntFieldUpdateOperationsInput | number | null
    depositPercentBps?: NullableIntFieldUpdateOperationsInput | number | null
    paymentScheduleJson?: NullableJsonNullValueInput | InputJsonValue
    showQtyToClient?: BoolFieldUpdateOperationsInput | boolean
    showUnitRatesToClient?: BoolFieldUpdateOperationsInput | boolean
    scopeOverviewJson?: NullableJsonNullValueInput | InputJsonValue
    termsJson?: NullableJsonNullValueInput | InputJsonValue
    estimatedStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedDurationWeeks?: NullableIntFieldUpdateOperationsInput | number | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: QuoteItemUncheckedUpdateManyWithoutQuoteNestedInput
    publicLinks?: QuotePublicLinkUncheckedUpdateManyWithoutQuoteNestedInput
    pdfs?: QuotePdfUncheckedUpdateManyWithoutQuoteNestedInput
    acceptance?: QuoteAcceptanceUncheckedUpdateOneWithoutQuoteNestedInput
    variations?: VariationUncheckedUpdateManyWithoutQuoteNestedInput
    versions?: QuoteVersionUncheckedUpdateManyWithoutQuoteNestedInput
  }

  export type QuoteCreateManyInput = {
    id?: string
    orgId: string
    clientId?: string | null
    title: string
    referenceNo?: string | null
    projectAddress?: string | null
    status?: $Enums.QuoteStatus
    currentVersion?: number
    sentAt?: Date | string | null
    acceptedAt?: Date | string | null
    vatMode?: $Enums.VatMode
    vatRateBps?: number
    depositType?: $Enums.DepositType
    depositAmountPence?: number | null
    depositPercentBps?: number | null
    paymentScheduleJson?: NullableJsonNullValueInput | InputJsonValue
    showQtyToClient?: boolean
    showUnitRatesToClient?: boolean
    scopeOverviewJson?: NullableJsonNullValueInput | InputJsonValue
    termsJson?: NullableJsonNullValueInput | InputJsonValue
    estimatedStartDate?: Date | string | null
    estimatedDurationWeeks?: number | null
    createdByUserId?: string | null
    updatedByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuoteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    referenceNo?: NullableStringFieldUpdateOperationsInput | string | null
    projectAddress?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQuoteStatusFieldUpdateOperationsInput | $Enums.QuoteStatus
    currentVersion?: IntFieldUpdateOperationsInput | number
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatMode?: EnumVatModeFieldUpdateOperationsInput | $Enums.VatMode
    vatRateBps?: IntFieldUpdateOperationsInput | number
    depositType?: EnumDepositTypeFieldUpdateOperationsInput | $Enums.DepositType
    depositAmountPence?: NullableIntFieldUpdateOperationsInput | number | null
    depositPercentBps?: NullableIntFieldUpdateOperationsInput | number | null
    paymentScheduleJson?: NullableJsonNullValueInput | InputJsonValue
    showQtyToClient?: BoolFieldUpdateOperationsInput | boolean
    showUnitRatesToClient?: BoolFieldUpdateOperationsInput | boolean
    scopeOverviewJson?: NullableJsonNullValueInput | InputJsonValue
    termsJson?: NullableJsonNullValueInput | InputJsonValue
    estimatedStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedDurationWeeks?: NullableIntFieldUpdateOperationsInput | number | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuoteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    referenceNo?: NullableStringFieldUpdateOperationsInput | string | null
    projectAddress?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQuoteStatusFieldUpdateOperationsInput | $Enums.QuoteStatus
    currentVersion?: IntFieldUpdateOperationsInput | number
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatMode?: EnumVatModeFieldUpdateOperationsInput | $Enums.VatMode
    vatRateBps?: IntFieldUpdateOperationsInput | number
    depositType?: EnumDepositTypeFieldUpdateOperationsInput | $Enums.DepositType
    depositAmountPence?: NullableIntFieldUpdateOperationsInput | number | null
    depositPercentBps?: NullableIntFieldUpdateOperationsInput | number | null
    paymentScheduleJson?: NullableJsonNullValueInput | InputJsonValue
    showQtyToClient?: BoolFieldUpdateOperationsInput | boolean
    showUnitRatesToClient?: BoolFieldUpdateOperationsInput | boolean
    scopeOverviewJson?: NullableJsonNullValueInput | InputJsonValue
    termsJson?: NullableJsonNullValueInput | InputJsonValue
    estimatedStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedDurationWeeks?: NullableIntFieldUpdateOperationsInput | number | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuoteItemCreateInput = {
    id?: string
    rowType?: $Enums.ItemRowType
    title: string
    description?: string | null
    sortOrder?: number
    roomTag?: string | null
    tradeTag?: string | null
    phaseTag?: string | null
    calcType?: $Enums.CalcType
    qty?: Decimal | DecimalJsLike | number | string | null
    unit?: string | null
    unitPricePence?: number | null
    hours?: Decimal | DecimalJsLike | number | string | null
    hourlyRatePence?: number | null
    sellPricePence?: number | null
    isAllowance?: boolean
    costPence?: number | null
    markupPercentBps?: number | null
    createdByUserId?: string | null
    updatedByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    quote: QuoteCreateNestedOneWithoutItemsInput
    parent?: QuoteItemCreateNestedOneWithoutChildrenInput
    children?: QuoteItemCreateNestedManyWithoutParentInput
  }

  export type QuoteItemUncheckedCreateInput = {
    id?: string
    orgId: string
    quoteId: string
    parentId?: string | null
    rowType?: $Enums.ItemRowType
    title: string
    description?: string | null
    sortOrder?: number
    roomTag?: string | null
    tradeTag?: string | null
    phaseTag?: string | null
    calcType?: $Enums.CalcType
    qty?: Decimal | DecimalJsLike | number | string | null
    unit?: string | null
    unitPricePence?: number | null
    hours?: Decimal | DecimalJsLike | number | string | null
    hourlyRatePence?: number | null
    sellPricePence?: number | null
    isAllowance?: boolean
    costPence?: number | null
    markupPercentBps?: number | null
    createdByUserId?: string | null
    updatedByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: QuoteItemUncheckedCreateNestedManyWithoutParentInput
  }

  export type QuoteItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rowType?: EnumItemRowTypeFieldUpdateOperationsInput | $Enums.ItemRowType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    roomTag?: NullableStringFieldUpdateOperationsInput | string | null
    tradeTag?: NullableStringFieldUpdateOperationsInput | string | null
    phaseTag?: NullableStringFieldUpdateOperationsInput | string | null
    calcType?: EnumCalcTypeFieldUpdateOperationsInput | $Enums.CalcType
    qty?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    unitPricePence?: NullableIntFieldUpdateOperationsInput | number | null
    hours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    hourlyRatePence?: NullableIntFieldUpdateOperationsInput | number | null
    sellPricePence?: NullableIntFieldUpdateOperationsInput | number | null
    isAllowance?: BoolFieldUpdateOperationsInput | boolean
    costPence?: NullableIntFieldUpdateOperationsInput | number | null
    markupPercentBps?: NullableIntFieldUpdateOperationsInput | number | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quote?: QuoteUpdateOneRequiredWithoutItemsNestedInput
    parent?: QuoteItemUpdateOneWithoutChildrenNestedInput
    children?: QuoteItemUpdateManyWithoutParentNestedInput
  }

  export type QuoteItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    quoteId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    rowType?: EnumItemRowTypeFieldUpdateOperationsInput | $Enums.ItemRowType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    roomTag?: NullableStringFieldUpdateOperationsInput | string | null
    tradeTag?: NullableStringFieldUpdateOperationsInput | string | null
    phaseTag?: NullableStringFieldUpdateOperationsInput | string | null
    calcType?: EnumCalcTypeFieldUpdateOperationsInput | $Enums.CalcType
    qty?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    unitPricePence?: NullableIntFieldUpdateOperationsInput | number | null
    hours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    hourlyRatePence?: NullableIntFieldUpdateOperationsInput | number | null
    sellPricePence?: NullableIntFieldUpdateOperationsInput | number | null
    isAllowance?: BoolFieldUpdateOperationsInput | boolean
    costPence?: NullableIntFieldUpdateOperationsInput | number | null
    markupPercentBps?: NullableIntFieldUpdateOperationsInput | number | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: QuoteItemUncheckedUpdateManyWithoutParentNestedInput
  }

  export type QuoteItemCreateManyInput = {
    id?: string
    orgId: string
    quoteId: string
    parentId?: string | null
    rowType?: $Enums.ItemRowType
    title: string
    description?: string | null
    sortOrder?: number
    roomTag?: string | null
    tradeTag?: string | null
    phaseTag?: string | null
    calcType?: $Enums.CalcType
    qty?: Decimal | DecimalJsLike | number | string | null
    unit?: string | null
    unitPricePence?: number | null
    hours?: Decimal | DecimalJsLike | number | string | null
    hourlyRatePence?: number | null
    sellPricePence?: number | null
    isAllowance?: boolean
    costPence?: number | null
    markupPercentBps?: number | null
    createdByUserId?: string | null
    updatedByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuoteItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    rowType?: EnumItemRowTypeFieldUpdateOperationsInput | $Enums.ItemRowType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    roomTag?: NullableStringFieldUpdateOperationsInput | string | null
    tradeTag?: NullableStringFieldUpdateOperationsInput | string | null
    phaseTag?: NullableStringFieldUpdateOperationsInput | string | null
    calcType?: EnumCalcTypeFieldUpdateOperationsInput | $Enums.CalcType
    qty?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    unitPricePence?: NullableIntFieldUpdateOperationsInput | number | null
    hours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    hourlyRatePence?: NullableIntFieldUpdateOperationsInput | number | null
    sellPricePence?: NullableIntFieldUpdateOperationsInput | number | null
    isAllowance?: BoolFieldUpdateOperationsInput | boolean
    costPence?: NullableIntFieldUpdateOperationsInput | number | null
    markupPercentBps?: NullableIntFieldUpdateOperationsInput | number | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuoteItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    quoteId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    rowType?: EnumItemRowTypeFieldUpdateOperationsInput | $Enums.ItemRowType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    roomTag?: NullableStringFieldUpdateOperationsInput | string | null
    tradeTag?: NullableStringFieldUpdateOperationsInput | string | null
    phaseTag?: NullableStringFieldUpdateOperationsInput | string | null
    calcType?: EnumCalcTypeFieldUpdateOperationsInput | $Enums.CalcType
    qty?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    unitPricePence?: NullableIntFieldUpdateOperationsInput | number | null
    hours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    hourlyRatePence?: NullableIntFieldUpdateOperationsInput | number | null
    sellPricePence?: NullableIntFieldUpdateOperationsInput | number | null
    isAllowance?: BoolFieldUpdateOperationsInput | boolean
    costPence?: NullableIntFieldUpdateOperationsInput | number | null
    markupPercentBps?: NullableIntFieldUpdateOperationsInput | number | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuoteVersionCreateInput = {
    id?: string
    version: number
    status: $Enums.QuoteStatus
    vatMode: $Enums.VatMode
    vatRateBps: number
    depositType: $Enums.DepositType
    depositAmountPence?: number | null
    depositPercentBps?: number | null
    showQtyToClient: boolean
    showUnitRatesToClient: boolean
    title: string
    referenceNo?: string | null
    projectAddress?: string | null
    scopeOverviewJson?: NullableJsonNullValueInput | InputJsonValue
    termsJson?: NullableJsonNullValueInput | InputJsonValue
    paymentScheduleJson?: NullableJsonNullValueInput | InputJsonValue
    subtotalPence?: number | null
    vatPence?: number | null
    totalPence?: number | null
    sentAt?: Date | string | null
    createdByUserId?: string | null
    createdAt?: Date | string
    quote: QuoteCreateNestedOneWithoutVersionsInput
    items?: QuoteVersionItemCreateNestedManyWithoutQuoteVersionInput
  }

  export type QuoteVersionUncheckedCreateInput = {
    id?: string
    orgId: string
    quoteId: string
    version: number
    status: $Enums.QuoteStatus
    vatMode: $Enums.VatMode
    vatRateBps: number
    depositType: $Enums.DepositType
    depositAmountPence?: number | null
    depositPercentBps?: number | null
    showQtyToClient: boolean
    showUnitRatesToClient: boolean
    title: string
    referenceNo?: string | null
    projectAddress?: string | null
    scopeOverviewJson?: NullableJsonNullValueInput | InputJsonValue
    termsJson?: NullableJsonNullValueInput | InputJsonValue
    paymentScheduleJson?: NullableJsonNullValueInput | InputJsonValue
    subtotalPence?: number | null
    vatPence?: number | null
    totalPence?: number | null
    sentAt?: Date | string | null
    createdByUserId?: string | null
    createdAt?: Date | string
    items?: QuoteVersionItemUncheckedCreateNestedManyWithoutQuoteVersionInput
  }

  export type QuoteVersionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumQuoteStatusFieldUpdateOperationsInput | $Enums.QuoteStatus
    vatMode?: EnumVatModeFieldUpdateOperationsInput | $Enums.VatMode
    vatRateBps?: IntFieldUpdateOperationsInput | number
    depositType?: EnumDepositTypeFieldUpdateOperationsInput | $Enums.DepositType
    depositAmountPence?: NullableIntFieldUpdateOperationsInput | number | null
    depositPercentBps?: NullableIntFieldUpdateOperationsInput | number | null
    showQtyToClient?: BoolFieldUpdateOperationsInput | boolean
    showUnitRatesToClient?: BoolFieldUpdateOperationsInput | boolean
    title?: StringFieldUpdateOperationsInput | string
    referenceNo?: NullableStringFieldUpdateOperationsInput | string | null
    projectAddress?: NullableStringFieldUpdateOperationsInput | string | null
    scopeOverviewJson?: NullableJsonNullValueInput | InputJsonValue
    termsJson?: NullableJsonNullValueInput | InputJsonValue
    paymentScheduleJson?: NullableJsonNullValueInput | InputJsonValue
    subtotalPence?: NullableIntFieldUpdateOperationsInput | number | null
    vatPence?: NullableIntFieldUpdateOperationsInput | number | null
    totalPence?: NullableIntFieldUpdateOperationsInput | number | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quote?: QuoteUpdateOneRequiredWithoutVersionsNestedInput
    items?: QuoteVersionItemUpdateManyWithoutQuoteVersionNestedInput
  }

  export type QuoteVersionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    quoteId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumQuoteStatusFieldUpdateOperationsInput | $Enums.QuoteStatus
    vatMode?: EnumVatModeFieldUpdateOperationsInput | $Enums.VatMode
    vatRateBps?: IntFieldUpdateOperationsInput | number
    depositType?: EnumDepositTypeFieldUpdateOperationsInput | $Enums.DepositType
    depositAmountPence?: NullableIntFieldUpdateOperationsInput | number | null
    depositPercentBps?: NullableIntFieldUpdateOperationsInput | number | null
    showQtyToClient?: BoolFieldUpdateOperationsInput | boolean
    showUnitRatesToClient?: BoolFieldUpdateOperationsInput | boolean
    title?: StringFieldUpdateOperationsInput | string
    referenceNo?: NullableStringFieldUpdateOperationsInput | string | null
    projectAddress?: NullableStringFieldUpdateOperationsInput | string | null
    scopeOverviewJson?: NullableJsonNullValueInput | InputJsonValue
    termsJson?: NullableJsonNullValueInput | InputJsonValue
    paymentScheduleJson?: NullableJsonNullValueInput | InputJsonValue
    subtotalPence?: NullableIntFieldUpdateOperationsInput | number | null
    vatPence?: NullableIntFieldUpdateOperationsInput | number | null
    totalPence?: NullableIntFieldUpdateOperationsInput | number | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: QuoteVersionItemUncheckedUpdateManyWithoutQuoteVersionNestedInput
  }

  export type QuoteVersionCreateManyInput = {
    id?: string
    orgId: string
    quoteId: string
    version: number
    status: $Enums.QuoteStatus
    vatMode: $Enums.VatMode
    vatRateBps: number
    depositType: $Enums.DepositType
    depositAmountPence?: number | null
    depositPercentBps?: number | null
    showQtyToClient: boolean
    showUnitRatesToClient: boolean
    title: string
    referenceNo?: string | null
    projectAddress?: string | null
    scopeOverviewJson?: NullableJsonNullValueInput | InputJsonValue
    termsJson?: NullableJsonNullValueInput | InputJsonValue
    paymentScheduleJson?: NullableJsonNullValueInput | InputJsonValue
    subtotalPence?: number | null
    vatPence?: number | null
    totalPence?: number | null
    sentAt?: Date | string | null
    createdByUserId?: string | null
    createdAt?: Date | string
  }

  export type QuoteVersionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumQuoteStatusFieldUpdateOperationsInput | $Enums.QuoteStatus
    vatMode?: EnumVatModeFieldUpdateOperationsInput | $Enums.VatMode
    vatRateBps?: IntFieldUpdateOperationsInput | number
    depositType?: EnumDepositTypeFieldUpdateOperationsInput | $Enums.DepositType
    depositAmountPence?: NullableIntFieldUpdateOperationsInput | number | null
    depositPercentBps?: NullableIntFieldUpdateOperationsInput | number | null
    showQtyToClient?: BoolFieldUpdateOperationsInput | boolean
    showUnitRatesToClient?: BoolFieldUpdateOperationsInput | boolean
    title?: StringFieldUpdateOperationsInput | string
    referenceNo?: NullableStringFieldUpdateOperationsInput | string | null
    projectAddress?: NullableStringFieldUpdateOperationsInput | string | null
    scopeOverviewJson?: NullableJsonNullValueInput | InputJsonValue
    termsJson?: NullableJsonNullValueInput | InputJsonValue
    paymentScheduleJson?: NullableJsonNullValueInput | InputJsonValue
    subtotalPence?: NullableIntFieldUpdateOperationsInput | number | null
    vatPence?: NullableIntFieldUpdateOperationsInput | number | null
    totalPence?: NullableIntFieldUpdateOperationsInput | number | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuoteVersionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    quoteId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumQuoteStatusFieldUpdateOperationsInput | $Enums.QuoteStatus
    vatMode?: EnumVatModeFieldUpdateOperationsInput | $Enums.VatMode
    vatRateBps?: IntFieldUpdateOperationsInput | number
    depositType?: EnumDepositTypeFieldUpdateOperationsInput | $Enums.DepositType
    depositAmountPence?: NullableIntFieldUpdateOperationsInput | number | null
    depositPercentBps?: NullableIntFieldUpdateOperationsInput | number | null
    showQtyToClient?: BoolFieldUpdateOperationsInput | boolean
    showUnitRatesToClient?: BoolFieldUpdateOperationsInput | boolean
    title?: StringFieldUpdateOperationsInput | string
    referenceNo?: NullableStringFieldUpdateOperationsInput | string | null
    projectAddress?: NullableStringFieldUpdateOperationsInput | string | null
    scopeOverviewJson?: NullableJsonNullValueInput | InputJsonValue
    termsJson?: NullableJsonNullValueInput | InputJsonValue
    paymentScheduleJson?: NullableJsonNullValueInput | InputJsonValue
    subtotalPence?: NullableIntFieldUpdateOperationsInput | number | null
    vatPence?: NullableIntFieldUpdateOperationsInput | number | null
    totalPence?: NullableIntFieldUpdateOperationsInput | number | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuoteVersionItemCreateInput = {
    id?: string
    sourceQuoteItemId?: string | null
    rowType?: $Enums.ItemRowType
    title: string
    description?: string | null
    sortOrder?: number
    roomTag?: string | null
    tradeTag?: string | null
    phaseTag?: string | null
    calcType?: $Enums.CalcType
    qty?: Decimal | DecimalJsLike | number | string | null
    unit?: string | null
    unitPricePence?: number | null
    hours?: Decimal | DecimalJsLike | number | string | null
    hourlyRatePence?: number | null
    sellPricePence?: number | null
    isAllowance?: boolean
    lineTotalPence?: number | null
    createdAt?: Date | string
    quoteVersion: QuoteVersionCreateNestedOneWithoutItemsInput
    parent?: QuoteVersionItemCreateNestedOneWithoutChildrenInput
    children?: QuoteVersionItemCreateNestedManyWithoutParentInput
  }

  export type QuoteVersionItemUncheckedCreateInput = {
    id?: string
    orgId: string
    quoteVersionId: string
    parentId?: string | null
    sourceQuoteItemId?: string | null
    rowType?: $Enums.ItemRowType
    title: string
    description?: string | null
    sortOrder?: number
    roomTag?: string | null
    tradeTag?: string | null
    phaseTag?: string | null
    calcType?: $Enums.CalcType
    qty?: Decimal | DecimalJsLike | number | string | null
    unit?: string | null
    unitPricePence?: number | null
    hours?: Decimal | DecimalJsLike | number | string | null
    hourlyRatePence?: number | null
    sellPricePence?: number | null
    isAllowance?: boolean
    lineTotalPence?: number | null
    createdAt?: Date | string
    children?: QuoteVersionItemUncheckedCreateNestedManyWithoutParentInput
  }

  export type QuoteVersionItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceQuoteItemId?: NullableStringFieldUpdateOperationsInput | string | null
    rowType?: EnumItemRowTypeFieldUpdateOperationsInput | $Enums.ItemRowType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    roomTag?: NullableStringFieldUpdateOperationsInput | string | null
    tradeTag?: NullableStringFieldUpdateOperationsInput | string | null
    phaseTag?: NullableStringFieldUpdateOperationsInput | string | null
    calcType?: EnumCalcTypeFieldUpdateOperationsInput | $Enums.CalcType
    qty?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    unitPricePence?: NullableIntFieldUpdateOperationsInput | number | null
    hours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    hourlyRatePence?: NullableIntFieldUpdateOperationsInput | number | null
    sellPricePence?: NullableIntFieldUpdateOperationsInput | number | null
    isAllowance?: BoolFieldUpdateOperationsInput | boolean
    lineTotalPence?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quoteVersion?: QuoteVersionUpdateOneRequiredWithoutItemsNestedInput
    parent?: QuoteVersionItemUpdateOneWithoutChildrenNestedInput
    children?: QuoteVersionItemUpdateManyWithoutParentNestedInput
  }

  export type QuoteVersionItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    quoteVersionId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceQuoteItemId?: NullableStringFieldUpdateOperationsInput | string | null
    rowType?: EnumItemRowTypeFieldUpdateOperationsInput | $Enums.ItemRowType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    roomTag?: NullableStringFieldUpdateOperationsInput | string | null
    tradeTag?: NullableStringFieldUpdateOperationsInput | string | null
    phaseTag?: NullableStringFieldUpdateOperationsInput | string | null
    calcType?: EnumCalcTypeFieldUpdateOperationsInput | $Enums.CalcType
    qty?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    unitPricePence?: NullableIntFieldUpdateOperationsInput | number | null
    hours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    hourlyRatePence?: NullableIntFieldUpdateOperationsInput | number | null
    sellPricePence?: NullableIntFieldUpdateOperationsInput | number | null
    isAllowance?: BoolFieldUpdateOperationsInput | boolean
    lineTotalPence?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: QuoteVersionItemUncheckedUpdateManyWithoutParentNestedInput
  }

  export type QuoteVersionItemCreateManyInput = {
    id?: string
    orgId: string
    quoteVersionId: string
    parentId?: string | null
    sourceQuoteItemId?: string | null
    rowType?: $Enums.ItemRowType
    title: string
    description?: string | null
    sortOrder?: number
    roomTag?: string | null
    tradeTag?: string | null
    phaseTag?: string | null
    calcType?: $Enums.CalcType
    qty?: Decimal | DecimalJsLike | number | string | null
    unit?: string | null
    unitPricePence?: number | null
    hours?: Decimal | DecimalJsLike | number | string | null
    hourlyRatePence?: number | null
    sellPricePence?: number | null
    isAllowance?: boolean
    lineTotalPence?: number | null
    createdAt?: Date | string
  }

  export type QuoteVersionItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceQuoteItemId?: NullableStringFieldUpdateOperationsInput | string | null
    rowType?: EnumItemRowTypeFieldUpdateOperationsInput | $Enums.ItemRowType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    roomTag?: NullableStringFieldUpdateOperationsInput | string | null
    tradeTag?: NullableStringFieldUpdateOperationsInput | string | null
    phaseTag?: NullableStringFieldUpdateOperationsInput | string | null
    calcType?: EnumCalcTypeFieldUpdateOperationsInput | $Enums.CalcType
    qty?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    unitPricePence?: NullableIntFieldUpdateOperationsInput | number | null
    hours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    hourlyRatePence?: NullableIntFieldUpdateOperationsInput | number | null
    sellPricePence?: NullableIntFieldUpdateOperationsInput | number | null
    isAllowance?: BoolFieldUpdateOperationsInput | boolean
    lineTotalPence?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuoteVersionItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    quoteVersionId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceQuoteItemId?: NullableStringFieldUpdateOperationsInput | string | null
    rowType?: EnumItemRowTypeFieldUpdateOperationsInput | $Enums.ItemRowType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    roomTag?: NullableStringFieldUpdateOperationsInput | string | null
    tradeTag?: NullableStringFieldUpdateOperationsInput | string | null
    phaseTag?: NullableStringFieldUpdateOperationsInput | string | null
    calcType?: EnumCalcTypeFieldUpdateOperationsInput | $Enums.CalcType
    qty?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    unitPricePence?: NullableIntFieldUpdateOperationsInput | number | null
    hours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    hourlyRatePence?: NullableIntFieldUpdateOperationsInput | number | null
    sellPricePence?: NullableIntFieldUpdateOperationsInput | number | null
    isAllowance?: BoolFieldUpdateOperationsInput | boolean
    lineTotalPence?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuotePublicLinkCreateInput = {
    id?: string
    tokenHash: string
    tokenPrefix?: string | null
    isActive?: boolean
    expiresAt?: Date | string | null
    revokedAt?: Date | string | null
    firstViewedAt?: Date | string | null
    lastViewedAt?: Date | string | null
    viewCount?: number
    createdByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    quote: QuoteCreateNestedOneWithoutPublicLinksInput
  }

  export type QuotePublicLinkUncheckedCreateInput = {
    id?: string
    orgId: string
    quoteId: string
    tokenHash: string
    tokenPrefix?: string | null
    isActive?: boolean
    expiresAt?: Date | string | null
    revokedAt?: Date | string | null
    firstViewedAt?: Date | string | null
    lastViewedAt?: Date | string | null
    viewCount?: number
    createdByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuotePublicLinkUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    tokenPrefix?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firstViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quote?: QuoteUpdateOneRequiredWithoutPublicLinksNestedInput
  }

  export type QuotePublicLinkUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    quoteId?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    tokenPrefix?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firstViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuotePublicLinkCreateManyInput = {
    id?: string
    orgId: string
    quoteId: string
    tokenHash: string
    tokenPrefix?: string | null
    isActive?: boolean
    expiresAt?: Date | string | null
    revokedAt?: Date | string | null
    firstViewedAt?: Date | string | null
    lastViewedAt?: Date | string | null
    viewCount?: number
    createdByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuotePublicLinkUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    tokenPrefix?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firstViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuotePublicLinkUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    quoteId?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    tokenPrefix?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firstViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuotePdfCreateInput = {
    id?: string
    version: number
    fileUrl: string
    createdAt?: Date | string
    quote: QuoteCreateNestedOneWithoutPdfsInput
  }

  export type QuotePdfUncheckedCreateInput = {
    id?: string
    orgId: string
    quoteId: string
    version: number
    fileUrl: string
    createdAt?: Date | string
  }

  export type QuotePdfUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    fileUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quote?: QuoteUpdateOneRequiredWithoutPdfsNestedInput
  }

  export type QuotePdfUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    quoteId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    fileUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuotePdfCreateManyInput = {
    id?: string
    orgId: string
    quoteId: string
    version: number
    fileUrl: string
    createdAt?: Date | string
  }

  export type QuotePdfUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    fileUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuotePdfUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    quoteId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    fileUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuoteAcceptanceCreateInput = {
    id?: string
    acceptedName: string
    acceptedEmail?: string | null
    acceptedAt?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    quote: QuoteCreateNestedOneWithoutAcceptanceInput
  }

  export type QuoteAcceptanceUncheckedCreateInput = {
    id?: string
    orgId: string
    quoteId: string
    acceptedName: string
    acceptedEmail?: string | null
    acceptedAt?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type QuoteAcceptanceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    acceptedName?: StringFieldUpdateOperationsInput | string
    acceptedEmail?: NullableStringFieldUpdateOperationsInput | string | null
    acceptedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quote?: QuoteUpdateOneRequiredWithoutAcceptanceNestedInput
  }

  export type QuoteAcceptanceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    quoteId?: StringFieldUpdateOperationsInput | string
    acceptedName?: StringFieldUpdateOperationsInput | string
    acceptedEmail?: NullableStringFieldUpdateOperationsInput | string | null
    acceptedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuoteAcceptanceCreateManyInput = {
    id?: string
    orgId: string
    quoteId: string
    acceptedName: string
    acceptedEmail?: string | null
    acceptedAt?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type QuoteAcceptanceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    acceptedName?: StringFieldUpdateOperationsInput | string
    acceptedEmail?: NullableStringFieldUpdateOperationsInput | string | null
    acceptedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuoteAcceptanceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    quoteId?: StringFieldUpdateOperationsInput | string
    acceptedName?: StringFieldUpdateOperationsInput | string
    acceptedEmail?: NullableStringFieldUpdateOperationsInput | string | null
    acceptedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PriceBookItemCreateInput = {
    id?: string
    orgId: string
    title: string
    description?: string | null
    calcType?: $Enums.CalcType
    defaultQty?: Decimal | DecimalJsLike | number | string | null
    defaultUnit?: string | null
    defaultUnitPricePence?: number | null
    defaultHours?: Decimal | DecimalJsLike | number | string | null
    defaultHourlyRatePence?: number | null
    defaultSellPricePence?: number | null
    defaultIsAllowance?: boolean
    roomTag?: string | null
    tradeTag?: string | null
    phaseTag?: string | null
    isFavorite?: boolean
    createdByUserId?: string | null
    updatedByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PriceBookItemUncheckedCreateInput = {
    id?: string
    orgId: string
    title: string
    description?: string | null
    calcType?: $Enums.CalcType
    defaultQty?: Decimal | DecimalJsLike | number | string | null
    defaultUnit?: string | null
    defaultUnitPricePence?: number | null
    defaultHours?: Decimal | DecimalJsLike | number | string | null
    defaultHourlyRatePence?: number | null
    defaultSellPricePence?: number | null
    defaultIsAllowance?: boolean
    roomTag?: string | null
    tradeTag?: string | null
    phaseTag?: string | null
    isFavorite?: boolean
    createdByUserId?: string | null
    updatedByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PriceBookItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    calcType?: EnumCalcTypeFieldUpdateOperationsInput | $Enums.CalcType
    defaultQty?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    defaultUnit?: NullableStringFieldUpdateOperationsInput | string | null
    defaultUnitPricePence?: NullableIntFieldUpdateOperationsInput | number | null
    defaultHours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    defaultHourlyRatePence?: NullableIntFieldUpdateOperationsInput | number | null
    defaultSellPricePence?: NullableIntFieldUpdateOperationsInput | number | null
    defaultIsAllowance?: BoolFieldUpdateOperationsInput | boolean
    roomTag?: NullableStringFieldUpdateOperationsInput | string | null
    tradeTag?: NullableStringFieldUpdateOperationsInput | string | null
    phaseTag?: NullableStringFieldUpdateOperationsInput | string | null
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PriceBookItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    calcType?: EnumCalcTypeFieldUpdateOperationsInput | $Enums.CalcType
    defaultQty?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    defaultUnit?: NullableStringFieldUpdateOperationsInput | string | null
    defaultUnitPricePence?: NullableIntFieldUpdateOperationsInput | number | null
    defaultHours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    defaultHourlyRatePence?: NullableIntFieldUpdateOperationsInput | number | null
    defaultSellPricePence?: NullableIntFieldUpdateOperationsInput | number | null
    defaultIsAllowance?: BoolFieldUpdateOperationsInput | boolean
    roomTag?: NullableStringFieldUpdateOperationsInput | string | null
    tradeTag?: NullableStringFieldUpdateOperationsInput | string | null
    phaseTag?: NullableStringFieldUpdateOperationsInput | string | null
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PriceBookItemCreateManyInput = {
    id?: string
    orgId: string
    title: string
    description?: string | null
    calcType?: $Enums.CalcType
    defaultQty?: Decimal | DecimalJsLike | number | string | null
    defaultUnit?: string | null
    defaultUnitPricePence?: number | null
    defaultHours?: Decimal | DecimalJsLike | number | string | null
    defaultHourlyRatePence?: number | null
    defaultSellPricePence?: number | null
    defaultIsAllowance?: boolean
    roomTag?: string | null
    tradeTag?: string | null
    phaseTag?: string | null
    isFavorite?: boolean
    createdByUserId?: string | null
    updatedByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PriceBookItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    calcType?: EnumCalcTypeFieldUpdateOperationsInput | $Enums.CalcType
    defaultQty?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    defaultUnit?: NullableStringFieldUpdateOperationsInput | string | null
    defaultUnitPricePence?: NullableIntFieldUpdateOperationsInput | number | null
    defaultHours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    defaultHourlyRatePence?: NullableIntFieldUpdateOperationsInput | number | null
    defaultSellPricePence?: NullableIntFieldUpdateOperationsInput | number | null
    defaultIsAllowance?: BoolFieldUpdateOperationsInput | boolean
    roomTag?: NullableStringFieldUpdateOperationsInput | string | null
    tradeTag?: NullableStringFieldUpdateOperationsInput | string | null
    phaseTag?: NullableStringFieldUpdateOperationsInput | string | null
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PriceBookItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    calcType?: EnumCalcTypeFieldUpdateOperationsInput | $Enums.CalcType
    defaultQty?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    defaultUnit?: NullableStringFieldUpdateOperationsInput | string | null
    defaultUnitPricePence?: NullableIntFieldUpdateOperationsInput | number | null
    defaultHours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    defaultHourlyRatePence?: NullableIntFieldUpdateOperationsInput | number | null
    defaultSellPricePence?: NullableIntFieldUpdateOperationsInput | number | null
    defaultIsAllowance?: BoolFieldUpdateOperationsInput | boolean
    roomTag?: NullableStringFieldUpdateOperationsInput | string | null
    tradeTag?: NullableStringFieldUpdateOperationsInput | string | null
    phaseTag?: NullableStringFieldUpdateOperationsInput | string | null
    isFavorite?: BoolFieldUpdateOperationsInput | boolean
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TemplateSectionCreateInput = {
    id?: string
    orgId: string
    name: string
    description?: string | null
    createdByUserId?: string | null
    updatedByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: TemplateSectionItemCreateNestedManyWithoutTemplateSectionInput
  }

  export type TemplateSectionUncheckedCreateInput = {
    id?: string
    orgId: string
    name: string
    description?: string | null
    createdByUserId?: string | null
    updatedByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: TemplateSectionItemUncheckedCreateNestedManyWithoutTemplateSectionInput
  }

  export type TemplateSectionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: TemplateSectionItemUpdateManyWithoutTemplateSectionNestedInput
  }

  export type TemplateSectionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: TemplateSectionItemUncheckedUpdateManyWithoutTemplateSectionNestedInput
  }

  export type TemplateSectionCreateManyInput = {
    id?: string
    orgId: string
    name: string
    description?: string | null
    createdByUserId?: string | null
    updatedByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TemplateSectionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TemplateSectionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TemplateSectionItemCreateInput = {
    id?: string
    title: string
    description?: string | null
    sortOrder?: number
    calcType?: $Enums.CalcType
    qty?: Decimal | DecimalJsLike | number | string | null
    unit?: string | null
    unitPricePence?: number | null
    hours?: Decimal | DecimalJsLike | number | string | null
    hourlyRatePence?: number | null
    sellPricePence?: number | null
    isAllowance?: boolean
    roomTag?: string | null
    tradeTag?: string | null
    phaseTag?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    templateSection: TemplateSectionCreateNestedOneWithoutItemsInput
  }

  export type TemplateSectionItemUncheckedCreateInput = {
    id?: string
    orgId: string
    templateSectionId: string
    title: string
    description?: string | null
    sortOrder?: number
    calcType?: $Enums.CalcType
    qty?: Decimal | DecimalJsLike | number | string | null
    unit?: string | null
    unitPricePence?: number | null
    hours?: Decimal | DecimalJsLike | number | string | null
    hourlyRatePence?: number | null
    sellPricePence?: number | null
    isAllowance?: boolean
    roomTag?: string | null
    tradeTag?: string | null
    phaseTag?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TemplateSectionItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    calcType?: EnumCalcTypeFieldUpdateOperationsInput | $Enums.CalcType
    qty?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    unitPricePence?: NullableIntFieldUpdateOperationsInput | number | null
    hours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    hourlyRatePence?: NullableIntFieldUpdateOperationsInput | number | null
    sellPricePence?: NullableIntFieldUpdateOperationsInput | number | null
    isAllowance?: BoolFieldUpdateOperationsInput | boolean
    roomTag?: NullableStringFieldUpdateOperationsInput | string | null
    tradeTag?: NullableStringFieldUpdateOperationsInput | string | null
    phaseTag?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    templateSection?: TemplateSectionUpdateOneRequiredWithoutItemsNestedInput
  }

  export type TemplateSectionItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    templateSectionId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    calcType?: EnumCalcTypeFieldUpdateOperationsInput | $Enums.CalcType
    qty?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    unitPricePence?: NullableIntFieldUpdateOperationsInput | number | null
    hours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    hourlyRatePence?: NullableIntFieldUpdateOperationsInput | number | null
    sellPricePence?: NullableIntFieldUpdateOperationsInput | number | null
    isAllowance?: BoolFieldUpdateOperationsInput | boolean
    roomTag?: NullableStringFieldUpdateOperationsInput | string | null
    tradeTag?: NullableStringFieldUpdateOperationsInput | string | null
    phaseTag?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TemplateSectionItemCreateManyInput = {
    id?: string
    orgId: string
    templateSectionId: string
    title: string
    description?: string | null
    sortOrder?: number
    calcType?: $Enums.CalcType
    qty?: Decimal | DecimalJsLike | number | string | null
    unit?: string | null
    unitPricePence?: number | null
    hours?: Decimal | DecimalJsLike | number | string | null
    hourlyRatePence?: number | null
    sellPricePence?: number | null
    isAllowance?: boolean
    roomTag?: string | null
    tradeTag?: string | null
    phaseTag?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TemplateSectionItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    calcType?: EnumCalcTypeFieldUpdateOperationsInput | $Enums.CalcType
    qty?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    unitPricePence?: NullableIntFieldUpdateOperationsInput | number | null
    hours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    hourlyRatePence?: NullableIntFieldUpdateOperationsInput | number | null
    sellPricePence?: NullableIntFieldUpdateOperationsInput | number | null
    isAllowance?: BoolFieldUpdateOperationsInput | boolean
    roomTag?: NullableStringFieldUpdateOperationsInput | string | null
    tradeTag?: NullableStringFieldUpdateOperationsInput | string | null
    phaseTag?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TemplateSectionItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    templateSectionId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    calcType?: EnumCalcTypeFieldUpdateOperationsInput | $Enums.CalcType
    qty?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    unitPricePence?: NullableIntFieldUpdateOperationsInput | number | null
    hours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    hourlyRatePence?: NullableIntFieldUpdateOperationsInput | number | null
    sellPricePence?: NullableIntFieldUpdateOperationsInput | number | null
    isAllowance?: BoolFieldUpdateOperationsInput | boolean
    roomTag?: NullableStringFieldUpdateOperationsInput | string | null
    tradeTag?: NullableStringFieldUpdateOperationsInput | string | null
    phaseTag?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VariationCreateInput = {
    id?: string
    number: number
    title: string
    description?: string | null
    status?: $Enums.VariationStatus
    sentAt?: Date | string | null
    approvedAt?: Date | string | null
    vatMode?: $Enums.VatMode
    vatRateBps?: number
    createdByUserId?: string | null
    updatedByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    quote: QuoteCreateNestedOneWithoutVariationsInput
    publicLinks?: VariationPublicLinkCreateNestedManyWithoutVariationInput
    items?: VariationItemCreateNestedManyWithoutVariationInput
    approval?: VariationApprovalCreateNestedOneWithoutVariationInput
    pdfs?: VariationPdfCreateNestedManyWithoutVariationInput
  }

  export type VariationUncheckedCreateInput = {
    id?: string
    orgId: string
    quoteId: string
    number: number
    title: string
    description?: string | null
    status?: $Enums.VariationStatus
    sentAt?: Date | string | null
    approvedAt?: Date | string | null
    vatMode?: $Enums.VatMode
    vatRateBps?: number
    createdByUserId?: string | null
    updatedByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    publicLinks?: VariationPublicLinkUncheckedCreateNestedManyWithoutVariationInput
    items?: VariationItemUncheckedCreateNestedManyWithoutVariationInput
    approval?: VariationApprovalUncheckedCreateNestedOneWithoutVariationInput
    pdfs?: VariationPdfUncheckedCreateNestedManyWithoutVariationInput
  }

  export type VariationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVariationStatusFieldUpdateOperationsInput | $Enums.VariationStatus
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatMode?: EnumVatModeFieldUpdateOperationsInput | $Enums.VatMode
    vatRateBps?: IntFieldUpdateOperationsInput | number
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quote?: QuoteUpdateOneRequiredWithoutVariationsNestedInput
    publicLinks?: VariationPublicLinkUpdateManyWithoutVariationNestedInput
    items?: VariationItemUpdateManyWithoutVariationNestedInput
    approval?: VariationApprovalUpdateOneWithoutVariationNestedInput
    pdfs?: VariationPdfUpdateManyWithoutVariationNestedInput
  }

  export type VariationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    quoteId?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVariationStatusFieldUpdateOperationsInput | $Enums.VariationStatus
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatMode?: EnumVatModeFieldUpdateOperationsInput | $Enums.VatMode
    vatRateBps?: IntFieldUpdateOperationsInput | number
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publicLinks?: VariationPublicLinkUncheckedUpdateManyWithoutVariationNestedInput
    items?: VariationItemUncheckedUpdateManyWithoutVariationNestedInput
    approval?: VariationApprovalUncheckedUpdateOneWithoutVariationNestedInput
    pdfs?: VariationPdfUncheckedUpdateManyWithoutVariationNestedInput
  }

  export type VariationCreateManyInput = {
    id?: string
    orgId: string
    quoteId: string
    number: number
    title: string
    description?: string | null
    status?: $Enums.VariationStatus
    sentAt?: Date | string | null
    approvedAt?: Date | string | null
    vatMode?: $Enums.VatMode
    vatRateBps?: number
    createdByUserId?: string | null
    updatedByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VariationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVariationStatusFieldUpdateOperationsInput | $Enums.VariationStatus
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatMode?: EnumVatModeFieldUpdateOperationsInput | $Enums.VatMode
    vatRateBps?: IntFieldUpdateOperationsInput | number
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VariationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    quoteId?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVariationStatusFieldUpdateOperationsInput | $Enums.VariationStatus
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatMode?: EnumVatModeFieldUpdateOperationsInput | $Enums.VatMode
    vatRateBps?: IntFieldUpdateOperationsInput | number
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VariationItemCreateInput = {
    id?: string
    rowType?: $Enums.ItemRowType
    title: string
    description?: string | null
    sortOrder?: number
    calcType?: $Enums.CalcType
    qty?: Decimal | DecimalJsLike | number | string | null
    unit?: string | null
    unitPricePence?: number | null
    hours?: Decimal | DecimalJsLike | number | string | null
    hourlyRatePence?: number | null
    sellPricePence?: number | null
    isAllowance?: boolean
    roomTag?: string | null
    tradeTag?: string | null
    phaseTag?: string | null
    costPence?: number | null
    markupPercentBps?: number | null
    createdByUserId?: string | null
    updatedByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    variation: VariationCreateNestedOneWithoutItemsInput
    parent?: VariationItemCreateNestedOneWithoutChildrenInput
    children?: VariationItemCreateNestedManyWithoutParentInput
  }

  export type VariationItemUncheckedCreateInput = {
    id?: string
    orgId: string
    variationId: string
    parentId?: string | null
    rowType?: $Enums.ItemRowType
    title: string
    description?: string | null
    sortOrder?: number
    calcType?: $Enums.CalcType
    qty?: Decimal | DecimalJsLike | number | string | null
    unit?: string | null
    unitPricePence?: number | null
    hours?: Decimal | DecimalJsLike | number | string | null
    hourlyRatePence?: number | null
    sellPricePence?: number | null
    isAllowance?: boolean
    roomTag?: string | null
    tradeTag?: string | null
    phaseTag?: string | null
    costPence?: number | null
    markupPercentBps?: number | null
    createdByUserId?: string | null
    updatedByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: VariationItemUncheckedCreateNestedManyWithoutParentInput
  }

  export type VariationItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rowType?: EnumItemRowTypeFieldUpdateOperationsInput | $Enums.ItemRowType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    calcType?: EnumCalcTypeFieldUpdateOperationsInput | $Enums.CalcType
    qty?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    unitPricePence?: NullableIntFieldUpdateOperationsInput | number | null
    hours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    hourlyRatePence?: NullableIntFieldUpdateOperationsInput | number | null
    sellPricePence?: NullableIntFieldUpdateOperationsInput | number | null
    isAllowance?: BoolFieldUpdateOperationsInput | boolean
    roomTag?: NullableStringFieldUpdateOperationsInput | string | null
    tradeTag?: NullableStringFieldUpdateOperationsInput | string | null
    phaseTag?: NullableStringFieldUpdateOperationsInput | string | null
    costPence?: NullableIntFieldUpdateOperationsInput | number | null
    markupPercentBps?: NullableIntFieldUpdateOperationsInput | number | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    variation?: VariationUpdateOneRequiredWithoutItemsNestedInput
    parent?: VariationItemUpdateOneWithoutChildrenNestedInput
    children?: VariationItemUpdateManyWithoutParentNestedInput
  }

  export type VariationItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    variationId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    rowType?: EnumItemRowTypeFieldUpdateOperationsInput | $Enums.ItemRowType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    calcType?: EnumCalcTypeFieldUpdateOperationsInput | $Enums.CalcType
    qty?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    unitPricePence?: NullableIntFieldUpdateOperationsInput | number | null
    hours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    hourlyRatePence?: NullableIntFieldUpdateOperationsInput | number | null
    sellPricePence?: NullableIntFieldUpdateOperationsInput | number | null
    isAllowance?: BoolFieldUpdateOperationsInput | boolean
    roomTag?: NullableStringFieldUpdateOperationsInput | string | null
    tradeTag?: NullableStringFieldUpdateOperationsInput | string | null
    phaseTag?: NullableStringFieldUpdateOperationsInput | string | null
    costPence?: NullableIntFieldUpdateOperationsInput | number | null
    markupPercentBps?: NullableIntFieldUpdateOperationsInput | number | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: VariationItemUncheckedUpdateManyWithoutParentNestedInput
  }

  export type VariationItemCreateManyInput = {
    id?: string
    orgId: string
    variationId: string
    parentId?: string | null
    rowType?: $Enums.ItemRowType
    title: string
    description?: string | null
    sortOrder?: number
    calcType?: $Enums.CalcType
    qty?: Decimal | DecimalJsLike | number | string | null
    unit?: string | null
    unitPricePence?: number | null
    hours?: Decimal | DecimalJsLike | number | string | null
    hourlyRatePence?: number | null
    sellPricePence?: number | null
    isAllowance?: boolean
    roomTag?: string | null
    tradeTag?: string | null
    phaseTag?: string | null
    costPence?: number | null
    markupPercentBps?: number | null
    createdByUserId?: string | null
    updatedByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VariationItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    rowType?: EnumItemRowTypeFieldUpdateOperationsInput | $Enums.ItemRowType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    calcType?: EnumCalcTypeFieldUpdateOperationsInput | $Enums.CalcType
    qty?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    unitPricePence?: NullableIntFieldUpdateOperationsInput | number | null
    hours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    hourlyRatePence?: NullableIntFieldUpdateOperationsInput | number | null
    sellPricePence?: NullableIntFieldUpdateOperationsInput | number | null
    isAllowance?: BoolFieldUpdateOperationsInput | boolean
    roomTag?: NullableStringFieldUpdateOperationsInput | string | null
    tradeTag?: NullableStringFieldUpdateOperationsInput | string | null
    phaseTag?: NullableStringFieldUpdateOperationsInput | string | null
    costPence?: NullableIntFieldUpdateOperationsInput | number | null
    markupPercentBps?: NullableIntFieldUpdateOperationsInput | number | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VariationItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    variationId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    rowType?: EnumItemRowTypeFieldUpdateOperationsInput | $Enums.ItemRowType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    calcType?: EnumCalcTypeFieldUpdateOperationsInput | $Enums.CalcType
    qty?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    unitPricePence?: NullableIntFieldUpdateOperationsInput | number | null
    hours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    hourlyRatePence?: NullableIntFieldUpdateOperationsInput | number | null
    sellPricePence?: NullableIntFieldUpdateOperationsInput | number | null
    isAllowance?: BoolFieldUpdateOperationsInput | boolean
    roomTag?: NullableStringFieldUpdateOperationsInput | string | null
    tradeTag?: NullableStringFieldUpdateOperationsInput | string | null
    phaseTag?: NullableStringFieldUpdateOperationsInput | string | null
    costPence?: NullableIntFieldUpdateOperationsInput | number | null
    markupPercentBps?: NullableIntFieldUpdateOperationsInput | number | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VariationApprovalCreateInput = {
    id?: string
    approvedName: string
    approvedEmail?: string | null
    approvedAt?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    variation: VariationCreateNestedOneWithoutApprovalInput
  }

  export type VariationApprovalUncheckedCreateInput = {
    id?: string
    orgId: string
    variationId: string
    approvedName: string
    approvedEmail?: string | null
    approvedAt?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type VariationApprovalUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    approvedName?: StringFieldUpdateOperationsInput | string
    approvedEmail?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    variation?: VariationUpdateOneRequiredWithoutApprovalNestedInput
  }

  export type VariationApprovalUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    variationId?: StringFieldUpdateOperationsInput | string
    approvedName?: StringFieldUpdateOperationsInput | string
    approvedEmail?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VariationApprovalCreateManyInput = {
    id?: string
    orgId: string
    variationId: string
    approvedName: string
    approvedEmail?: string | null
    approvedAt?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type VariationApprovalUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    approvedName?: StringFieldUpdateOperationsInput | string
    approvedEmail?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VariationApprovalUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    variationId?: StringFieldUpdateOperationsInput | string
    approvedName?: StringFieldUpdateOperationsInput | string
    approvedEmail?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VariationPublicLinkCreateInput = {
    id?: string
    tokenHash: string
    tokenPrefix?: string | null
    isActive?: boolean
    expiresAt?: Date | string | null
    revokedAt?: Date | string | null
    firstViewedAt?: Date | string | null
    lastViewedAt?: Date | string | null
    viewCount?: number
    createdByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    variation: VariationCreateNestedOneWithoutPublicLinksInput
  }

  export type VariationPublicLinkUncheckedCreateInput = {
    id?: string
    orgId: string
    variationId: string
    tokenHash: string
    tokenPrefix?: string | null
    isActive?: boolean
    expiresAt?: Date | string | null
    revokedAt?: Date | string | null
    firstViewedAt?: Date | string | null
    lastViewedAt?: Date | string | null
    viewCount?: number
    createdByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VariationPublicLinkUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    tokenPrefix?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firstViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    variation?: VariationUpdateOneRequiredWithoutPublicLinksNestedInput
  }

  export type VariationPublicLinkUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    variationId?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    tokenPrefix?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firstViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VariationPublicLinkCreateManyInput = {
    id?: string
    orgId: string
    variationId: string
    tokenHash: string
    tokenPrefix?: string | null
    isActive?: boolean
    expiresAt?: Date | string | null
    revokedAt?: Date | string | null
    firstViewedAt?: Date | string | null
    lastViewedAt?: Date | string | null
    viewCount?: number
    createdByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VariationPublicLinkUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    tokenPrefix?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firstViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VariationPublicLinkUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    variationId?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    tokenPrefix?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firstViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VariationPdfCreateInput = {
    id?: string
    stage: $Enums.VariationPdfStage
    fileUrl: string
    createdAt?: Date | string
    variation: VariationCreateNestedOneWithoutPdfsInput
  }

  export type VariationPdfUncheckedCreateInput = {
    id?: string
    orgId: string
    variationId: string
    stage: $Enums.VariationPdfStage
    fileUrl: string
    createdAt?: Date | string
  }

  export type VariationPdfUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    stage?: EnumVariationPdfStageFieldUpdateOperationsInput | $Enums.VariationPdfStage
    fileUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    variation?: VariationUpdateOneRequiredWithoutPdfsNestedInput
  }

  export type VariationPdfUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    variationId?: StringFieldUpdateOperationsInput | string
    stage?: EnumVariationPdfStageFieldUpdateOperationsInput | $Enums.VariationPdfStage
    fileUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VariationPdfCreateManyInput = {
    id?: string
    orgId: string
    variationId: string
    stage: $Enums.VariationPdfStage
    fileUrl: string
    createdAt?: Date | string
  }

  export type VariationPdfUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    stage?: EnumVariationPdfStageFieldUpdateOperationsInput | $Enums.VariationPdfStage
    fileUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VariationPdfUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    variationId?: StringFieldUpdateOperationsInput | string
    stage?: EnumVariationPdfStageFieldUpdateOperationsInput | $Enums.VariationPdfStage
    fileUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumVatModeFilter<$PrismaModel = never> = {
    equals?: $Enums.VatMode | EnumVatModeFieldRefInput<$PrismaModel>
    in?: $Enums.VatMode[] | ListEnumVatModeFieldRefInput<$PrismaModel>
    notIn?: $Enums.VatMode[] | ListEnumVatModeFieldRefInput<$PrismaModel>
    not?: NestedEnumVatModeFilter<$PrismaModel> | $Enums.VatMode
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type CompanySettingsCountOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    companyName?: SortOrder
    logoUrl?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrder
    city?: SortOrder
    postcode?: SortOrder
    country?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    website?: SortOrder
    defaultVatMode?: SortOrder
    defaultVatRateBps?: SortOrder
    defaultGrouping?: SortOrder
    defaultShowQtyToClient?: SortOrder
    defaultShowUnitRatesToClient?: SortOrder
    defaultTermsJson?: SortOrder
    defaultScopeOverviewJson?: SortOrder
    createdByUserId?: SortOrder
    updatedByUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanySettingsAvgOrderByAggregateInput = {
    defaultVatRateBps?: SortOrder
  }

  export type CompanySettingsMaxOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    companyName?: SortOrder
    logoUrl?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrder
    city?: SortOrder
    postcode?: SortOrder
    country?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    website?: SortOrder
    defaultVatMode?: SortOrder
    defaultVatRateBps?: SortOrder
    defaultGrouping?: SortOrder
    defaultShowQtyToClient?: SortOrder
    defaultShowUnitRatesToClient?: SortOrder
    createdByUserId?: SortOrder
    updatedByUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanySettingsMinOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    companyName?: SortOrder
    logoUrl?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrder
    city?: SortOrder
    postcode?: SortOrder
    country?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    website?: SortOrder
    defaultVatMode?: SortOrder
    defaultVatRateBps?: SortOrder
    defaultGrouping?: SortOrder
    defaultShowQtyToClient?: SortOrder
    defaultShowUnitRatesToClient?: SortOrder
    createdByUserId?: SortOrder
    updatedByUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanySettingsSumOrderByAggregateInput = {
    defaultVatRateBps?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumVatModeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VatMode | EnumVatModeFieldRefInput<$PrismaModel>
    in?: $Enums.VatMode[] | ListEnumVatModeFieldRefInput<$PrismaModel>
    notIn?: $Enums.VatMode[] | ListEnumVatModeFieldRefInput<$PrismaModel>
    not?: NestedEnumVatModeWithAggregatesFilter<$PrismaModel> | $Enums.VatMode
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVatModeFilter<$PrismaModel>
    _max?: NestedEnumVatModeFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type QuoteListRelationFilter = {
    every?: QuoteWhereInput
    some?: QuoteWhereInput
    none?: QuoteWhereInput
  }

  export type QuoteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClientIdOrgIdCompoundUniqueInput = {
    id: string
    orgId: string
  }

  export type ClientCountOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrder
    city?: SortOrder
    postcode?: SortOrder
    country?: SortOrder
    notes?: SortOrder
    createdByUserId?: SortOrder
    updatedByUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientMaxOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrder
    city?: SortOrder
    postcode?: SortOrder
    country?: SortOrder
    notes?: SortOrder
    createdByUserId?: SortOrder
    updatedByUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientMinOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrder
    city?: SortOrder
    postcode?: SortOrder
    country?: SortOrder
    notes?: SortOrder
    createdByUserId?: SortOrder
    updatedByUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumQuoteStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.QuoteStatus | EnumQuoteStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QuoteStatus[] | ListEnumQuoteStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuoteStatus[] | ListEnumQuoteStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumQuoteStatusFilter<$PrismaModel> | $Enums.QuoteStatus
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type EnumDepositTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DepositType | EnumDepositTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DepositType[] | ListEnumDepositTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DepositType[] | ListEnumDepositTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDepositTypeFilter<$PrismaModel> | $Enums.DepositType
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type ClientNullableScalarRelationFilter = {
    is?: ClientWhereInput | null
    isNot?: ClientWhereInput | null
  }

  export type QuoteItemListRelationFilter = {
    every?: QuoteItemWhereInput
    some?: QuoteItemWhereInput
    none?: QuoteItemWhereInput
  }

  export type QuotePublicLinkListRelationFilter = {
    every?: QuotePublicLinkWhereInput
    some?: QuotePublicLinkWhereInput
    none?: QuotePublicLinkWhereInput
  }

  export type QuotePdfListRelationFilter = {
    every?: QuotePdfWhereInput
    some?: QuotePdfWhereInput
    none?: QuotePdfWhereInput
  }

  export type QuoteAcceptanceNullableScalarRelationFilter = {
    is?: QuoteAcceptanceWhereInput | null
    isNot?: QuoteAcceptanceWhereInput | null
  }

  export type VariationListRelationFilter = {
    every?: VariationWhereInput
    some?: VariationWhereInput
    none?: VariationWhereInput
  }

  export type QuoteVersionListRelationFilter = {
    every?: QuoteVersionWhereInput
    some?: QuoteVersionWhereInput
    none?: QuoteVersionWhereInput
  }

  export type QuoteItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuotePublicLinkOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuotePdfOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VariationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuoteVersionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuoteIdOrgIdCompoundUniqueInput = {
    id: string
    orgId: string
  }

  export type QuoteCountOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    clientId?: SortOrder
    title?: SortOrder
    referenceNo?: SortOrder
    projectAddress?: SortOrder
    status?: SortOrder
    currentVersion?: SortOrder
    sentAt?: SortOrder
    acceptedAt?: SortOrder
    vatMode?: SortOrder
    vatRateBps?: SortOrder
    depositType?: SortOrder
    depositAmountPence?: SortOrder
    depositPercentBps?: SortOrder
    paymentScheduleJson?: SortOrder
    showQtyToClient?: SortOrder
    showUnitRatesToClient?: SortOrder
    scopeOverviewJson?: SortOrder
    termsJson?: SortOrder
    estimatedStartDate?: SortOrder
    estimatedDurationWeeks?: SortOrder
    createdByUserId?: SortOrder
    updatedByUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuoteAvgOrderByAggregateInput = {
    currentVersion?: SortOrder
    vatRateBps?: SortOrder
    depositAmountPence?: SortOrder
    depositPercentBps?: SortOrder
    estimatedDurationWeeks?: SortOrder
  }

  export type QuoteMaxOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    clientId?: SortOrder
    title?: SortOrder
    referenceNo?: SortOrder
    projectAddress?: SortOrder
    status?: SortOrder
    currentVersion?: SortOrder
    sentAt?: SortOrder
    acceptedAt?: SortOrder
    vatMode?: SortOrder
    vatRateBps?: SortOrder
    depositType?: SortOrder
    depositAmountPence?: SortOrder
    depositPercentBps?: SortOrder
    showQtyToClient?: SortOrder
    showUnitRatesToClient?: SortOrder
    estimatedStartDate?: SortOrder
    estimatedDurationWeeks?: SortOrder
    createdByUserId?: SortOrder
    updatedByUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuoteMinOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    clientId?: SortOrder
    title?: SortOrder
    referenceNo?: SortOrder
    projectAddress?: SortOrder
    status?: SortOrder
    currentVersion?: SortOrder
    sentAt?: SortOrder
    acceptedAt?: SortOrder
    vatMode?: SortOrder
    vatRateBps?: SortOrder
    depositType?: SortOrder
    depositAmountPence?: SortOrder
    depositPercentBps?: SortOrder
    showQtyToClient?: SortOrder
    showUnitRatesToClient?: SortOrder
    estimatedStartDate?: SortOrder
    estimatedDurationWeeks?: SortOrder
    createdByUserId?: SortOrder
    updatedByUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuoteSumOrderByAggregateInput = {
    currentVersion?: SortOrder
    vatRateBps?: SortOrder
    depositAmountPence?: SortOrder
    depositPercentBps?: SortOrder
    estimatedDurationWeeks?: SortOrder
  }

  export type EnumQuoteStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QuoteStatus | EnumQuoteStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QuoteStatus[] | ListEnumQuoteStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuoteStatus[] | ListEnumQuoteStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumQuoteStatusWithAggregatesFilter<$PrismaModel> | $Enums.QuoteStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQuoteStatusFilter<$PrismaModel>
    _max?: NestedEnumQuoteStatusFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumDepositTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DepositType | EnumDepositTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DepositType[] | ListEnumDepositTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DepositType[] | ListEnumDepositTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDepositTypeWithAggregatesFilter<$PrismaModel> | $Enums.DepositType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDepositTypeFilter<$PrismaModel>
    _max?: NestedEnumDepositTypeFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumItemRowTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ItemRowType | EnumItemRowTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ItemRowType[] | ListEnumItemRowTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ItemRowType[] | ListEnumItemRowTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumItemRowTypeFilter<$PrismaModel> | $Enums.ItemRowType
  }

  export type EnumCalcTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CalcType | EnumCalcTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CalcType[] | ListEnumCalcTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CalcType[] | ListEnumCalcTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCalcTypeFilter<$PrismaModel> | $Enums.CalcType
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type QuoteScalarRelationFilter = {
    is?: QuoteWhereInput
    isNot?: QuoteWhereInput
  }

  export type QuoteItemNullableScalarRelationFilter = {
    is?: QuoteItemWhereInput | null
    isNot?: QuoteItemWhereInput | null
  }

  export type QuoteItemIdOrgIdCompoundUniqueInput = {
    id: string
    orgId: string
  }

  export type QuoteItemCountOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    quoteId?: SortOrder
    parentId?: SortOrder
    rowType?: SortOrder
    title?: SortOrder
    description?: SortOrder
    sortOrder?: SortOrder
    roomTag?: SortOrder
    tradeTag?: SortOrder
    phaseTag?: SortOrder
    calcType?: SortOrder
    qty?: SortOrder
    unit?: SortOrder
    unitPricePence?: SortOrder
    hours?: SortOrder
    hourlyRatePence?: SortOrder
    sellPricePence?: SortOrder
    isAllowance?: SortOrder
    costPence?: SortOrder
    markupPercentBps?: SortOrder
    createdByUserId?: SortOrder
    updatedByUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuoteItemAvgOrderByAggregateInput = {
    sortOrder?: SortOrder
    qty?: SortOrder
    unitPricePence?: SortOrder
    hours?: SortOrder
    hourlyRatePence?: SortOrder
    sellPricePence?: SortOrder
    costPence?: SortOrder
    markupPercentBps?: SortOrder
  }

  export type QuoteItemMaxOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    quoteId?: SortOrder
    parentId?: SortOrder
    rowType?: SortOrder
    title?: SortOrder
    description?: SortOrder
    sortOrder?: SortOrder
    roomTag?: SortOrder
    tradeTag?: SortOrder
    phaseTag?: SortOrder
    calcType?: SortOrder
    qty?: SortOrder
    unit?: SortOrder
    unitPricePence?: SortOrder
    hours?: SortOrder
    hourlyRatePence?: SortOrder
    sellPricePence?: SortOrder
    isAllowance?: SortOrder
    costPence?: SortOrder
    markupPercentBps?: SortOrder
    createdByUserId?: SortOrder
    updatedByUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuoteItemMinOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    quoteId?: SortOrder
    parentId?: SortOrder
    rowType?: SortOrder
    title?: SortOrder
    description?: SortOrder
    sortOrder?: SortOrder
    roomTag?: SortOrder
    tradeTag?: SortOrder
    phaseTag?: SortOrder
    calcType?: SortOrder
    qty?: SortOrder
    unit?: SortOrder
    unitPricePence?: SortOrder
    hours?: SortOrder
    hourlyRatePence?: SortOrder
    sellPricePence?: SortOrder
    isAllowance?: SortOrder
    costPence?: SortOrder
    markupPercentBps?: SortOrder
    createdByUserId?: SortOrder
    updatedByUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuoteItemSumOrderByAggregateInput = {
    sortOrder?: SortOrder
    qty?: SortOrder
    unitPricePence?: SortOrder
    hours?: SortOrder
    hourlyRatePence?: SortOrder
    sellPricePence?: SortOrder
    costPence?: SortOrder
    markupPercentBps?: SortOrder
  }

  export type EnumItemRowTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ItemRowType | EnumItemRowTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ItemRowType[] | ListEnumItemRowTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ItemRowType[] | ListEnumItemRowTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumItemRowTypeWithAggregatesFilter<$PrismaModel> | $Enums.ItemRowType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumItemRowTypeFilter<$PrismaModel>
    _max?: NestedEnumItemRowTypeFilter<$PrismaModel>
  }

  export type EnumCalcTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CalcType | EnumCalcTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CalcType[] | ListEnumCalcTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CalcType[] | ListEnumCalcTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCalcTypeWithAggregatesFilter<$PrismaModel> | $Enums.CalcType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCalcTypeFilter<$PrismaModel>
    _max?: NestedEnumCalcTypeFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type QuoteVersionItemListRelationFilter = {
    every?: QuoteVersionItemWhereInput
    some?: QuoteVersionItemWhereInput
    none?: QuoteVersionItemWhereInput
  }

  export type QuoteVersionItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuoteVersionIdOrgIdCompoundUniqueInput = {
    id: string
    orgId: string
  }

  export type QuoteVersionQuoteIdVersionCompoundUniqueInput = {
    quoteId: string
    version: number
  }

  export type QuoteVersionCountOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    quoteId?: SortOrder
    version?: SortOrder
    status?: SortOrder
    vatMode?: SortOrder
    vatRateBps?: SortOrder
    depositType?: SortOrder
    depositAmountPence?: SortOrder
    depositPercentBps?: SortOrder
    showQtyToClient?: SortOrder
    showUnitRatesToClient?: SortOrder
    title?: SortOrder
    referenceNo?: SortOrder
    projectAddress?: SortOrder
    scopeOverviewJson?: SortOrder
    termsJson?: SortOrder
    paymentScheduleJson?: SortOrder
    subtotalPence?: SortOrder
    vatPence?: SortOrder
    totalPence?: SortOrder
    sentAt?: SortOrder
    createdByUserId?: SortOrder
    createdAt?: SortOrder
  }

  export type QuoteVersionAvgOrderByAggregateInput = {
    version?: SortOrder
    vatRateBps?: SortOrder
    depositAmountPence?: SortOrder
    depositPercentBps?: SortOrder
    subtotalPence?: SortOrder
    vatPence?: SortOrder
    totalPence?: SortOrder
  }

  export type QuoteVersionMaxOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    quoteId?: SortOrder
    version?: SortOrder
    status?: SortOrder
    vatMode?: SortOrder
    vatRateBps?: SortOrder
    depositType?: SortOrder
    depositAmountPence?: SortOrder
    depositPercentBps?: SortOrder
    showQtyToClient?: SortOrder
    showUnitRatesToClient?: SortOrder
    title?: SortOrder
    referenceNo?: SortOrder
    projectAddress?: SortOrder
    subtotalPence?: SortOrder
    vatPence?: SortOrder
    totalPence?: SortOrder
    sentAt?: SortOrder
    createdByUserId?: SortOrder
    createdAt?: SortOrder
  }

  export type QuoteVersionMinOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    quoteId?: SortOrder
    version?: SortOrder
    status?: SortOrder
    vatMode?: SortOrder
    vatRateBps?: SortOrder
    depositType?: SortOrder
    depositAmountPence?: SortOrder
    depositPercentBps?: SortOrder
    showQtyToClient?: SortOrder
    showUnitRatesToClient?: SortOrder
    title?: SortOrder
    referenceNo?: SortOrder
    projectAddress?: SortOrder
    subtotalPence?: SortOrder
    vatPence?: SortOrder
    totalPence?: SortOrder
    sentAt?: SortOrder
    createdByUserId?: SortOrder
    createdAt?: SortOrder
  }

  export type QuoteVersionSumOrderByAggregateInput = {
    version?: SortOrder
    vatRateBps?: SortOrder
    depositAmountPence?: SortOrder
    depositPercentBps?: SortOrder
    subtotalPence?: SortOrder
    vatPence?: SortOrder
    totalPence?: SortOrder
  }

  export type QuoteVersionScalarRelationFilter = {
    is?: QuoteVersionWhereInput
    isNot?: QuoteVersionWhereInput
  }

  export type QuoteVersionItemNullableScalarRelationFilter = {
    is?: QuoteVersionItemWhereInput | null
    isNot?: QuoteVersionItemWhereInput | null
  }

  export type QuoteVersionItemIdOrgIdCompoundUniqueInput = {
    id: string
    orgId: string
  }

  export type QuoteVersionItemCountOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    quoteVersionId?: SortOrder
    parentId?: SortOrder
    sourceQuoteItemId?: SortOrder
    rowType?: SortOrder
    title?: SortOrder
    description?: SortOrder
    sortOrder?: SortOrder
    roomTag?: SortOrder
    tradeTag?: SortOrder
    phaseTag?: SortOrder
    calcType?: SortOrder
    qty?: SortOrder
    unit?: SortOrder
    unitPricePence?: SortOrder
    hours?: SortOrder
    hourlyRatePence?: SortOrder
    sellPricePence?: SortOrder
    isAllowance?: SortOrder
    lineTotalPence?: SortOrder
    createdAt?: SortOrder
  }

  export type QuoteVersionItemAvgOrderByAggregateInput = {
    sortOrder?: SortOrder
    qty?: SortOrder
    unitPricePence?: SortOrder
    hours?: SortOrder
    hourlyRatePence?: SortOrder
    sellPricePence?: SortOrder
    lineTotalPence?: SortOrder
  }

  export type QuoteVersionItemMaxOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    quoteVersionId?: SortOrder
    parentId?: SortOrder
    sourceQuoteItemId?: SortOrder
    rowType?: SortOrder
    title?: SortOrder
    description?: SortOrder
    sortOrder?: SortOrder
    roomTag?: SortOrder
    tradeTag?: SortOrder
    phaseTag?: SortOrder
    calcType?: SortOrder
    qty?: SortOrder
    unit?: SortOrder
    unitPricePence?: SortOrder
    hours?: SortOrder
    hourlyRatePence?: SortOrder
    sellPricePence?: SortOrder
    isAllowance?: SortOrder
    lineTotalPence?: SortOrder
    createdAt?: SortOrder
  }

  export type QuoteVersionItemMinOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    quoteVersionId?: SortOrder
    parentId?: SortOrder
    sourceQuoteItemId?: SortOrder
    rowType?: SortOrder
    title?: SortOrder
    description?: SortOrder
    sortOrder?: SortOrder
    roomTag?: SortOrder
    tradeTag?: SortOrder
    phaseTag?: SortOrder
    calcType?: SortOrder
    qty?: SortOrder
    unit?: SortOrder
    unitPricePence?: SortOrder
    hours?: SortOrder
    hourlyRatePence?: SortOrder
    sellPricePence?: SortOrder
    isAllowance?: SortOrder
    lineTotalPence?: SortOrder
    createdAt?: SortOrder
  }

  export type QuoteVersionItemSumOrderByAggregateInput = {
    sortOrder?: SortOrder
    qty?: SortOrder
    unitPricePence?: SortOrder
    hours?: SortOrder
    hourlyRatePence?: SortOrder
    sellPricePence?: SortOrder
    lineTotalPence?: SortOrder
  }

  export type QuotePublicLinkCountOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    quoteId?: SortOrder
    tokenHash?: SortOrder
    tokenPrefix?: SortOrder
    isActive?: SortOrder
    expiresAt?: SortOrder
    revokedAt?: SortOrder
    firstViewedAt?: SortOrder
    lastViewedAt?: SortOrder
    viewCount?: SortOrder
    createdByUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuotePublicLinkAvgOrderByAggregateInput = {
    viewCount?: SortOrder
  }

  export type QuotePublicLinkMaxOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    quoteId?: SortOrder
    tokenHash?: SortOrder
    tokenPrefix?: SortOrder
    isActive?: SortOrder
    expiresAt?: SortOrder
    revokedAt?: SortOrder
    firstViewedAt?: SortOrder
    lastViewedAt?: SortOrder
    viewCount?: SortOrder
    createdByUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuotePublicLinkMinOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    quoteId?: SortOrder
    tokenHash?: SortOrder
    tokenPrefix?: SortOrder
    isActive?: SortOrder
    expiresAt?: SortOrder
    revokedAt?: SortOrder
    firstViewedAt?: SortOrder
    lastViewedAt?: SortOrder
    viewCount?: SortOrder
    createdByUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuotePublicLinkSumOrderByAggregateInput = {
    viewCount?: SortOrder
  }

  export type QuotePdfQuoteIdVersionCompoundUniqueInput = {
    quoteId: string
    version: number
  }

  export type QuotePdfCountOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    quoteId?: SortOrder
    version?: SortOrder
    fileUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type QuotePdfAvgOrderByAggregateInput = {
    version?: SortOrder
  }

  export type QuotePdfMaxOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    quoteId?: SortOrder
    version?: SortOrder
    fileUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type QuotePdfMinOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    quoteId?: SortOrder
    version?: SortOrder
    fileUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type QuotePdfSumOrderByAggregateInput = {
    version?: SortOrder
  }

  export type QuoteAcceptanceQuoteIdOrgIdCompoundUniqueInput = {
    quoteId: string
    orgId: string
  }

  export type QuoteAcceptanceCountOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    quoteId?: SortOrder
    acceptedName?: SortOrder
    acceptedEmail?: SortOrder
    acceptedAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type QuoteAcceptanceMaxOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    quoteId?: SortOrder
    acceptedName?: SortOrder
    acceptedEmail?: SortOrder
    acceptedAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type QuoteAcceptanceMinOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    quoteId?: SortOrder
    acceptedName?: SortOrder
    acceptedEmail?: SortOrder
    acceptedAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type PriceBookItemCountOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    calcType?: SortOrder
    defaultQty?: SortOrder
    defaultUnit?: SortOrder
    defaultUnitPricePence?: SortOrder
    defaultHours?: SortOrder
    defaultHourlyRatePence?: SortOrder
    defaultSellPricePence?: SortOrder
    defaultIsAllowance?: SortOrder
    roomTag?: SortOrder
    tradeTag?: SortOrder
    phaseTag?: SortOrder
    isFavorite?: SortOrder
    createdByUserId?: SortOrder
    updatedByUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PriceBookItemAvgOrderByAggregateInput = {
    defaultQty?: SortOrder
    defaultUnitPricePence?: SortOrder
    defaultHours?: SortOrder
    defaultHourlyRatePence?: SortOrder
    defaultSellPricePence?: SortOrder
  }

  export type PriceBookItemMaxOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    calcType?: SortOrder
    defaultQty?: SortOrder
    defaultUnit?: SortOrder
    defaultUnitPricePence?: SortOrder
    defaultHours?: SortOrder
    defaultHourlyRatePence?: SortOrder
    defaultSellPricePence?: SortOrder
    defaultIsAllowance?: SortOrder
    roomTag?: SortOrder
    tradeTag?: SortOrder
    phaseTag?: SortOrder
    isFavorite?: SortOrder
    createdByUserId?: SortOrder
    updatedByUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PriceBookItemMinOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    calcType?: SortOrder
    defaultQty?: SortOrder
    defaultUnit?: SortOrder
    defaultUnitPricePence?: SortOrder
    defaultHours?: SortOrder
    defaultHourlyRatePence?: SortOrder
    defaultSellPricePence?: SortOrder
    defaultIsAllowance?: SortOrder
    roomTag?: SortOrder
    tradeTag?: SortOrder
    phaseTag?: SortOrder
    isFavorite?: SortOrder
    createdByUserId?: SortOrder
    updatedByUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PriceBookItemSumOrderByAggregateInput = {
    defaultQty?: SortOrder
    defaultUnitPricePence?: SortOrder
    defaultHours?: SortOrder
    defaultHourlyRatePence?: SortOrder
    defaultSellPricePence?: SortOrder
  }

  export type TemplateSectionItemListRelationFilter = {
    every?: TemplateSectionItemWhereInput
    some?: TemplateSectionItemWhereInput
    none?: TemplateSectionItemWhereInput
  }

  export type TemplateSectionItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TemplateSectionIdOrgIdCompoundUniqueInput = {
    id: string
    orgId: string
  }

  export type TemplateSectionCountOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdByUserId?: SortOrder
    updatedByUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TemplateSectionMaxOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdByUserId?: SortOrder
    updatedByUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TemplateSectionMinOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdByUserId?: SortOrder
    updatedByUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TemplateSectionScalarRelationFilter = {
    is?: TemplateSectionWhereInput
    isNot?: TemplateSectionWhereInput
  }

  export type TemplateSectionItemCountOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    templateSectionId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    sortOrder?: SortOrder
    calcType?: SortOrder
    qty?: SortOrder
    unit?: SortOrder
    unitPricePence?: SortOrder
    hours?: SortOrder
    hourlyRatePence?: SortOrder
    sellPricePence?: SortOrder
    isAllowance?: SortOrder
    roomTag?: SortOrder
    tradeTag?: SortOrder
    phaseTag?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TemplateSectionItemAvgOrderByAggregateInput = {
    sortOrder?: SortOrder
    qty?: SortOrder
    unitPricePence?: SortOrder
    hours?: SortOrder
    hourlyRatePence?: SortOrder
    sellPricePence?: SortOrder
  }

  export type TemplateSectionItemMaxOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    templateSectionId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    sortOrder?: SortOrder
    calcType?: SortOrder
    qty?: SortOrder
    unit?: SortOrder
    unitPricePence?: SortOrder
    hours?: SortOrder
    hourlyRatePence?: SortOrder
    sellPricePence?: SortOrder
    isAllowance?: SortOrder
    roomTag?: SortOrder
    tradeTag?: SortOrder
    phaseTag?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TemplateSectionItemMinOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    templateSectionId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    sortOrder?: SortOrder
    calcType?: SortOrder
    qty?: SortOrder
    unit?: SortOrder
    unitPricePence?: SortOrder
    hours?: SortOrder
    hourlyRatePence?: SortOrder
    sellPricePence?: SortOrder
    isAllowance?: SortOrder
    roomTag?: SortOrder
    tradeTag?: SortOrder
    phaseTag?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TemplateSectionItemSumOrderByAggregateInput = {
    sortOrder?: SortOrder
    qty?: SortOrder
    unitPricePence?: SortOrder
    hours?: SortOrder
    hourlyRatePence?: SortOrder
    sellPricePence?: SortOrder
  }

  export type EnumVariationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.VariationStatus | EnumVariationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VariationStatus[] | ListEnumVariationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VariationStatus[] | ListEnumVariationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVariationStatusFilter<$PrismaModel> | $Enums.VariationStatus
  }

  export type VariationPublicLinkListRelationFilter = {
    every?: VariationPublicLinkWhereInput
    some?: VariationPublicLinkWhereInput
    none?: VariationPublicLinkWhereInput
  }

  export type VariationItemListRelationFilter = {
    every?: VariationItemWhereInput
    some?: VariationItemWhereInput
    none?: VariationItemWhereInput
  }

  export type VariationApprovalNullableScalarRelationFilter = {
    is?: VariationApprovalWhereInput | null
    isNot?: VariationApprovalWhereInput | null
  }

  export type VariationPdfListRelationFilter = {
    every?: VariationPdfWhereInput
    some?: VariationPdfWhereInput
    none?: VariationPdfWhereInput
  }

  export type VariationPublicLinkOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VariationItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VariationPdfOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VariationIdOrgIdCompoundUniqueInput = {
    id: string
    orgId: string
  }

  export type VariationQuoteIdNumberCompoundUniqueInput = {
    quoteId: string
    number: number
  }

  export type VariationCountOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    quoteId?: SortOrder
    number?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    sentAt?: SortOrder
    approvedAt?: SortOrder
    vatMode?: SortOrder
    vatRateBps?: SortOrder
    createdByUserId?: SortOrder
    updatedByUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VariationAvgOrderByAggregateInput = {
    number?: SortOrder
    vatRateBps?: SortOrder
  }

  export type VariationMaxOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    quoteId?: SortOrder
    number?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    sentAt?: SortOrder
    approvedAt?: SortOrder
    vatMode?: SortOrder
    vatRateBps?: SortOrder
    createdByUserId?: SortOrder
    updatedByUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VariationMinOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    quoteId?: SortOrder
    number?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    sentAt?: SortOrder
    approvedAt?: SortOrder
    vatMode?: SortOrder
    vatRateBps?: SortOrder
    createdByUserId?: SortOrder
    updatedByUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VariationSumOrderByAggregateInput = {
    number?: SortOrder
    vatRateBps?: SortOrder
  }

  export type EnumVariationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VariationStatus | EnumVariationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VariationStatus[] | ListEnumVariationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VariationStatus[] | ListEnumVariationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVariationStatusWithAggregatesFilter<$PrismaModel> | $Enums.VariationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVariationStatusFilter<$PrismaModel>
    _max?: NestedEnumVariationStatusFilter<$PrismaModel>
  }

  export type VariationScalarRelationFilter = {
    is?: VariationWhereInput
    isNot?: VariationWhereInput
  }

  export type VariationItemNullableScalarRelationFilter = {
    is?: VariationItemWhereInput | null
    isNot?: VariationItemWhereInput | null
  }

  export type VariationItemIdOrgIdCompoundUniqueInput = {
    id: string
    orgId: string
  }

  export type VariationItemCountOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    variationId?: SortOrder
    parentId?: SortOrder
    rowType?: SortOrder
    title?: SortOrder
    description?: SortOrder
    sortOrder?: SortOrder
    calcType?: SortOrder
    qty?: SortOrder
    unit?: SortOrder
    unitPricePence?: SortOrder
    hours?: SortOrder
    hourlyRatePence?: SortOrder
    sellPricePence?: SortOrder
    isAllowance?: SortOrder
    roomTag?: SortOrder
    tradeTag?: SortOrder
    phaseTag?: SortOrder
    costPence?: SortOrder
    markupPercentBps?: SortOrder
    createdByUserId?: SortOrder
    updatedByUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VariationItemAvgOrderByAggregateInput = {
    sortOrder?: SortOrder
    qty?: SortOrder
    unitPricePence?: SortOrder
    hours?: SortOrder
    hourlyRatePence?: SortOrder
    sellPricePence?: SortOrder
    costPence?: SortOrder
    markupPercentBps?: SortOrder
  }

  export type VariationItemMaxOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    variationId?: SortOrder
    parentId?: SortOrder
    rowType?: SortOrder
    title?: SortOrder
    description?: SortOrder
    sortOrder?: SortOrder
    calcType?: SortOrder
    qty?: SortOrder
    unit?: SortOrder
    unitPricePence?: SortOrder
    hours?: SortOrder
    hourlyRatePence?: SortOrder
    sellPricePence?: SortOrder
    isAllowance?: SortOrder
    roomTag?: SortOrder
    tradeTag?: SortOrder
    phaseTag?: SortOrder
    costPence?: SortOrder
    markupPercentBps?: SortOrder
    createdByUserId?: SortOrder
    updatedByUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VariationItemMinOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    variationId?: SortOrder
    parentId?: SortOrder
    rowType?: SortOrder
    title?: SortOrder
    description?: SortOrder
    sortOrder?: SortOrder
    calcType?: SortOrder
    qty?: SortOrder
    unit?: SortOrder
    unitPricePence?: SortOrder
    hours?: SortOrder
    hourlyRatePence?: SortOrder
    sellPricePence?: SortOrder
    isAllowance?: SortOrder
    roomTag?: SortOrder
    tradeTag?: SortOrder
    phaseTag?: SortOrder
    costPence?: SortOrder
    markupPercentBps?: SortOrder
    createdByUserId?: SortOrder
    updatedByUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VariationItemSumOrderByAggregateInput = {
    sortOrder?: SortOrder
    qty?: SortOrder
    unitPricePence?: SortOrder
    hours?: SortOrder
    hourlyRatePence?: SortOrder
    sellPricePence?: SortOrder
    costPence?: SortOrder
    markupPercentBps?: SortOrder
  }

  export type VariationApprovalVariationIdOrgIdCompoundUniqueInput = {
    variationId: string
    orgId: string
  }

  export type VariationApprovalCountOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    variationId?: SortOrder
    approvedName?: SortOrder
    approvedEmail?: SortOrder
    approvedAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type VariationApprovalMaxOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    variationId?: SortOrder
    approvedName?: SortOrder
    approvedEmail?: SortOrder
    approvedAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type VariationApprovalMinOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    variationId?: SortOrder
    approvedName?: SortOrder
    approvedEmail?: SortOrder
    approvedAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type VariationPublicLinkCountOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    variationId?: SortOrder
    tokenHash?: SortOrder
    tokenPrefix?: SortOrder
    isActive?: SortOrder
    expiresAt?: SortOrder
    revokedAt?: SortOrder
    firstViewedAt?: SortOrder
    lastViewedAt?: SortOrder
    viewCount?: SortOrder
    createdByUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VariationPublicLinkAvgOrderByAggregateInput = {
    viewCount?: SortOrder
  }

  export type VariationPublicLinkMaxOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    variationId?: SortOrder
    tokenHash?: SortOrder
    tokenPrefix?: SortOrder
    isActive?: SortOrder
    expiresAt?: SortOrder
    revokedAt?: SortOrder
    firstViewedAt?: SortOrder
    lastViewedAt?: SortOrder
    viewCount?: SortOrder
    createdByUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VariationPublicLinkMinOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    variationId?: SortOrder
    tokenHash?: SortOrder
    tokenPrefix?: SortOrder
    isActive?: SortOrder
    expiresAt?: SortOrder
    revokedAt?: SortOrder
    firstViewedAt?: SortOrder
    lastViewedAt?: SortOrder
    viewCount?: SortOrder
    createdByUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VariationPublicLinkSumOrderByAggregateInput = {
    viewCount?: SortOrder
  }

  export type EnumVariationPdfStageFilter<$PrismaModel = never> = {
    equals?: $Enums.VariationPdfStage | EnumVariationPdfStageFieldRefInput<$PrismaModel>
    in?: $Enums.VariationPdfStage[] | ListEnumVariationPdfStageFieldRefInput<$PrismaModel>
    notIn?: $Enums.VariationPdfStage[] | ListEnumVariationPdfStageFieldRefInput<$PrismaModel>
    not?: NestedEnumVariationPdfStageFilter<$PrismaModel> | $Enums.VariationPdfStage
  }

  export type VariationPdfVariationIdStageCompoundUniqueInput = {
    variationId: string
    stage: $Enums.VariationPdfStage
  }

  export type VariationPdfCountOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    variationId?: SortOrder
    stage?: SortOrder
    fileUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type VariationPdfMaxOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    variationId?: SortOrder
    stage?: SortOrder
    fileUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type VariationPdfMinOrderByAggregateInput = {
    id?: SortOrder
    orgId?: SortOrder
    variationId?: SortOrder
    stage?: SortOrder
    fileUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumVariationPdfStageWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VariationPdfStage | EnumVariationPdfStageFieldRefInput<$PrismaModel>
    in?: $Enums.VariationPdfStage[] | ListEnumVariationPdfStageFieldRefInput<$PrismaModel>
    notIn?: $Enums.VariationPdfStage[] | ListEnumVariationPdfStageFieldRefInput<$PrismaModel>
    not?: NestedEnumVariationPdfStageWithAggregatesFilter<$PrismaModel> | $Enums.VariationPdfStage
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVariationPdfStageFilter<$PrismaModel>
    _max?: NestedEnumVariationPdfStageFilter<$PrismaModel>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumVatModeFieldUpdateOperationsInput = {
    set?: $Enums.VatMode
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type QuoteCreateNestedManyWithoutClientInput = {
    create?: XOR<QuoteCreateWithoutClientInput, QuoteUncheckedCreateWithoutClientInput> | QuoteCreateWithoutClientInput[] | QuoteUncheckedCreateWithoutClientInput[]
    connectOrCreate?: QuoteCreateOrConnectWithoutClientInput | QuoteCreateOrConnectWithoutClientInput[]
    createMany?: QuoteCreateManyClientInputEnvelope
    connect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
  }

  export type QuoteUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<QuoteCreateWithoutClientInput, QuoteUncheckedCreateWithoutClientInput> | QuoteCreateWithoutClientInput[] | QuoteUncheckedCreateWithoutClientInput[]
    connectOrCreate?: QuoteCreateOrConnectWithoutClientInput | QuoteCreateOrConnectWithoutClientInput[]
    createMany?: QuoteCreateManyClientInputEnvelope
    connect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
  }

  export type QuoteUpdateManyWithoutClientNestedInput = {
    create?: XOR<QuoteCreateWithoutClientInput, QuoteUncheckedCreateWithoutClientInput> | QuoteCreateWithoutClientInput[] | QuoteUncheckedCreateWithoutClientInput[]
    connectOrCreate?: QuoteCreateOrConnectWithoutClientInput | QuoteCreateOrConnectWithoutClientInput[]
    upsert?: QuoteUpsertWithWhereUniqueWithoutClientInput | QuoteUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: QuoteCreateManyClientInputEnvelope
    set?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    disconnect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    delete?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    connect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    update?: QuoteUpdateWithWhereUniqueWithoutClientInput | QuoteUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: QuoteUpdateManyWithWhereWithoutClientInput | QuoteUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: QuoteScalarWhereInput | QuoteScalarWhereInput[]
  }

  export type QuoteUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<QuoteCreateWithoutClientInput, QuoteUncheckedCreateWithoutClientInput> | QuoteCreateWithoutClientInput[] | QuoteUncheckedCreateWithoutClientInput[]
    connectOrCreate?: QuoteCreateOrConnectWithoutClientInput | QuoteCreateOrConnectWithoutClientInput[]
    upsert?: QuoteUpsertWithWhereUniqueWithoutClientInput | QuoteUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: QuoteCreateManyClientInputEnvelope
    set?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    disconnect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    delete?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    connect?: QuoteWhereUniqueInput | QuoteWhereUniqueInput[]
    update?: QuoteUpdateWithWhereUniqueWithoutClientInput | QuoteUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: QuoteUpdateManyWithWhereWithoutClientInput | QuoteUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: QuoteScalarWhereInput | QuoteScalarWhereInput[]
  }

  export type ClientCreateNestedOneWithoutQuotesInput = {
    create?: XOR<ClientCreateWithoutQuotesInput, ClientUncheckedCreateWithoutQuotesInput>
    connectOrCreate?: ClientCreateOrConnectWithoutQuotesInput
    connect?: ClientWhereUniqueInput
  }

  export type QuoteItemCreateNestedManyWithoutQuoteInput = {
    create?: XOR<QuoteItemCreateWithoutQuoteInput, QuoteItemUncheckedCreateWithoutQuoteInput> | QuoteItemCreateWithoutQuoteInput[] | QuoteItemUncheckedCreateWithoutQuoteInput[]
    connectOrCreate?: QuoteItemCreateOrConnectWithoutQuoteInput | QuoteItemCreateOrConnectWithoutQuoteInput[]
    createMany?: QuoteItemCreateManyQuoteInputEnvelope
    connect?: QuoteItemWhereUniqueInput | QuoteItemWhereUniqueInput[]
  }

  export type QuotePublicLinkCreateNestedManyWithoutQuoteInput = {
    create?: XOR<QuotePublicLinkCreateWithoutQuoteInput, QuotePublicLinkUncheckedCreateWithoutQuoteInput> | QuotePublicLinkCreateWithoutQuoteInput[] | QuotePublicLinkUncheckedCreateWithoutQuoteInput[]
    connectOrCreate?: QuotePublicLinkCreateOrConnectWithoutQuoteInput | QuotePublicLinkCreateOrConnectWithoutQuoteInput[]
    createMany?: QuotePublicLinkCreateManyQuoteInputEnvelope
    connect?: QuotePublicLinkWhereUniqueInput | QuotePublicLinkWhereUniqueInput[]
  }

  export type QuotePdfCreateNestedManyWithoutQuoteInput = {
    create?: XOR<QuotePdfCreateWithoutQuoteInput, QuotePdfUncheckedCreateWithoutQuoteInput> | QuotePdfCreateWithoutQuoteInput[] | QuotePdfUncheckedCreateWithoutQuoteInput[]
    connectOrCreate?: QuotePdfCreateOrConnectWithoutQuoteInput | QuotePdfCreateOrConnectWithoutQuoteInput[]
    createMany?: QuotePdfCreateManyQuoteInputEnvelope
    connect?: QuotePdfWhereUniqueInput | QuotePdfWhereUniqueInput[]
  }

  export type QuoteAcceptanceCreateNestedOneWithoutQuoteInput = {
    create?: XOR<QuoteAcceptanceCreateWithoutQuoteInput, QuoteAcceptanceUncheckedCreateWithoutQuoteInput>
    connectOrCreate?: QuoteAcceptanceCreateOrConnectWithoutQuoteInput
    connect?: QuoteAcceptanceWhereUniqueInput
  }

  export type VariationCreateNestedManyWithoutQuoteInput = {
    create?: XOR<VariationCreateWithoutQuoteInput, VariationUncheckedCreateWithoutQuoteInput> | VariationCreateWithoutQuoteInput[] | VariationUncheckedCreateWithoutQuoteInput[]
    connectOrCreate?: VariationCreateOrConnectWithoutQuoteInput | VariationCreateOrConnectWithoutQuoteInput[]
    createMany?: VariationCreateManyQuoteInputEnvelope
    connect?: VariationWhereUniqueInput | VariationWhereUniqueInput[]
  }

  export type QuoteVersionCreateNestedManyWithoutQuoteInput = {
    create?: XOR<QuoteVersionCreateWithoutQuoteInput, QuoteVersionUncheckedCreateWithoutQuoteInput> | QuoteVersionCreateWithoutQuoteInput[] | QuoteVersionUncheckedCreateWithoutQuoteInput[]
    connectOrCreate?: QuoteVersionCreateOrConnectWithoutQuoteInput | QuoteVersionCreateOrConnectWithoutQuoteInput[]
    createMany?: QuoteVersionCreateManyQuoteInputEnvelope
    connect?: QuoteVersionWhereUniqueInput | QuoteVersionWhereUniqueInput[]
  }

  export type QuoteItemUncheckedCreateNestedManyWithoutQuoteInput = {
    create?: XOR<QuoteItemCreateWithoutQuoteInput, QuoteItemUncheckedCreateWithoutQuoteInput> | QuoteItemCreateWithoutQuoteInput[] | QuoteItemUncheckedCreateWithoutQuoteInput[]
    connectOrCreate?: QuoteItemCreateOrConnectWithoutQuoteInput | QuoteItemCreateOrConnectWithoutQuoteInput[]
    createMany?: QuoteItemCreateManyQuoteInputEnvelope
    connect?: QuoteItemWhereUniqueInput | QuoteItemWhereUniqueInput[]
  }

  export type QuotePublicLinkUncheckedCreateNestedManyWithoutQuoteInput = {
    create?: XOR<QuotePublicLinkCreateWithoutQuoteInput, QuotePublicLinkUncheckedCreateWithoutQuoteInput> | QuotePublicLinkCreateWithoutQuoteInput[] | QuotePublicLinkUncheckedCreateWithoutQuoteInput[]
    connectOrCreate?: QuotePublicLinkCreateOrConnectWithoutQuoteInput | QuotePublicLinkCreateOrConnectWithoutQuoteInput[]
    createMany?: QuotePublicLinkCreateManyQuoteInputEnvelope
    connect?: QuotePublicLinkWhereUniqueInput | QuotePublicLinkWhereUniqueInput[]
  }

  export type QuotePdfUncheckedCreateNestedManyWithoutQuoteInput = {
    create?: XOR<QuotePdfCreateWithoutQuoteInput, QuotePdfUncheckedCreateWithoutQuoteInput> | QuotePdfCreateWithoutQuoteInput[] | QuotePdfUncheckedCreateWithoutQuoteInput[]
    connectOrCreate?: QuotePdfCreateOrConnectWithoutQuoteInput | QuotePdfCreateOrConnectWithoutQuoteInput[]
    createMany?: QuotePdfCreateManyQuoteInputEnvelope
    connect?: QuotePdfWhereUniqueInput | QuotePdfWhereUniqueInput[]
  }

  export type QuoteAcceptanceUncheckedCreateNestedOneWithoutQuoteInput = {
    create?: XOR<QuoteAcceptanceCreateWithoutQuoteInput, QuoteAcceptanceUncheckedCreateWithoutQuoteInput>
    connectOrCreate?: QuoteAcceptanceCreateOrConnectWithoutQuoteInput
    connect?: QuoteAcceptanceWhereUniqueInput
  }

  export type VariationUncheckedCreateNestedManyWithoutQuoteInput = {
    create?: XOR<VariationCreateWithoutQuoteInput, VariationUncheckedCreateWithoutQuoteInput> | VariationCreateWithoutQuoteInput[] | VariationUncheckedCreateWithoutQuoteInput[]
    connectOrCreate?: VariationCreateOrConnectWithoutQuoteInput | VariationCreateOrConnectWithoutQuoteInput[]
    createMany?: VariationCreateManyQuoteInputEnvelope
    connect?: VariationWhereUniqueInput | VariationWhereUniqueInput[]
  }

  export type QuoteVersionUncheckedCreateNestedManyWithoutQuoteInput = {
    create?: XOR<QuoteVersionCreateWithoutQuoteInput, QuoteVersionUncheckedCreateWithoutQuoteInput> | QuoteVersionCreateWithoutQuoteInput[] | QuoteVersionUncheckedCreateWithoutQuoteInput[]
    connectOrCreate?: QuoteVersionCreateOrConnectWithoutQuoteInput | QuoteVersionCreateOrConnectWithoutQuoteInput[]
    createMany?: QuoteVersionCreateManyQuoteInputEnvelope
    connect?: QuoteVersionWhereUniqueInput | QuoteVersionWhereUniqueInput[]
  }

  export type EnumQuoteStatusFieldUpdateOperationsInput = {
    set?: $Enums.QuoteStatus
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type EnumDepositTypeFieldUpdateOperationsInput = {
    set?: $Enums.DepositType
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ClientUpdateOneWithoutQuotesNestedInput = {
    create?: XOR<ClientCreateWithoutQuotesInput, ClientUncheckedCreateWithoutQuotesInput>
    connectOrCreate?: ClientCreateOrConnectWithoutQuotesInput
    upsert?: ClientUpsertWithoutQuotesInput
    disconnect?: ClientWhereInput | boolean
    delete?: ClientWhereInput | boolean
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutQuotesInput, ClientUpdateWithoutQuotesInput>, ClientUncheckedUpdateWithoutQuotesInput>
  }

  export type QuoteItemUpdateManyWithoutQuoteNestedInput = {
    create?: XOR<QuoteItemCreateWithoutQuoteInput, QuoteItemUncheckedCreateWithoutQuoteInput> | QuoteItemCreateWithoutQuoteInput[] | QuoteItemUncheckedCreateWithoutQuoteInput[]
    connectOrCreate?: QuoteItemCreateOrConnectWithoutQuoteInput | QuoteItemCreateOrConnectWithoutQuoteInput[]
    upsert?: QuoteItemUpsertWithWhereUniqueWithoutQuoteInput | QuoteItemUpsertWithWhereUniqueWithoutQuoteInput[]
    createMany?: QuoteItemCreateManyQuoteInputEnvelope
    set?: QuoteItemWhereUniqueInput | QuoteItemWhereUniqueInput[]
    disconnect?: QuoteItemWhereUniqueInput | QuoteItemWhereUniqueInput[]
    delete?: QuoteItemWhereUniqueInput | QuoteItemWhereUniqueInput[]
    connect?: QuoteItemWhereUniqueInput | QuoteItemWhereUniqueInput[]
    update?: QuoteItemUpdateWithWhereUniqueWithoutQuoteInput | QuoteItemUpdateWithWhereUniqueWithoutQuoteInput[]
    updateMany?: QuoteItemUpdateManyWithWhereWithoutQuoteInput | QuoteItemUpdateManyWithWhereWithoutQuoteInput[]
    deleteMany?: QuoteItemScalarWhereInput | QuoteItemScalarWhereInput[]
  }

  export type QuotePublicLinkUpdateManyWithoutQuoteNestedInput = {
    create?: XOR<QuotePublicLinkCreateWithoutQuoteInput, QuotePublicLinkUncheckedCreateWithoutQuoteInput> | QuotePublicLinkCreateWithoutQuoteInput[] | QuotePublicLinkUncheckedCreateWithoutQuoteInput[]
    connectOrCreate?: QuotePublicLinkCreateOrConnectWithoutQuoteInput | QuotePublicLinkCreateOrConnectWithoutQuoteInput[]
    upsert?: QuotePublicLinkUpsertWithWhereUniqueWithoutQuoteInput | QuotePublicLinkUpsertWithWhereUniqueWithoutQuoteInput[]
    createMany?: QuotePublicLinkCreateManyQuoteInputEnvelope
    set?: QuotePublicLinkWhereUniqueInput | QuotePublicLinkWhereUniqueInput[]
    disconnect?: QuotePublicLinkWhereUniqueInput | QuotePublicLinkWhereUniqueInput[]
    delete?: QuotePublicLinkWhereUniqueInput | QuotePublicLinkWhereUniqueInput[]
    connect?: QuotePublicLinkWhereUniqueInput | QuotePublicLinkWhereUniqueInput[]
    update?: QuotePublicLinkUpdateWithWhereUniqueWithoutQuoteInput | QuotePublicLinkUpdateWithWhereUniqueWithoutQuoteInput[]
    updateMany?: QuotePublicLinkUpdateManyWithWhereWithoutQuoteInput | QuotePublicLinkUpdateManyWithWhereWithoutQuoteInput[]
    deleteMany?: QuotePublicLinkScalarWhereInput | QuotePublicLinkScalarWhereInput[]
  }

  export type QuotePdfUpdateManyWithoutQuoteNestedInput = {
    create?: XOR<QuotePdfCreateWithoutQuoteInput, QuotePdfUncheckedCreateWithoutQuoteInput> | QuotePdfCreateWithoutQuoteInput[] | QuotePdfUncheckedCreateWithoutQuoteInput[]
    connectOrCreate?: QuotePdfCreateOrConnectWithoutQuoteInput | QuotePdfCreateOrConnectWithoutQuoteInput[]
    upsert?: QuotePdfUpsertWithWhereUniqueWithoutQuoteInput | QuotePdfUpsertWithWhereUniqueWithoutQuoteInput[]
    createMany?: QuotePdfCreateManyQuoteInputEnvelope
    set?: QuotePdfWhereUniqueInput | QuotePdfWhereUniqueInput[]
    disconnect?: QuotePdfWhereUniqueInput | QuotePdfWhereUniqueInput[]
    delete?: QuotePdfWhereUniqueInput | QuotePdfWhereUniqueInput[]
    connect?: QuotePdfWhereUniqueInput | QuotePdfWhereUniqueInput[]
    update?: QuotePdfUpdateWithWhereUniqueWithoutQuoteInput | QuotePdfUpdateWithWhereUniqueWithoutQuoteInput[]
    updateMany?: QuotePdfUpdateManyWithWhereWithoutQuoteInput | QuotePdfUpdateManyWithWhereWithoutQuoteInput[]
    deleteMany?: QuotePdfScalarWhereInput | QuotePdfScalarWhereInput[]
  }

  export type QuoteAcceptanceUpdateOneWithoutQuoteNestedInput = {
    create?: XOR<QuoteAcceptanceCreateWithoutQuoteInput, QuoteAcceptanceUncheckedCreateWithoutQuoteInput>
    connectOrCreate?: QuoteAcceptanceCreateOrConnectWithoutQuoteInput
    upsert?: QuoteAcceptanceUpsertWithoutQuoteInput
    disconnect?: QuoteAcceptanceWhereInput | boolean
    delete?: QuoteAcceptanceWhereInput | boolean
    connect?: QuoteAcceptanceWhereUniqueInput
    update?: XOR<XOR<QuoteAcceptanceUpdateToOneWithWhereWithoutQuoteInput, QuoteAcceptanceUpdateWithoutQuoteInput>, QuoteAcceptanceUncheckedUpdateWithoutQuoteInput>
  }

  export type VariationUpdateManyWithoutQuoteNestedInput = {
    create?: XOR<VariationCreateWithoutQuoteInput, VariationUncheckedCreateWithoutQuoteInput> | VariationCreateWithoutQuoteInput[] | VariationUncheckedCreateWithoutQuoteInput[]
    connectOrCreate?: VariationCreateOrConnectWithoutQuoteInput | VariationCreateOrConnectWithoutQuoteInput[]
    upsert?: VariationUpsertWithWhereUniqueWithoutQuoteInput | VariationUpsertWithWhereUniqueWithoutQuoteInput[]
    createMany?: VariationCreateManyQuoteInputEnvelope
    set?: VariationWhereUniqueInput | VariationWhereUniqueInput[]
    disconnect?: VariationWhereUniqueInput | VariationWhereUniqueInput[]
    delete?: VariationWhereUniqueInput | VariationWhereUniqueInput[]
    connect?: VariationWhereUniqueInput | VariationWhereUniqueInput[]
    update?: VariationUpdateWithWhereUniqueWithoutQuoteInput | VariationUpdateWithWhereUniqueWithoutQuoteInput[]
    updateMany?: VariationUpdateManyWithWhereWithoutQuoteInput | VariationUpdateManyWithWhereWithoutQuoteInput[]
    deleteMany?: VariationScalarWhereInput | VariationScalarWhereInput[]
  }

  export type QuoteVersionUpdateManyWithoutQuoteNestedInput = {
    create?: XOR<QuoteVersionCreateWithoutQuoteInput, QuoteVersionUncheckedCreateWithoutQuoteInput> | QuoteVersionCreateWithoutQuoteInput[] | QuoteVersionUncheckedCreateWithoutQuoteInput[]
    connectOrCreate?: QuoteVersionCreateOrConnectWithoutQuoteInput | QuoteVersionCreateOrConnectWithoutQuoteInput[]
    upsert?: QuoteVersionUpsertWithWhereUniqueWithoutQuoteInput | QuoteVersionUpsertWithWhereUniqueWithoutQuoteInput[]
    createMany?: QuoteVersionCreateManyQuoteInputEnvelope
    set?: QuoteVersionWhereUniqueInput | QuoteVersionWhereUniqueInput[]
    disconnect?: QuoteVersionWhereUniqueInput | QuoteVersionWhereUniqueInput[]
    delete?: QuoteVersionWhereUniqueInput | QuoteVersionWhereUniqueInput[]
    connect?: QuoteVersionWhereUniqueInput | QuoteVersionWhereUniqueInput[]
    update?: QuoteVersionUpdateWithWhereUniqueWithoutQuoteInput | QuoteVersionUpdateWithWhereUniqueWithoutQuoteInput[]
    updateMany?: QuoteVersionUpdateManyWithWhereWithoutQuoteInput | QuoteVersionUpdateManyWithWhereWithoutQuoteInput[]
    deleteMany?: QuoteVersionScalarWhereInput | QuoteVersionScalarWhereInput[]
  }

  export type QuoteItemUncheckedUpdateManyWithoutQuoteNestedInput = {
    create?: XOR<QuoteItemCreateWithoutQuoteInput, QuoteItemUncheckedCreateWithoutQuoteInput> | QuoteItemCreateWithoutQuoteInput[] | QuoteItemUncheckedCreateWithoutQuoteInput[]
    connectOrCreate?: QuoteItemCreateOrConnectWithoutQuoteInput | QuoteItemCreateOrConnectWithoutQuoteInput[]
    upsert?: QuoteItemUpsertWithWhereUniqueWithoutQuoteInput | QuoteItemUpsertWithWhereUniqueWithoutQuoteInput[]
    createMany?: QuoteItemCreateManyQuoteInputEnvelope
    set?: QuoteItemWhereUniqueInput | QuoteItemWhereUniqueInput[]
    disconnect?: QuoteItemWhereUniqueInput | QuoteItemWhereUniqueInput[]
    delete?: QuoteItemWhereUniqueInput | QuoteItemWhereUniqueInput[]
    connect?: QuoteItemWhereUniqueInput | QuoteItemWhereUniqueInput[]
    update?: QuoteItemUpdateWithWhereUniqueWithoutQuoteInput | QuoteItemUpdateWithWhereUniqueWithoutQuoteInput[]
    updateMany?: QuoteItemUpdateManyWithWhereWithoutQuoteInput | QuoteItemUpdateManyWithWhereWithoutQuoteInput[]
    deleteMany?: QuoteItemScalarWhereInput | QuoteItemScalarWhereInput[]
  }

  export type QuotePublicLinkUncheckedUpdateManyWithoutQuoteNestedInput = {
    create?: XOR<QuotePublicLinkCreateWithoutQuoteInput, QuotePublicLinkUncheckedCreateWithoutQuoteInput> | QuotePublicLinkCreateWithoutQuoteInput[] | QuotePublicLinkUncheckedCreateWithoutQuoteInput[]
    connectOrCreate?: QuotePublicLinkCreateOrConnectWithoutQuoteInput | QuotePublicLinkCreateOrConnectWithoutQuoteInput[]
    upsert?: QuotePublicLinkUpsertWithWhereUniqueWithoutQuoteInput | QuotePublicLinkUpsertWithWhereUniqueWithoutQuoteInput[]
    createMany?: QuotePublicLinkCreateManyQuoteInputEnvelope
    set?: QuotePublicLinkWhereUniqueInput | QuotePublicLinkWhereUniqueInput[]
    disconnect?: QuotePublicLinkWhereUniqueInput | QuotePublicLinkWhereUniqueInput[]
    delete?: QuotePublicLinkWhereUniqueInput | QuotePublicLinkWhereUniqueInput[]
    connect?: QuotePublicLinkWhereUniqueInput | QuotePublicLinkWhereUniqueInput[]
    update?: QuotePublicLinkUpdateWithWhereUniqueWithoutQuoteInput | QuotePublicLinkUpdateWithWhereUniqueWithoutQuoteInput[]
    updateMany?: QuotePublicLinkUpdateManyWithWhereWithoutQuoteInput | QuotePublicLinkUpdateManyWithWhereWithoutQuoteInput[]
    deleteMany?: QuotePublicLinkScalarWhereInput | QuotePublicLinkScalarWhereInput[]
  }

  export type QuotePdfUncheckedUpdateManyWithoutQuoteNestedInput = {
    create?: XOR<QuotePdfCreateWithoutQuoteInput, QuotePdfUncheckedCreateWithoutQuoteInput> | QuotePdfCreateWithoutQuoteInput[] | QuotePdfUncheckedCreateWithoutQuoteInput[]
    connectOrCreate?: QuotePdfCreateOrConnectWithoutQuoteInput | QuotePdfCreateOrConnectWithoutQuoteInput[]
    upsert?: QuotePdfUpsertWithWhereUniqueWithoutQuoteInput | QuotePdfUpsertWithWhereUniqueWithoutQuoteInput[]
    createMany?: QuotePdfCreateManyQuoteInputEnvelope
    set?: QuotePdfWhereUniqueInput | QuotePdfWhereUniqueInput[]
    disconnect?: QuotePdfWhereUniqueInput | QuotePdfWhereUniqueInput[]
    delete?: QuotePdfWhereUniqueInput | QuotePdfWhereUniqueInput[]
    connect?: QuotePdfWhereUniqueInput | QuotePdfWhereUniqueInput[]
    update?: QuotePdfUpdateWithWhereUniqueWithoutQuoteInput | QuotePdfUpdateWithWhereUniqueWithoutQuoteInput[]
    updateMany?: QuotePdfUpdateManyWithWhereWithoutQuoteInput | QuotePdfUpdateManyWithWhereWithoutQuoteInput[]
    deleteMany?: QuotePdfScalarWhereInput | QuotePdfScalarWhereInput[]
  }

  export type QuoteAcceptanceUncheckedUpdateOneWithoutQuoteNestedInput = {
    create?: XOR<QuoteAcceptanceCreateWithoutQuoteInput, QuoteAcceptanceUncheckedCreateWithoutQuoteInput>
    connectOrCreate?: QuoteAcceptanceCreateOrConnectWithoutQuoteInput
    upsert?: QuoteAcceptanceUpsertWithoutQuoteInput
    disconnect?: QuoteAcceptanceWhereInput | boolean
    delete?: QuoteAcceptanceWhereInput | boolean
    connect?: QuoteAcceptanceWhereUniqueInput
    update?: XOR<XOR<QuoteAcceptanceUpdateToOneWithWhereWithoutQuoteInput, QuoteAcceptanceUpdateWithoutQuoteInput>, QuoteAcceptanceUncheckedUpdateWithoutQuoteInput>
  }

  export type VariationUncheckedUpdateManyWithoutQuoteNestedInput = {
    create?: XOR<VariationCreateWithoutQuoteInput, VariationUncheckedCreateWithoutQuoteInput> | VariationCreateWithoutQuoteInput[] | VariationUncheckedCreateWithoutQuoteInput[]
    connectOrCreate?: VariationCreateOrConnectWithoutQuoteInput | VariationCreateOrConnectWithoutQuoteInput[]
    upsert?: VariationUpsertWithWhereUniqueWithoutQuoteInput | VariationUpsertWithWhereUniqueWithoutQuoteInput[]
    createMany?: VariationCreateManyQuoteInputEnvelope
    set?: VariationWhereUniqueInput | VariationWhereUniqueInput[]
    disconnect?: VariationWhereUniqueInput | VariationWhereUniqueInput[]
    delete?: VariationWhereUniqueInput | VariationWhereUniqueInput[]
    connect?: VariationWhereUniqueInput | VariationWhereUniqueInput[]
    update?: VariationUpdateWithWhereUniqueWithoutQuoteInput | VariationUpdateWithWhereUniqueWithoutQuoteInput[]
    updateMany?: VariationUpdateManyWithWhereWithoutQuoteInput | VariationUpdateManyWithWhereWithoutQuoteInput[]
    deleteMany?: VariationScalarWhereInput | VariationScalarWhereInput[]
  }

  export type QuoteVersionUncheckedUpdateManyWithoutQuoteNestedInput = {
    create?: XOR<QuoteVersionCreateWithoutQuoteInput, QuoteVersionUncheckedCreateWithoutQuoteInput> | QuoteVersionCreateWithoutQuoteInput[] | QuoteVersionUncheckedCreateWithoutQuoteInput[]
    connectOrCreate?: QuoteVersionCreateOrConnectWithoutQuoteInput | QuoteVersionCreateOrConnectWithoutQuoteInput[]
    upsert?: QuoteVersionUpsertWithWhereUniqueWithoutQuoteInput | QuoteVersionUpsertWithWhereUniqueWithoutQuoteInput[]
    createMany?: QuoteVersionCreateManyQuoteInputEnvelope
    set?: QuoteVersionWhereUniqueInput | QuoteVersionWhereUniqueInput[]
    disconnect?: QuoteVersionWhereUniqueInput | QuoteVersionWhereUniqueInput[]
    delete?: QuoteVersionWhereUniqueInput | QuoteVersionWhereUniqueInput[]
    connect?: QuoteVersionWhereUniqueInput | QuoteVersionWhereUniqueInput[]
    update?: QuoteVersionUpdateWithWhereUniqueWithoutQuoteInput | QuoteVersionUpdateWithWhereUniqueWithoutQuoteInput[]
    updateMany?: QuoteVersionUpdateManyWithWhereWithoutQuoteInput | QuoteVersionUpdateManyWithWhereWithoutQuoteInput[]
    deleteMany?: QuoteVersionScalarWhereInput | QuoteVersionScalarWhereInput[]
  }

  export type QuoteCreateNestedOneWithoutItemsInput = {
    create?: XOR<QuoteCreateWithoutItemsInput, QuoteUncheckedCreateWithoutItemsInput>
    connectOrCreate?: QuoteCreateOrConnectWithoutItemsInput
    connect?: QuoteWhereUniqueInput
  }

  export type QuoteItemCreateNestedOneWithoutChildrenInput = {
    create?: XOR<QuoteItemCreateWithoutChildrenInput, QuoteItemUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: QuoteItemCreateOrConnectWithoutChildrenInput
    connect?: QuoteItemWhereUniqueInput
  }

  export type QuoteItemCreateNestedManyWithoutParentInput = {
    create?: XOR<QuoteItemCreateWithoutParentInput, QuoteItemUncheckedCreateWithoutParentInput> | QuoteItemCreateWithoutParentInput[] | QuoteItemUncheckedCreateWithoutParentInput[]
    connectOrCreate?: QuoteItemCreateOrConnectWithoutParentInput | QuoteItemCreateOrConnectWithoutParentInput[]
    createMany?: QuoteItemCreateManyParentInputEnvelope
    connect?: QuoteItemWhereUniqueInput | QuoteItemWhereUniqueInput[]
  }

  export type QuoteItemUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<QuoteItemCreateWithoutParentInput, QuoteItemUncheckedCreateWithoutParentInput> | QuoteItemCreateWithoutParentInput[] | QuoteItemUncheckedCreateWithoutParentInput[]
    connectOrCreate?: QuoteItemCreateOrConnectWithoutParentInput | QuoteItemCreateOrConnectWithoutParentInput[]
    createMany?: QuoteItemCreateManyParentInputEnvelope
    connect?: QuoteItemWhereUniqueInput | QuoteItemWhereUniqueInput[]
  }

  export type EnumItemRowTypeFieldUpdateOperationsInput = {
    set?: $Enums.ItemRowType
  }

  export type EnumCalcTypeFieldUpdateOperationsInput = {
    set?: $Enums.CalcType
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type QuoteUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<QuoteCreateWithoutItemsInput, QuoteUncheckedCreateWithoutItemsInput>
    connectOrCreate?: QuoteCreateOrConnectWithoutItemsInput
    upsert?: QuoteUpsertWithoutItemsInput
    connect?: QuoteWhereUniqueInput
    update?: XOR<XOR<QuoteUpdateToOneWithWhereWithoutItemsInput, QuoteUpdateWithoutItemsInput>, QuoteUncheckedUpdateWithoutItemsInput>
  }

  export type QuoteItemUpdateOneWithoutChildrenNestedInput = {
    create?: XOR<QuoteItemCreateWithoutChildrenInput, QuoteItemUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: QuoteItemCreateOrConnectWithoutChildrenInput
    upsert?: QuoteItemUpsertWithoutChildrenInput
    disconnect?: QuoteItemWhereInput | boolean
    delete?: QuoteItemWhereInput | boolean
    connect?: QuoteItemWhereUniqueInput
    update?: XOR<XOR<QuoteItemUpdateToOneWithWhereWithoutChildrenInput, QuoteItemUpdateWithoutChildrenInput>, QuoteItemUncheckedUpdateWithoutChildrenInput>
  }

  export type QuoteItemUpdateManyWithoutParentNestedInput = {
    create?: XOR<QuoteItemCreateWithoutParentInput, QuoteItemUncheckedCreateWithoutParentInput> | QuoteItemCreateWithoutParentInput[] | QuoteItemUncheckedCreateWithoutParentInput[]
    connectOrCreate?: QuoteItemCreateOrConnectWithoutParentInput | QuoteItemCreateOrConnectWithoutParentInput[]
    upsert?: QuoteItemUpsertWithWhereUniqueWithoutParentInput | QuoteItemUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: QuoteItemCreateManyParentInputEnvelope
    set?: QuoteItemWhereUniqueInput | QuoteItemWhereUniqueInput[]
    disconnect?: QuoteItemWhereUniqueInput | QuoteItemWhereUniqueInput[]
    delete?: QuoteItemWhereUniqueInput | QuoteItemWhereUniqueInput[]
    connect?: QuoteItemWhereUniqueInput | QuoteItemWhereUniqueInput[]
    update?: QuoteItemUpdateWithWhereUniqueWithoutParentInput | QuoteItemUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: QuoteItemUpdateManyWithWhereWithoutParentInput | QuoteItemUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: QuoteItemScalarWhereInput | QuoteItemScalarWhereInput[]
  }

  export type QuoteItemUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<QuoteItemCreateWithoutParentInput, QuoteItemUncheckedCreateWithoutParentInput> | QuoteItemCreateWithoutParentInput[] | QuoteItemUncheckedCreateWithoutParentInput[]
    connectOrCreate?: QuoteItemCreateOrConnectWithoutParentInput | QuoteItemCreateOrConnectWithoutParentInput[]
    upsert?: QuoteItemUpsertWithWhereUniqueWithoutParentInput | QuoteItemUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: QuoteItemCreateManyParentInputEnvelope
    set?: QuoteItemWhereUniqueInput | QuoteItemWhereUniqueInput[]
    disconnect?: QuoteItemWhereUniqueInput | QuoteItemWhereUniqueInput[]
    delete?: QuoteItemWhereUniqueInput | QuoteItemWhereUniqueInput[]
    connect?: QuoteItemWhereUniqueInput | QuoteItemWhereUniqueInput[]
    update?: QuoteItemUpdateWithWhereUniqueWithoutParentInput | QuoteItemUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: QuoteItemUpdateManyWithWhereWithoutParentInput | QuoteItemUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: QuoteItemScalarWhereInput | QuoteItemScalarWhereInput[]
  }

  export type QuoteCreateNestedOneWithoutVersionsInput = {
    create?: XOR<QuoteCreateWithoutVersionsInput, QuoteUncheckedCreateWithoutVersionsInput>
    connectOrCreate?: QuoteCreateOrConnectWithoutVersionsInput
    connect?: QuoteWhereUniqueInput
  }

  export type QuoteVersionItemCreateNestedManyWithoutQuoteVersionInput = {
    create?: XOR<QuoteVersionItemCreateWithoutQuoteVersionInput, QuoteVersionItemUncheckedCreateWithoutQuoteVersionInput> | QuoteVersionItemCreateWithoutQuoteVersionInput[] | QuoteVersionItemUncheckedCreateWithoutQuoteVersionInput[]
    connectOrCreate?: QuoteVersionItemCreateOrConnectWithoutQuoteVersionInput | QuoteVersionItemCreateOrConnectWithoutQuoteVersionInput[]
    createMany?: QuoteVersionItemCreateManyQuoteVersionInputEnvelope
    connect?: QuoteVersionItemWhereUniqueInput | QuoteVersionItemWhereUniqueInput[]
  }

  export type QuoteVersionItemUncheckedCreateNestedManyWithoutQuoteVersionInput = {
    create?: XOR<QuoteVersionItemCreateWithoutQuoteVersionInput, QuoteVersionItemUncheckedCreateWithoutQuoteVersionInput> | QuoteVersionItemCreateWithoutQuoteVersionInput[] | QuoteVersionItemUncheckedCreateWithoutQuoteVersionInput[]
    connectOrCreate?: QuoteVersionItemCreateOrConnectWithoutQuoteVersionInput | QuoteVersionItemCreateOrConnectWithoutQuoteVersionInput[]
    createMany?: QuoteVersionItemCreateManyQuoteVersionInputEnvelope
    connect?: QuoteVersionItemWhereUniqueInput | QuoteVersionItemWhereUniqueInput[]
  }

  export type QuoteUpdateOneRequiredWithoutVersionsNestedInput = {
    create?: XOR<QuoteCreateWithoutVersionsInput, QuoteUncheckedCreateWithoutVersionsInput>
    connectOrCreate?: QuoteCreateOrConnectWithoutVersionsInput
    upsert?: QuoteUpsertWithoutVersionsInput
    connect?: QuoteWhereUniqueInput
    update?: XOR<XOR<QuoteUpdateToOneWithWhereWithoutVersionsInput, QuoteUpdateWithoutVersionsInput>, QuoteUncheckedUpdateWithoutVersionsInput>
  }

  export type QuoteVersionItemUpdateManyWithoutQuoteVersionNestedInput = {
    create?: XOR<QuoteVersionItemCreateWithoutQuoteVersionInput, QuoteVersionItemUncheckedCreateWithoutQuoteVersionInput> | QuoteVersionItemCreateWithoutQuoteVersionInput[] | QuoteVersionItemUncheckedCreateWithoutQuoteVersionInput[]
    connectOrCreate?: QuoteVersionItemCreateOrConnectWithoutQuoteVersionInput | QuoteVersionItemCreateOrConnectWithoutQuoteVersionInput[]
    upsert?: QuoteVersionItemUpsertWithWhereUniqueWithoutQuoteVersionInput | QuoteVersionItemUpsertWithWhereUniqueWithoutQuoteVersionInput[]
    createMany?: QuoteVersionItemCreateManyQuoteVersionInputEnvelope
    set?: QuoteVersionItemWhereUniqueInput | QuoteVersionItemWhereUniqueInput[]
    disconnect?: QuoteVersionItemWhereUniqueInput | QuoteVersionItemWhereUniqueInput[]
    delete?: QuoteVersionItemWhereUniqueInput | QuoteVersionItemWhereUniqueInput[]
    connect?: QuoteVersionItemWhereUniqueInput | QuoteVersionItemWhereUniqueInput[]
    update?: QuoteVersionItemUpdateWithWhereUniqueWithoutQuoteVersionInput | QuoteVersionItemUpdateWithWhereUniqueWithoutQuoteVersionInput[]
    updateMany?: QuoteVersionItemUpdateManyWithWhereWithoutQuoteVersionInput | QuoteVersionItemUpdateManyWithWhereWithoutQuoteVersionInput[]
    deleteMany?: QuoteVersionItemScalarWhereInput | QuoteVersionItemScalarWhereInput[]
  }

  export type QuoteVersionItemUncheckedUpdateManyWithoutQuoteVersionNestedInput = {
    create?: XOR<QuoteVersionItemCreateWithoutQuoteVersionInput, QuoteVersionItemUncheckedCreateWithoutQuoteVersionInput> | QuoteVersionItemCreateWithoutQuoteVersionInput[] | QuoteVersionItemUncheckedCreateWithoutQuoteVersionInput[]
    connectOrCreate?: QuoteVersionItemCreateOrConnectWithoutQuoteVersionInput | QuoteVersionItemCreateOrConnectWithoutQuoteVersionInput[]
    upsert?: QuoteVersionItemUpsertWithWhereUniqueWithoutQuoteVersionInput | QuoteVersionItemUpsertWithWhereUniqueWithoutQuoteVersionInput[]
    createMany?: QuoteVersionItemCreateManyQuoteVersionInputEnvelope
    set?: QuoteVersionItemWhereUniqueInput | QuoteVersionItemWhereUniqueInput[]
    disconnect?: QuoteVersionItemWhereUniqueInput | QuoteVersionItemWhereUniqueInput[]
    delete?: QuoteVersionItemWhereUniqueInput | QuoteVersionItemWhereUniqueInput[]
    connect?: QuoteVersionItemWhereUniqueInput | QuoteVersionItemWhereUniqueInput[]
    update?: QuoteVersionItemUpdateWithWhereUniqueWithoutQuoteVersionInput | QuoteVersionItemUpdateWithWhereUniqueWithoutQuoteVersionInput[]
    updateMany?: QuoteVersionItemUpdateManyWithWhereWithoutQuoteVersionInput | QuoteVersionItemUpdateManyWithWhereWithoutQuoteVersionInput[]
    deleteMany?: QuoteVersionItemScalarWhereInput | QuoteVersionItemScalarWhereInput[]
  }

  export type QuoteVersionCreateNestedOneWithoutItemsInput = {
    create?: XOR<QuoteVersionCreateWithoutItemsInput, QuoteVersionUncheckedCreateWithoutItemsInput>
    connectOrCreate?: QuoteVersionCreateOrConnectWithoutItemsInput
    connect?: QuoteVersionWhereUniqueInput
  }

  export type QuoteVersionItemCreateNestedOneWithoutChildrenInput = {
    create?: XOR<QuoteVersionItemCreateWithoutChildrenInput, QuoteVersionItemUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: QuoteVersionItemCreateOrConnectWithoutChildrenInput
    connect?: QuoteVersionItemWhereUniqueInput
  }

  export type QuoteVersionItemCreateNestedManyWithoutParentInput = {
    create?: XOR<QuoteVersionItemCreateWithoutParentInput, QuoteVersionItemUncheckedCreateWithoutParentInput> | QuoteVersionItemCreateWithoutParentInput[] | QuoteVersionItemUncheckedCreateWithoutParentInput[]
    connectOrCreate?: QuoteVersionItemCreateOrConnectWithoutParentInput | QuoteVersionItemCreateOrConnectWithoutParentInput[]
    createMany?: QuoteVersionItemCreateManyParentInputEnvelope
    connect?: QuoteVersionItemWhereUniqueInput | QuoteVersionItemWhereUniqueInput[]
  }

  export type QuoteVersionItemUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<QuoteVersionItemCreateWithoutParentInput, QuoteVersionItemUncheckedCreateWithoutParentInput> | QuoteVersionItemCreateWithoutParentInput[] | QuoteVersionItemUncheckedCreateWithoutParentInput[]
    connectOrCreate?: QuoteVersionItemCreateOrConnectWithoutParentInput | QuoteVersionItemCreateOrConnectWithoutParentInput[]
    createMany?: QuoteVersionItemCreateManyParentInputEnvelope
    connect?: QuoteVersionItemWhereUniqueInput | QuoteVersionItemWhereUniqueInput[]
  }

  export type QuoteVersionUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<QuoteVersionCreateWithoutItemsInput, QuoteVersionUncheckedCreateWithoutItemsInput>
    connectOrCreate?: QuoteVersionCreateOrConnectWithoutItemsInput
    upsert?: QuoteVersionUpsertWithoutItemsInput
    connect?: QuoteVersionWhereUniqueInput
    update?: XOR<XOR<QuoteVersionUpdateToOneWithWhereWithoutItemsInput, QuoteVersionUpdateWithoutItemsInput>, QuoteVersionUncheckedUpdateWithoutItemsInput>
  }

  export type QuoteVersionItemUpdateOneWithoutChildrenNestedInput = {
    create?: XOR<QuoteVersionItemCreateWithoutChildrenInput, QuoteVersionItemUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: QuoteVersionItemCreateOrConnectWithoutChildrenInput
    upsert?: QuoteVersionItemUpsertWithoutChildrenInput
    disconnect?: QuoteVersionItemWhereInput | boolean
    delete?: QuoteVersionItemWhereInput | boolean
    connect?: QuoteVersionItemWhereUniqueInput
    update?: XOR<XOR<QuoteVersionItemUpdateToOneWithWhereWithoutChildrenInput, QuoteVersionItemUpdateWithoutChildrenInput>, QuoteVersionItemUncheckedUpdateWithoutChildrenInput>
  }

  export type QuoteVersionItemUpdateManyWithoutParentNestedInput = {
    create?: XOR<QuoteVersionItemCreateWithoutParentInput, QuoteVersionItemUncheckedCreateWithoutParentInput> | QuoteVersionItemCreateWithoutParentInput[] | QuoteVersionItemUncheckedCreateWithoutParentInput[]
    connectOrCreate?: QuoteVersionItemCreateOrConnectWithoutParentInput | QuoteVersionItemCreateOrConnectWithoutParentInput[]
    upsert?: QuoteVersionItemUpsertWithWhereUniqueWithoutParentInput | QuoteVersionItemUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: QuoteVersionItemCreateManyParentInputEnvelope
    set?: QuoteVersionItemWhereUniqueInput | QuoteVersionItemWhereUniqueInput[]
    disconnect?: QuoteVersionItemWhereUniqueInput | QuoteVersionItemWhereUniqueInput[]
    delete?: QuoteVersionItemWhereUniqueInput | QuoteVersionItemWhereUniqueInput[]
    connect?: QuoteVersionItemWhereUniqueInput | QuoteVersionItemWhereUniqueInput[]
    update?: QuoteVersionItemUpdateWithWhereUniqueWithoutParentInput | QuoteVersionItemUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: QuoteVersionItemUpdateManyWithWhereWithoutParentInput | QuoteVersionItemUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: QuoteVersionItemScalarWhereInput | QuoteVersionItemScalarWhereInput[]
  }

  export type QuoteVersionItemUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<QuoteVersionItemCreateWithoutParentInput, QuoteVersionItemUncheckedCreateWithoutParentInput> | QuoteVersionItemCreateWithoutParentInput[] | QuoteVersionItemUncheckedCreateWithoutParentInput[]
    connectOrCreate?: QuoteVersionItemCreateOrConnectWithoutParentInput | QuoteVersionItemCreateOrConnectWithoutParentInput[]
    upsert?: QuoteVersionItemUpsertWithWhereUniqueWithoutParentInput | QuoteVersionItemUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: QuoteVersionItemCreateManyParentInputEnvelope
    set?: QuoteVersionItemWhereUniqueInput | QuoteVersionItemWhereUniqueInput[]
    disconnect?: QuoteVersionItemWhereUniqueInput | QuoteVersionItemWhereUniqueInput[]
    delete?: QuoteVersionItemWhereUniqueInput | QuoteVersionItemWhereUniqueInput[]
    connect?: QuoteVersionItemWhereUniqueInput | QuoteVersionItemWhereUniqueInput[]
    update?: QuoteVersionItemUpdateWithWhereUniqueWithoutParentInput | QuoteVersionItemUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: QuoteVersionItemUpdateManyWithWhereWithoutParentInput | QuoteVersionItemUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: QuoteVersionItemScalarWhereInput | QuoteVersionItemScalarWhereInput[]
  }

  export type QuoteCreateNestedOneWithoutPublicLinksInput = {
    create?: XOR<QuoteCreateWithoutPublicLinksInput, QuoteUncheckedCreateWithoutPublicLinksInput>
    connectOrCreate?: QuoteCreateOrConnectWithoutPublicLinksInput
    connect?: QuoteWhereUniqueInput
  }

  export type QuoteUpdateOneRequiredWithoutPublicLinksNestedInput = {
    create?: XOR<QuoteCreateWithoutPublicLinksInput, QuoteUncheckedCreateWithoutPublicLinksInput>
    connectOrCreate?: QuoteCreateOrConnectWithoutPublicLinksInput
    upsert?: QuoteUpsertWithoutPublicLinksInput
    connect?: QuoteWhereUniqueInput
    update?: XOR<XOR<QuoteUpdateToOneWithWhereWithoutPublicLinksInput, QuoteUpdateWithoutPublicLinksInput>, QuoteUncheckedUpdateWithoutPublicLinksInput>
  }

  export type QuoteCreateNestedOneWithoutPdfsInput = {
    create?: XOR<QuoteCreateWithoutPdfsInput, QuoteUncheckedCreateWithoutPdfsInput>
    connectOrCreate?: QuoteCreateOrConnectWithoutPdfsInput
    connect?: QuoteWhereUniqueInput
  }

  export type QuoteUpdateOneRequiredWithoutPdfsNestedInput = {
    create?: XOR<QuoteCreateWithoutPdfsInput, QuoteUncheckedCreateWithoutPdfsInput>
    connectOrCreate?: QuoteCreateOrConnectWithoutPdfsInput
    upsert?: QuoteUpsertWithoutPdfsInput
    connect?: QuoteWhereUniqueInput
    update?: XOR<XOR<QuoteUpdateToOneWithWhereWithoutPdfsInput, QuoteUpdateWithoutPdfsInput>, QuoteUncheckedUpdateWithoutPdfsInput>
  }

  export type QuoteCreateNestedOneWithoutAcceptanceInput = {
    create?: XOR<QuoteCreateWithoutAcceptanceInput, QuoteUncheckedCreateWithoutAcceptanceInput>
    connectOrCreate?: QuoteCreateOrConnectWithoutAcceptanceInput
    connect?: QuoteWhereUniqueInput
  }

  export type QuoteUpdateOneRequiredWithoutAcceptanceNestedInput = {
    create?: XOR<QuoteCreateWithoutAcceptanceInput, QuoteUncheckedCreateWithoutAcceptanceInput>
    connectOrCreate?: QuoteCreateOrConnectWithoutAcceptanceInput
    upsert?: QuoteUpsertWithoutAcceptanceInput
    connect?: QuoteWhereUniqueInput
    update?: XOR<XOR<QuoteUpdateToOneWithWhereWithoutAcceptanceInput, QuoteUpdateWithoutAcceptanceInput>, QuoteUncheckedUpdateWithoutAcceptanceInput>
  }

  export type TemplateSectionItemCreateNestedManyWithoutTemplateSectionInput = {
    create?: XOR<TemplateSectionItemCreateWithoutTemplateSectionInput, TemplateSectionItemUncheckedCreateWithoutTemplateSectionInput> | TemplateSectionItemCreateWithoutTemplateSectionInput[] | TemplateSectionItemUncheckedCreateWithoutTemplateSectionInput[]
    connectOrCreate?: TemplateSectionItemCreateOrConnectWithoutTemplateSectionInput | TemplateSectionItemCreateOrConnectWithoutTemplateSectionInput[]
    createMany?: TemplateSectionItemCreateManyTemplateSectionInputEnvelope
    connect?: TemplateSectionItemWhereUniqueInput | TemplateSectionItemWhereUniqueInput[]
  }

  export type TemplateSectionItemUncheckedCreateNestedManyWithoutTemplateSectionInput = {
    create?: XOR<TemplateSectionItemCreateWithoutTemplateSectionInput, TemplateSectionItemUncheckedCreateWithoutTemplateSectionInput> | TemplateSectionItemCreateWithoutTemplateSectionInput[] | TemplateSectionItemUncheckedCreateWithoutTemplateSectionInput[]
    connectOrCreate?: TemplateSectionItemCreateOrConnectWithoutTemplateSectionInput | TemplateSectionItemCreateOrConnectWithoutTemplateSectionInput[]
    createMany?: TemplateSectionItemCreateManyTemplateSectionInputEnvelope
    connect?: TemplateSectionItemWhereUniqueInput | TemplateSectionItemWhereUniqueInput[]
  }

  export type TemplateSectionItemUpdateManyWithoutTemplateSectionNestedInput = {
    create?: XOR<TemplateSectionItemCreateWithoutTemplateSectionInput, TemplateSectionItemUncheckedCreateWithoutTemplateSectionInput> | TemplateSectionItemCreateWithoutTemplateSectionInput[] | TemplateSectionItemUncheckedCreateWithoutTemplateSectionInput[]
    connectOrCreate?: TemplateSectionItemCreateOrConnectWithoutTemplateSectionInput | TemplateSectionItemCreateOrConnectWithoutTemplateSectionInput[]
    upsert?: TemplateSectionItemUpsertWithWhereUniqueWithoutTemplateSectionInput | TemplateSectionItemUpsertWithWhereUniqueWithoutTemplateSectionInput[]
    createMany?: TemplateSectionItemCreateManyTemplateSectionInputEnvelope
    set?: TemplateSectionItemWhereUniqueInput | TemplateSectionItemWhereUniqueInput[]
    disconnect?: TemplateSectionItemWhereUniqueInput | TemplateSectionItemWhereUniqueInput[]
    delete?: TemplateSectionItemWhereUniqueInput | TemplateSectionItemWhereUniqueInput[]
    connect?: TemplateSectionItemWhereUniqueInput | TemplateSectionItemWhereUniqueInput[]
    update?: TemplateSectionItemUpdateWithWhereUniqueWithoutTemplateSectionInput | TemplateSectionItemUpdateWithWhereUniqueWithoutTemplateSectionInput[]
    updateMany?: TemplateSectionItemUpdateManyWithWhereWithoutTemplateSectionInput | TemplateSectionItemUpdateManyWithWhereWithoutTemplateSectionInput[]
    deleteMany?: TemplateSectionItemScalarWhereInput | TemplateSectionItemScalarWhereInput[]
  }

  export type TemplateSectionItemUncheckedUpdateManyWithoutTemplateSectionNestedInput = {
    create?: XOR<TemplateSectionItemCreateWithoutTemplateSectionInput, TemplateSectionItemUncheckedCreateWithoutTemplateSectionInput> | TemplateSectionItemCreateWithoutTemplateSectionInput[] | TemplateSectionItemUncheckedCreateWithoutTemplateSectionInput[]
    connectOrCreate?: TemplateSectionItemCreateOrConnectWithoutTemplateSectionInput | TemplateSectionItemCreateOrConnectWithoutTemplateSectionInput[]
    upsert?: TemplateSectionItemUpsertWithWhereUniqueWithoutTemplateSectionInput | TemplateSectionItemUpsertWithWhereUniqueWithoutTemplateSectionInput[]
    createMany?: TemplateSectionItemCreateManyTemplateSectionInputEnvelope
    set?: TemplateSectionItemWhereUniqueInput | TemplateSectionItemWhereUniqueInput[]
    disconnect?: TemplateSectionItemWhereUniqueInput | TemplateSectionItemWhereUniqueInput[]
    delete?: TemplateSectionItemWhereUniqueInput | TemplateSectionItemWhereUniqueInput[]
    connect?: TemplateSectionItemWhereUniqueInput | TemplateSectionItemWhereUniqueInput[]
    update?: TemplateSectionItemUpdateWithWhereUniqueWithoutTemplateSectionInput | TemplateSectionItemUpdateWithWhereUniqueWithoutTemplateSectionInput[]
    updateMany?: TemplateSectionItemUpdateManyWithWhereWithoutTemplateSectionInput | TemplateSectionItemUpdateManyWithWhereWithoutTemplateSectionInput[]
    deleteMany?: TemplateSectionItemScalarWhereInput | TemplateSectionItemScalarWhereInput[]
  }

  export type TemplateSectionCreateNestedOneWithoutItemsInput = {
    create?: XOR<TemplateSectionCreateWithoutItemsInput, TemplateSectionUncheckedCreateWithoutItemsInput>
    connectOrCreate?: TemplateSectionCreateOrConnectWithoutItemsInput
    connect?: TemplateSectionWhereUniqueInput
  }

  export type TemplateSectionUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<TemplateSectionCreateWithoutItemsInput, TemplateSectionUncheckedCreateWithoutItemsInput>
    connectOrCreate?: TemplateSectionCreateOrConnectWithoutItemsInput
    upsert?: TemplateSectionUpsertWithoutItemsInput
    connect?: TemplateSectionWhereUniqueInput
    update?: XOR<XOR<TemplateSectionUpdateToOneWithWhereWithoutItemsInput, TemplateSectionUpdateWithoutItemsInput>, TemplateSectionUncheckedUpdateWithoutItemsInput>
  }

  export type QuoteCreateNestedOneWithoutVariationsInput = {
    create?: XOR<QuoteCreateWithoutVariationsInput, QuoteUncheckedCreateWithoutVariationsInput>
    connectOrCreate?: QuoteCreateOrConnectWithoutVariationsInput
    connect?: QuoteWhereUniqueInput
  }

  export type VariationPublicLinkCreateNestedManyWithoutVariationInput = {
    create?: XOR<VariationPublicLinkCreateWithoutVariationInput, VariationPublicLinkUncheckedCreateWithoutVariationInput> | VariationPublicLinkCreateWithoutVariationInput[] | VariationPublicLinkUncheckedCreateWithoutVariationInput[]
    connectOrCreate?: VariationPublicLinkCreateOrConnectWithoutVariationInput | VariationPublicLinkCreateOrConnectWithoutVariationInput[]
    createMany?: VariationPublicLinkCreateManyVariationInputEnvelope
    connect?: VariationPublicLinkWhereUniqueInput | VariationPublicLinkWhereUniqueInput[]
  }

  export type VariationItemCreateNestedManyWithoutVariationInput = {
    create?: XOR<VariationItemCreateWithoutVariationInput, VariationItemUncheckedCreateWithoutVariationInput> | VariationItemCreateWithoutVariationInput[] | VariationItemUncheckedCreateWithoutVariationInput[]
    connectOrCreate?: VariationItemCreateOrConnectWithoutVariationInput | VariationItemCreateOrConnectWithoutVariationInput[]
    createMany?: VariationItemCreateManyVariationInputEnvelope
    connect?: VariationItemWhereUniqueInput | VariationItemWhereUniqueInput[]
  }

  export type VariationApprovalCreateNestedOneWithoutVariationInput = {
    create?: XOR<VariationApprovalCreateWithoutVariationInput, VariationApprovalUncheckedCreateWithoutVariationInput>
    connectOrCreate?: VariationApprovalCreateOrConnectWithoutVariationInput
    connect?: VariationApprovalWhereUniqueInput
  }

  export type VariationPdfCreateNestedManyWithoutVariationInput = {
    create?: XOR<VariationPdfCreateWithoutVariationInput, VariationPdfUncheckedCreateWithoutVariationInput> | VariationPdfCreateWithoutVariationInput[] | VariationPdfUncheckedCreateWithoutVariationInput[]
    connectOrCreate?: VariationPdfCreateOrConnectWithoutVariationInput | VariationPdfCreateOrConnectWithoutVariationInput[]
    createMany?: VariationPdfCreateManyVariationInputEnvelope
    connect?: VariationPdfWhereUniqueInput | VariationPdfWhereUniqueInput[]
  }

  export type VariationPublicLinkUncheckedCreateNestedManyWithoutVariationInput = {
    create?: XOR<VariationPublicLinkCreateWithoutVariationInput, VariationPublicLinkUncheckedCreateWithoutVariationInput> | VariationPublicLinkCreateWithoutVariationInput[] | VariationPublicLinkUncheckedCreateWithoutVariationInput[]
    connectOrCreate?: VariationPublicLinkCreateOrConnectWithoutVariationInput | VariationPublicLinkCreateOrConnectWithoutVariationInput[]
    createMany?: VariationPublicLinkCreateManyVariationInputEnvelope
    connect?: VariationPublicLinkWhereUniqueInput | VariationPublicLinkWhereUniqueInput[]
  }

  export type VariationItemUncheckedCreateNestedManyWithoutVariationInput = {
    create?: XOR<VariationItemCreateWithoutVariationInput, VariationItemUncheckedCreateWithoutVariationInput> | VariationItemCreateWithoutVariationInput[] | VariationItemUncheckedCreateWithoutVariationInput[]
    connectOrCreate?: VariationItemCreateOrConnectWithoutVariationInput | VariationItemCreateOrConnectWithoutVariationInput[]
    createMany?: VariationItemCreateManyVariationInputEnvelope
    connect?: VariationItemWhereUniqueInput | VariationItemWhereUniqueInput[]
  }

  export type VariationApprovalUncheckedCreateNestedOneWithoutVariationInput = {
    create?: XOR<VariationApprovalCreateWithoutVariationInput, VariationApprovalUncheckedCreateWithoutVariationInput>
    connectOrCreate?: VariationApprovalCreateOrConnectWithoutVariationInput
    connect?: VariationApprovalWhereUniqueInput
  }

  export type VariationPdfUncheckedCreateNestedManyWithoutVariationInput = {
    create?: XOR<VariationPdfCreateWithoutVariationInput, VariationPdfUncheckedCreateWithoutVariationInput> | VariationPdfCreateWithoutVariationInput[] | VariationPdfUncheckedCreateWithoutVariationInput[]
    connectOrCreate?: VariationPdfCreateOrConnectWithoutVariationInput | VariationPdfCreateOrConnectWithoutVariationInput[]
    createMany?: VariationPdfCreateManyVariationInputEnvelope
    connect?: VariationPdfWhereUniqueInput | VariationPdfWhereUniqueInput[]
  }

  export type EnumVariationStatusFieldUpdateOperationsInput = {
    set?: $Enums.VariationStatus
  }

  export type QuoteUpdateOneRequiredWithoutVariationsNestedInput = {
    create?: XOR<QuoteCreateWithoutVariationsInput, QuoteUncheckedCreateWithoutVariationsInput>
    connectOrCreate?: QuoteCreateOrConnectWithoutVariationsInput
    upsert?: QuoteUpsertWithoutVariationsInput
    connect?: QuoteWhereUniqueInput
    update?: XOR<XOR<QuoteUpdateToOneWithWhereWithoutVariationsInput, QuoteUpdateWithoutVariationsInput>, QuoteUncheckedUpdateWithoutVariationsInput>
  }

  export type VariationPublicLinkUpdateManyWithoutVariationNestedInput = {
    create?: XOR<VariationPublicLinkCreateWithoutVariationInput, VariationPublicLinkUncheckedCreateWithoutVariationInput> | VariationPublicLinkCreateWithoutVariationInput[] | VariationPublicLinkUncheckedCreateWithoutVariationInput[]
    connectOrCreate?: VariationPublicLinkCreateOrConnectWithoutVariationInput | VariationPublicLinkCreateOrConnectWithoutVariationInput[]
    upsert?: VariationPublicLinkUpsertWithWhereUniqueWithoutVariationInput | VariationPublicLinkUpsertWithWhereUniqueWithoutVariationInput[]
    createMany?: VariationPublicLinkCreateManyVariationInputEnvelope
    set?: VariationPublicLinkWhereUniqueInput | VariationPublicLinkWhereUniqueInput[]
    disconnect?: VariationPublicLinkWhereUniqueInput | VariationPublicLinkWhereUniqueInput[]
    delete?: VariationPublicLinkWhereUniqueInput | VariationPublicLinkWhereUniqueInput[]
    connect?: VariationPublicLinkWhereUniqueInput | VariationPublicLinkWhereUniqueInput[]
    update?: VariationPublicLinkUpdateWithWhereUniqueWithoutVariationInput | VariationPublicLinkUpdateWithWhereUniqueWithoutVariationInput[]
    updateMany?: VariationPublicLinkUpdateManyWithWhereWithoutVariationInput | VariationPublicLinkUpdateManyWithWhereWithoutVariationInput[]
    deleteMany?: VariationPublicLinkScalarWhereInput | VariationPublicLinkScalarWhereInput[]
  }

  export type VariationItemUpdateManyWithoutVariationNestedInput = {
    create?: XOR<VariationItemCreateWithoutVariationInput, VariationItemUncheckedCreateWithoutVariationInput> | VariationItemCreateWithoutVariationInput[] | VariationItemUncheckedCreateWithoutVariationInput[]
    connectOrCreate?: VariationItemCreateOrConnectWithoutVariationInput | VariationItemCreateOrConnectWithoutVariationInput[]
    upsert?: VariationItemUpsertWithWhereUniqueWithoutVariationInput | VariationItemUpsertWithWhereUniqueWithoutVariationInput[]
    createMany?: VariationItemCreateManyVariationInputEnvelope
    set?: VariationItemWhereUniqueInput | VariationItemWhereUniqueInput[]
    disconnect?: VariationItemWhereUniqueInput | VariationItemWhereUniqueInput[]
    delete?: VariationItemWhereUniqueInput | VariationItemWhereUniqueInput[]
    connect?: VariationItemWhereUniqueInput | VariationItemWhereUniqueInput[]
    update?: VariationItemUpdateWithWhereUniqueWithoutVariationInput | VariationItemUpdateWithWhereUniqueWithoutVariationInput[]
    updateMany?: VariationItemUpdateManyWithWhereWithoutVariationInput | VariationItemUpdateManyWithWhereWithoutVariationInput[]
    deleteMany?: VariationItemScalarWhereInput | VariationItemScalarWhereInput[]
  }

  export type VariationApprovalUpdateOneWithoutVariationNestedInput = {
    create?: XOR<VariationApprovalCreateWithoutVariationInput, VariationApprovalUncheckedCreateWithoutVariationInput>
    connectOrCreate?: VariationApprovalCreateOrConnectWithoutVariationInput
    upsert?: VariationApprovalUpsertWithoutVariationInput
    disconnect?: VariationApprovalWhereInput | boolean
    delete?: VariationApprovalWhereInput | boolean
    connect?: VariationApprovalWhereUniqueInput
    update?: XOR<XOR<VariationApprovalUpdateToOneWithWhereWithoutVariationInput, VariationApprovalUpdateWithoutVariationInput>, VariationApprovalUncheckedUpdateWithoutVariationInput>
  }

  export type VariationPdfUpdateManyWithoutVariationNestedInput = {
    create?: XOR<VariationPdfCreateWithoutVariationInput, VariationPdfUncheckedCreateWithoutVariationInput> | VariationPdfCreateWithoutVariationInput[] | VariationPdfUncheckedCreateWithoutVariationInput[]
    connectOrCreate?: VariationPdfCreateOrConnectWithoutVariationInput | VariationPdfCreateOrConnectWithoutVariationInput[]
    upsert?: VariationPdfUpsertWithWhereUniqueWithoutVariationInput | VariationPdfUpsertWithWhereUniqueWithoutVariationInput[]
    createMany?: VariationPdfCreateManyVariationInputEnvelope
    set?: VariationPdfWhereUniqueInput | VariationPdfWhereUniqueInput[]
    disconnect?: VariationPdfWhereUniqueInput | VariationPdfWhereUniqueInput[]
    delete?: VariationPdfWhereUniqueInput | VariationPdfWhereUniqueInput[]
    connect?: VariationPdfWhereUniqueInput | VariationPdfWhereUniqueInput[]
    update?: VariationPdfUpdateWithWhereUniqueWithoutVariationInput | VariationPdfUpdateWithWhereUniqueWithoutVariationInput[]
    updateMany?: VariationPdfUpdateManyWithWhereWithoutVariationInput | VariationPdfUpdateManyWithWhereWithoutVariationInput[]
    deleteMany?: VariationPdfScalarWhereInput | VariationPdfScalarWhereInput[]
  }

  export type VariationPublicLinkUncheckedUpdateManyWithoutVariationNestedInput = {
    create?: XOR<VariationPublicLinkCreateWithoutVariationInput, VariationPublicLinkUncheckedCreateWithoutVariationInput> | VariationPublicLinkCreateWithoutVariationInput[] | VariationPublicLinkUncheckedCreateWithoutVariationInput[]
    connectOrCreate?: VariationPublicLinkCreateOrConnectWithoutVariationInput | VariationPublicLinkCreateOrConnectWithoutVariationInput[]
    upsert?: VariationPublicLinkUpsertWithWhereUniqueWithoutVariationInput | VariationPublicLinkUpsertWithWhereUniqueWithoutVariationInput[]
    createMany?: VariationPublicLinkCreateManyVariationInputEnvelope
    set?: VariationPublicLinkWhereUniqueInput | VariationPublicLinkWhereUniqueInput[]
    disconnect?: VariationPublicLinkWhereUniqueInput | VariationPublicLinkWhereUniqueInput[]
    delete?: VariationPublicLinkWhereUniqueInput | VariationPublicLinkWhereUniqueInput[]
    connect?: VariationPublicLinkWhereUniqueInput | VariationPublicLinkWhereUniqueInput[]
    update?: VariationPublicLinkUpdateWithWhereUniqueWithoutVariationInput | VariationPublicLinkUpdateWithWhereUniqueWithoutVariationInput[]
    updateMany?: VariationPublicLinkUpdateManyWithWhereWithoutVariationInput | VariationPublicLinkUpdateManyWithWhereWithoutVariationInput[]
    deleteMany?: VariationPublicLinkScalarWhereInput | VariationPublicLinkScalarWhereInput[]
  }

  export type VariationItemUncheckedUpdateManyWithoutVariationNestedInput = {
    create?: XOR<VariationItemCreateWithoutVariationInput, VariationItemUncheckedCreateWithoutVariationInput> | VariationItemCreateWithoutVariationInput[] | VariationItemUncheckedCreateWithoutVariationInput[]
    connectOrCreate?: VariationItemCreateOrConnectWithoutVariationInput | VariationItemCreateOrConnectWithoutVariationInput[]
    upsert?: VariationItemUpsertWithWhereUniqueWithoutVariationInput | VariationItemUpsertWithWhereUniqueWithoutVariationInput[]
    createMany?: VariationItemCreateManyVariationInputEnvelope
    set?: VariationItemWhereUniqueInput | VariationItemWhereUniqueInput[]
    disconnect?: VariationItemWhereUniqueInput | VariationItemWhereUniqueInput[]
    delete?: VariationItemWhereUniqueInput | VariationItemWhereUniqueInput[]
    connect?: VariationItemWhereUniqueInput | VariationItemWhereUniqueInput[]
    update?: VariationItemUpdateWithWhereUniqueWithoutVariationInput | VariationItemUpdateWithWhereUniqueWithoutVariationInput[]
    updateMany?: VariationItemUpdateManyWithWhereWithoutVariationInput | VariationItemUpdateManyWithWhereWithoutVariationInput[]
    deleteMany?: VariationItemScalarWhereInput | VariationItemScalarWhereInput[]
  }

  export type VariationApprovalUncheckedUpdateOneWithoutVariationNestedInput = {
    create?: XOR<VariationApprovalCreateWithoutVariationInput, VariationApprovalUncheckedCreateWithoutVariationInput>
    connectOrCreate?: VariationApprovalCreateOrConnectWithoutVariationInput
    upsert?: VariationApprovalUpsertWithoutVariationInput
    disconnect?: VariationApprovalWhereInput | boolean
    delete?: VariationApprovalWhereInput | boolean
    connect?: VariationApprovalWhereUniqueInput
    update?: XOR<XOR<VariationApprovalUpdateToOneWithWhereWithoutVariationInput, VariationApprovalUpdateWithoutVariationInput>, VariationApprovalUncheckedUpdateWithoutVariationInput>
  }

  export type VariationPdfUncheckedUpdateManyWithoutVariationNestedInput = {
    create?: XOR<VariationPdfCreateWithoutVariationInput, VariationPdfUncheckedCreateWithoutVariationInput> | VariationPdfCreateWithoutVariationInput[] | VariationPdfUncheckedCreateWithoutVariationInput[]
    connectOrCreate?: VariationPdfCreateOrConnectWithoutVariationInput | VariationPdfCreateOrConnectWithoutVariationInput[]
    upsert?: VariationPdfUpsertWithWhereUniqueWithoutVariationInput | VariationPdfUpsertWithWhereUniqueWithoutVariationInput[]
    createMany?: VariationPdfCreateManyVariationInputEnvelope
    set?: VariationPdfWhereUniqueInput | VariationPdfWhereUniqueInput[]
    disconnect?: VariationPdfWhereUniqueInput | VariationPdfWhereUniqueInput[]
    delete?: VariationPdfWhereUniqueInput | VariationPdfWhereUniqueInput[]
    connect?: VariationPdfWhereUniqueInput | VariationPdfWhereUniqueInput[]
    update?: VariationPdfUpdateWithWhereUniqueWithoutVariationInput | VariationPdfUpdateWithWhereUniqueWithoutVariationInput[]
    updateMany?: VariationPdfUpdateManyWithWhereWithoutVariationInput | VariationPdfUpdateManyWithWhereWithoutVariationInput[]
    deleteMany?: VariationPdfScalarWhereInput | VariationPdfScalarWhereInput[]
  }

  export type VariationCreateNestedOneWithoutItemsInput = {
    create?: XOR<VariationCreateWithoutItemsInput, VariationUncheckedCreateWithoutItemsInput>
    connectOrCreate?: VariationCreateOrConnectWithoutItemsInput
    connect?: VariationWhereUniqueInput
  }

  export type VariationItemCreateNestedOneWithoutChildrenInput = {
    create?: XOR<VariationItemCreateWithoutChildrenInput, VariationItemUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: VariationItemCreateOrConnectWithoutChildrenInput
    connect?: VariationItemWhereUniqueInput
  }

  export type VariationItemCreateNestedManyWithoutParentInput = {
    create?: XOR<VariationItemCreateWithoutParentInput, VariationItemUncheckedCreateWithoutParentInput> | VariationItemCreateWithoutParentInput[] | VariationItemUncheckedCreateWithoutParentInput[]
    connectOrCreate?: VariationItemCreateOrConnectWithoutParentInput | VariationItemCreateOrConnectWithoutParentInput[]
    createMany?: VariationItemCreateManyParentInputEnvelope
    connect?: VariationItemWhereUniqueInput | VariationItemWhereUniqueInput[]
  }

  export type VariationItemUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<VariationItemCreateWithoutParentInput, VariationItemUncheckedCreateWithoutParentInput> | VariationItemCreateWithoutParentInput[] | VariationItemUncheckedCreateWithoutParentInput[]
    connectOrCreate?: VariationItemCreateOrConnectWithoutParentInput | VariationItemCreateOrConnectWithoutParentInput[]
    createMany?: VariationItemCreateManyParentInputEnvelope
    connect?: VariationItemWhereUniqueInput | VariationItemWhereUniqueInput[]
  }

  export type VariationUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<VariationCreateWithoutItemsInput, VariationUncheckedCreateWithoutItemsInput>
    connectOrCreate?: VariationCreateOrConnectWithoutItemsInput
    upsert?: VariationUpsertWithoutItemsInput
    connect?: VariationWhereUniqueInput
    update?: XOR<XOR<VariationUpdateToOneWithWhereWithoutItemsInput, VariationUpdateWithoutItemsInput>, VariationUncheckedUpdateWithoutItemsInput>
  }

  export type VariationItemUpdateOneWithoutChildrenNestedInput = {
    create?: XOR<VariationItemCreateWithoutChildrenInput, VariationItemUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: VariationItemCreateOrConnectWithoutChildrenInput
    upsert?: VariationItemUpsertWithoutChildrenInput
    disconnect?: VariationItemWhereInput | boolean
    delete?: VariationItemWhereInput | boolean
    connect?: VariationItemWhereUniqueInput
    update?: XOR<XOR<VariationItemUpdateToOneWithWhereWithoutChildrenInput, VariationItemUpdateWithoutChildrenInput>, VariationItemUncheckedUpdateWithoutChildrenInput>
  }

  export type VariationItemUpdateManyWithoutParentNestedInput = {
    create?: XOR<VariationItemCreateWithoutParentInput, VariationItemUncheckedCreateWithoutParentInput> | VariationItemCreateWithoutParentInput[] | VariationItemUncheckedCreateWithoutParentInput[]
    connectOrCreate?: VariationItemCreateOrConnectWithoutParentInput | VariationItemCreateOrConnectWithoutParentInput[]
    upsert?: VariationItemUpsertWithWhereUniqueWithoutParentInput | VariationItemUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: VariationItemCreateManyParentInputEnvelope
    set?: VariationItemWhereUniqueInput | VariationItemWhereUniqueInput[]
    disconnect?: VariationItemWhereUniqueInput | VariationItemWhereUniqueInput[]
    delete?: VariationItemWhereUniqueInput | VariationItemWhereUniqueInput[]
    connect?: VariationItemWhereUniqueInput | VariationItemWhereUniqueInput[]
    update?: VariationItemUpdateWithWhereUniqueWithoutParentInput | VariationItemUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: VariationItemUpdateManyWithWhereWithoutParentInput | VariationItemUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: VariationItemScalarWhereInput | VariationItemScalarWhereInput[]
  }

  export type VariationItemUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<VariationItemCreateWithoutParentInput, VariationItemUncheckedCreateWithoutParentInput> | VariationItemCreateWithoutParentInput[] | VariationItemUncheckedCreateWithoutParentInput[]
    connectOrCreate?: VariationItemCreateOrConnectWithoutParentInput | VariationItemCreateOrConnectWithoutParentInput[]
    upsert?: VariationItemUpsertWithWhereUniqueWithoutParentInput | VariationItemUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: VariationItemCreateManyParentInputEnvelope
    set?: VariationItemWhereUniqueInput | VariationItemWhereUniqueInput[]
    disconnect?: VariationItemWhereUniqueInput | VariationItemWhereUniqueInput[]
    delete?: VariationItemWhereUniqueInput | VariationItemWhereUniqueInput[]
    connect?: VariationItemWhereUniqueInput | VariationItemWhereUniqueInput[]
    update?: VariationItemUpdateWithWhereUniqueWithoutParentInput | VariationItemUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: VariationItemUpdateManyWithWhereWithoutParentInput | VariationItemUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: VariationItemScalarWhereInput | VariationItemScalarWhereInput[]
  }

  export type VariationCreateNestedOneWithoutApprovalInput = {
    create?: XOR<VariationCreateWithoutApprovalInput, VariationUncheckedCreateWithoutApprovalInput>
    connectOrCreate?: VariationCreateOrConnectWithoutApprovalInput
    connect?: VariationWhereUniqueInput
  }

  export type VariationUpdateOneRequiredWithoutApprovalNestedInput = {
    create?: XOR<VariationCreateWithoutApprovalInput, VariationUncheckedCreateWithoutApprovalInput>
    connectOrCreate?: VariationCreateOrConnectWithoutApprovalInput
    upsert?: VariationUpsertWithoutApprovalInput
    connect?: VariationWhereUniqueInput
    update?: XOR<XOR<VariationUpdateToOneWithWhereWithoutApprovalInput, VariationUpdateWithoutApprovalInput>, VariationUncheckedUpdateWithoutApprovalInput>
  }

  export type VariationCreateNestedOneWithoutPublicLinksInput = {
    create?: XOR<VariationCreateWithoutPublicLinksInput, VariationUncheckedCreateWithoutPublicLinksInput>
    connectOrCreate?: VariationCreateOrConnectWithoutPublicLinksInput
    connect?: VariationWhereUniqueInput
  }

  export type VariationUpdateOneRequiredWithoutPublicLinksNestedInput = {
    create?: XOR<VariationCreateWithoutPublicLinksInput, VariationUncheckedCreateWithoutPublicLinksInput>
    connectOrCreate?: VariationCreateOrConnectWithoutPublicLinksInput
    upsert?: VariationUpsertWithoutPublicLinksInput
    connect?: VariationWhereUniqueInput
    update?: XOR<XOR<VariationUpdateToOneWithWhereWithoutPublicLinksInput, VariationUpdateWithoutPublicLinksInput>, VariationUncheckedUpdateWithoutPublicLinksInput>
  }

  export type VariationCreateNestedOneWithoutPdfsInput = {
    create?: XOR<VariationCreateWithoutPdfsInput, VariationUncheckedCreateWithoutPdfsInput>
    connectOrCreate?: VariationCreateOrConnectWithoutPdfsInput
    connect?: VariationWhereUniqueInput
  }

  export type EnumVariationPdfStageFieldUpdateOperationsInput = {
    set?: $Enums.VariationPdfStage
  }

  export type VariationUpdateOneRequiredWithoutPdfsNestedInput = {
    create?: XOR<VariationCreateWithoutPdfsInput, VariationUncheckedCreateWithoutPdfsInput>
    connectOrCreate?: VariationCreateOrConnectWithoutPdfsInput
    upsert?: VariationUpsertWithoutPdfsInput
    connect?: VariationWhereUniqueInput
    update?: XOR<XOR<VariationUpdateToOneWithWhereWithoutPdfsInput, VariationUpdateWithoutPdfsInput>, VariationUncheckedUpdateWithoutPdfsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumVatModeFilter<$PrismaModel = never> = {
    equals?: $Enums.VatMode | EnumVatModeFieldRefInput<$PrismaModel>
    in?: $Enums.VatMode[] | ListEnumVatModeFieldRefInput<$PrismaModel>
    notIn?: $Enums.VatMode[] | ListEnumVatModeFieldRefInput<$PrismaModel>
    not?: NestedEnumVatModeFilter<$PrismaModel> | $Enums.VatMode
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumVatModeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VatMode | EnumVatModeFieldRefInput<$PrismaModel>
    in?: $Enums.VatMode[] | ListEnumVatModeFieldRefInput<$PrismaModel>
    notIn?: $Enums.VatMode[] | ListEnumVatModeFieldRefInput<$PrismaModel>
    not?: NestedEnumVatModeWithAggregatesFilter<$PrismaModel> | $Enums.VatMode
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVatModeFilter<$PrismaModel>
    _max?: NestedEnumVatModeFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumQuoteStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.QuoteStatus | EnumQuoteStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QuoteStatus[] | ListEnumQuoteStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuoteStatus[] | ListEnumQuoteStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumQuoteStatusFilter<$PrismaModel> | $Enums.QuoteStatus
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumDepositTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DepositType | EnumDepositTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DepositType[] | ListEnumDepositTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DepositType[] | ListEnumDepositTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDepositTypeFilter<$PrismaModel> | $Enums.DepositType
  }

  export type NestedEnumQuoteStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QuoteStatus | EnumQuoteStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QuoteStatus[] | ListEnumQuoteStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuoteStatus[] | ListEnumQuoteStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumQuoteStatusWithAggregatesFilter<$PrismaModel> | $Enums.QuoteStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQuoteStatusFilter<$PrismaModel>
    _max?: NestedEnumQuoteStatusFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumDepositTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DepositType | EnumDepositTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DepositType[] | ListEnumDepositTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DepositType[] | ListEnumDepositTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDepositTypeWithAggregatesFilter<$PrismaModel> | $Enums.DepositType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDepositTypeFilter<$PrismaModel>
    _max?: NestedEnumDepositTypeFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumItemRowTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ItemRowType | EnumItemRowTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ItemRowType[] | ListEnumItemRowTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ItemRowType[] | ListEnumItemRowTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumItemRowTypeFilter<$PrismaModel> | $Enums.ItemRowType
  }

  export type NestedEnumCalcTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CalcType | EnumCalcTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CalcType[] | ListEnumCalcTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CalcType[] | ListEnumCalcTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCalcTypeFilter<$PrismaModel> | $Enums.CalcType
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedEnumItemRowTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ItemRowType | EnumItemRowTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ItemRowType[] | ListEnumItemRowTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ItemRowType[] | ListEnumItemRowTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumItemRowTypeWithAggregatesFilter<$PrismaModel> | $Enums.ItemRowType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumItemRowTypeFilter<$PrismaModel>
    _max?: NestedEnumItemRowTypeFilter<$PrismaModel>
  }

  export type NestedEnumCalcTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CalcType | EnumCalcTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CalcType[] | ListEnumCalcTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CalcType[] | ListEnumCalcTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCalcTypeWithAggregatesFilter<$PrismaModel> | $Enums.CalcType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCalcTypeFilter<$PrismaModel>
    _max?: NestedEnumCalcTypeFilter<$PrismaModel>
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedEnumVariationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.VariationStatus | EnumVariationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VariationStatus[] | ListEnumVariationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VariationStatus[] | ListEnumVariationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVariationStatusFilter<$PrismaModel> | $Enums.VariationStatus
  }

  export type NestedEnumVariationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VariationStatus | EnumVariationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VariationStatus[] | ListEnumVariationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VariationStatus[] | ListEnumVariationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVariationStatusWithAggregatesFilter<$PrismaModel> | $Enums.VariationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVariationStatusFilter<$PrismaModel>
    _max?: NestedEnumVariationStatusFilter<$PrismaModel>
  }

  export type NestedEnumVariationPdfStageFilter<$PrismaModel = never> = {
    equals?: $Enums.VariationPdfStage | EnumVariationPdfStageFieldRefInput<$PrismaModel>
    in?: $Enums.VariationPdfStage[] | ListEnumVariationPdfStageFieldRefInput<$PrismaModel>
    notIn?: $Enums.VariationPdfStage[] | ListEnumVariationPdfStageFieldRefInput<$PrismaModel>
    not?: NestedEnumVariationPdfStageFilter<$PrismaModel> | $Enums.VariationPdfStage
  }

  export type NestedEnumVariationPdfStageWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VariationPdfStage | EnumVariationPdfStageFieldRefInput<$PrismaModel>
    in?: $Enums.VariationPdfStage[] | ListEnumVariationPdfStageFieldRefInput<$PrismaModel>
    notIn?: $Enums.VariationPdfStage[] | ListEnumVariationPdfStageFieldRefInput<$PrismaModel>
    not?: NestedEnumVariationPdfStageWithAggregatesFilter<$PrismaModel> | $Enums.VariationPdfStage
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVariationPdfStageFilter<$PrismaModel>
    _max?: NestedEnumVariationPdfStageFilter<$PrismaModel>
  }

  export type QuoteCreateWithoutClientInput = {
    id?: string
    title: string
    referenceNo?: string | null
    projectAddress?: string | null
    status?: $Enums.QuoteStatus
    currentVersion?: number
    sentAt?: Date | string | null
    acceptedAt?: Date | string | null
    vatMode?: $Enums.VatMode
    vatRateBps?: number
    depositType?: $Enums.DepositType
    depositAmountPence?: number | null
    depositPercentBps?: number | null
    paymentScheduleJson?: NullableJsonNullValueInput | InputJsonValue
    showQtyToClient?: boolean
    showUnitRatesToClient?: boolean
    scopeOverviewJson?: NullableJsonNullValueInput | InputJsonValue
    termsJson?: NullableJsonNullValueInput | InputJsonValue
    estimatedStartDate?: Date | string | null
    estimatedDurationWeeks?: number | null
    createdByUserId?: string | null
    updatedByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: QuoteItemCreateNestedManyWithoutQuoteInput
    publicLinks?: QuotePublicLinkCreateNestedManyWithoutQuoteInput
    pdfs?: QuotePdfCreateNestedManyWithoutQuoteInput
    acceptance?: QuoteAcceptanceCreateNestedOneWithoutQuoteInput
    variations?: VariationCreateNestedManyWithoutQuoteInput
    versions?: QuoteVersionCreateNestedManyWithoutQuoteInput
  }

  export type QuoteUncheckedCreateWithoutClientInput = {
    id?: string
    title: string
    referenceNo?: string | null
    projectAddress?: string | null
    status?: $Enums.QuoteStatus
    currentVersion?: number
    sentAt?: Date | string | null
    acceptedAt?: Date | string | null
    vatMode?: $Enums.VatMode
    vatRateBps?: number
    depositType?: $Enums.DepositType
    depositAmountPence?: number | null
    depositPercentBps?: number | null
    paymentScheduleJson?: NullableJsonNullValueInput | InputJsonValue
    showQtyToClient?: boolean
    showUnitRatesToClient?: boolean
    scopeOverviewJson?: NullableJsonNullValueInput | InputJsonValue
    termsJson?: NullableJsonNullValueInput | InputJsonValue
    estimatedStartDate?: Date | string | null
    estimatedDurationWeeks?: number | null
    createdByUserId?: string | null
    updatedByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: QuoteItemUncheckedCreateNestedManyWithoutQuoteInput
    publicLinks?: QuotePublicLinkUncheckedCreateNestedManyWithoutQuoteInput
    pdfs?: QuotePdfUncheckedCreateNestedManyWithoutQuoteInput
    acceptance?: QuoteAcceptanceUncheckedCreateNestedOneWithoutQuoteInput
    variations?: VariationUncheckedCreateNestedManyWithoutQuoteInput
    versions?: QuoteVersionUncheckedCreateNestedManyWithoutQuoteInput
  }

  export type QuoteCreateOrConnectWithoutClientInput = {
    where: QuoteWhereUniqueInput
    create: XOR<QuoteCreateWithoutClientInput, QuoteUncheckedCreateWithoutClientInput>
  }

  export type QuoteCreateManyClientInputEnvelope = {
    data: QuoteCreateManyClientInput | QuoteCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type QuoteUpsertWithWhereUniqueWithoutClientInput = {
    where: QuoteWhereUniqueInput
    update: XOR<QuoteUpdateWithoutClientInput, QuoteUncheckedUpdateWithoutClientInput>
    create: XOR<QuoteCreateWithoutClientInput, QuoteUncheckedCreateWithoutClientInput>
  }

  export type QuoteUpdateWithWhereUniqueWithoutClientInput = {
    where: QuoteWhereUniqueInput
    data: XOR<QuoteUpdateWithoutClientInput, QuoteUncheckedUpdateWithoutClientInput>
  }

  export type QuoteUpdateManyWithWhereWithoutClientInput = {
    where: QuoteScalarWhereInput
    data: XOR<QuoteUpdateManyMutationInput, QuoteUncheckedUpdateManyWithoutClientInput>
  }

  export type QuoteScalarWhereInput = {
    AND?: QuoteScalarWhereInput | QuoteScalarWhereInput[]
    OR?: QuoteScalarWhereInput[]
    NOT?: QuoteScalarWhereInput | QuoteScalarWhereInput[]
    id?: StringFilter<"Quote"> | string
    orgId?: StringFilter<"Quote"> | string
    clientId?: StringNullableFilter<"Quote"> | string | null
    title?: StringFilter<"Quote"> | string
    referenceNo?: StringNullableFilter<"Quote"> | string | null
    projectAddress?: StringNullableFilter<"Quote"> | string | null
    status?: EnumQuoteStatusFilter<"Quote"> | $Enums.QuoteStatus
    currentVersion?: IntFilter<"Quote"> | number
    sentAt?: DateTimeNullableFilter<"Quote"> | Date | string | null
    acceptedAt?: DateTimeNullableFilter<"Quote"> | Date | string | null
    vatMode?: EnumVatModeFilter<"Quote"> | $Enums.VatMode
    vatRateBps?: IntFilter<"Quote"> | number
    depositType?: EnumDepositTypeFilter<"Quote"> | $Enums.DepositType
    depositAmountPence?: IntNullableFilter<"Quote"> | number | null
    depositPercentBps?: IntNullableFilter<"Quote"> | number | null
    paymentScheduleJson?: JsonNullableFilter<"Quote">
    showQtyToClient?: BoolFilter<"Quote"> | boolean
    showUnitRatesToClient?: BoolFilter<"Quote"> | boolean
    scopeOverviewJson?: JsonNullableFilter<"Quote">
    termsJson?: JsonNullableFilter<"Quote">
    estimatedStartDate?: DateTimeNullableFilter<"Quote"> | Date | string | null
    estimatedDurationWeeks?: IntNullableFilter<"Quote"> | number | null
    createdByUserId?: StringNullableFilter<"Quote"> | string | null
    updatedByUserId?: StringNullableFilter<"Quote"> | string | null
    createdAt?: DateTimeFilter<"Quote"> | Date | string
    updatedAt?: DateTimeFilter<"Quote"> | Date | string
  }

  export type ClientCreateWithoutQuotesInput = {
    id?: string
    orgId: string
    name: string
    email?: string | null
    phone?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    postcode?: string | null
    country?: string | null
    notes?: string | null
    createdByUserId?: string | null
    updatedByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientUncheckedCreateWithoutQuotesInput = {
    id?: string
    orgId: string
    name: string
    email?: string | null
    phone?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    postcode?: string | null
    country?: string | null
    notes?: string | null
    createdByUserId?: string | null
    updatedByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientCreateOrConnectWithoutQuotesInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutQuotesInput, ClientUncheckedCreateWithoutQuotesInput>
  }

  export type QuoteItemCreateWithoutQuoteInput = {
    id?: string
    rowType?: $Enums.ItemRowType
    title: string
    description?: string | null
    sortOrder?: number
    roomTag?: string | null
    tradeTag?: string | null
    phaseTag?: string | null
    calcType?: $Enums.CalcType
    qty?: Decimal | DecimalJsLike | number | string | null
    unit?: string | null
    unitPricePence?: number | null
    hours?: Decimal | DecimalJsLike | number | string | null
    hourlyRatePence?: number | null
    sellPricePence?: number | null
    isAllowance?: boolean
    costPence?: number | null
    markupPercentBps?: number | null
    createdByUserId?: string | null
    updatedByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: QuoteItemCreateNestedOneWithoutChildrenInput
    children?: QuoteItemCreateNestedManyWithoutParentInput
  }

  export type QuoteItemUncheckedCreateWithoutQuoteInput = {
    id?: string
    parentId?: string | null
    rowType?: $Enums.ItemRowType
    title: string
    description?: string | null
    sortOrder?: number
    roomTag?: string | null
    tradeTag?: string | null
    phaseTag?: string | null
    calcType?: $Enums.CalcType
    qty?: Decimal | DecimalJsLike | number | string | null
    unit?: string | null
    unitPricePence?: number | null
    hours?: Decimal | DecimalJsLike | number | string | null
    hourlyRatePence?: number | null
    sellPricePence?: number | null
    isAllowance?: boolean
    costPence?: number | null
    markupPercentBps?: number | null
    createdByUserId?: string | null
    updatedByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: QuoteItemUncheckedCreateNestedManyWithoutParentInput
  }

  export type QuoteItemCreateOrConnectWithoutQuoteInput = {
    where: QuoteItemWhereUniqueInput
    create: XOR<QuoteItemCreateWithoutQuoteInput, QuoteItemUncheckedCreateWithoutQuoteInput>
  }

  export type QuoteItemCreateManyQuoteInputEnvelope = {
    data: QuoteItemCreateManyQuoteInput | QuoteItemCreateManyQuoteInput[]
    skipDuplicates?: boolean
  }

  export type QuotePublicLinkCreateWithoutQuoteInput = {
    id?: string
    tokenHash: string
    tokenPrefix?: string | null
    isActive?: boolean
    expiresAt?: Date | string | null
    revokedAt?: Date | string | null
    firstViewedAt?: Date | string | null
    lastViewedAt?: Date | string | null
    viewCount?: number
    createdByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuotePublicLinkUncheckedCreateWithoutQuoteInput = {
    id?: string
    tokenHash: string
    tokenPrefix?: string | null
    isActive?: boolean
    expiresAt?: Date | string | null
    revokedAt?: Date | string | null
    firstViewedAt?: Date | string | null
    lastViewedAt?: Date | string | null
    viewCount?: number
    createdByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuotePublicLinkCreateOrConnectWithoutQuoteInput = {
    where: QuotePublicLinkWhereUniqueInput
    create: XOR<QuotePublicLinkCreateWithoutQuoteInput, QuotePublicLinkUncheckedCreateWithoutQuoteInput>
  }

  export type QuotePublicLinkCreateManyQuoteInputEnvelope = {
    data: QuotePublicLinkCreateManyQuoteInput | QuotePublicLinkCreateManyQuoteInput[]
    skipDuplicates?: boolean
  }

  export type QuotePdfCreateWithoutQuoteInput = {
    id?: string
    version: number
    fileUrl: string
    createdAt?: Date | string
  }

  export type QuotePdfUncheckedCreateWithoutQuoteInput = {
    id?: string
    version: number
    fileUrl: string
    createdAt?: Date | string
  }

  export type QuotePdfCreateOrConnectWithoutQuoteInput = {
    where: QuotePdfWhereUniqueInput
    create: XOR<QuotePdfCreateWithoutQuoteInput, QuotePdfUncheckedCreateWithoutQuoteInput>
  }

  export type QuotePdfCreateManyQuoteInputEnvelope = {
    data: QuotePdfCreateManyQuoteInput | QuotePdfCreateManyQuoteInput[]
    skipDuplicates?: boolean
  }

  export type QuoteAcceptanceCreateWithoutQuoteInput = {
    id?: string
    acceptedName: string
    acceptedEmail?: string | null
    acceptedAt?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type QuoteAcceptanceUncheckedCreateWithoutQuoteInput = {
    id?: string
    acceptedName: string
    acceptedEmail?: string | null
    acceptedAt?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type QuoteAcceptanceCreateOrConnectWithoutQuoteInput = {
    where: QuoteAcceptanceWhereUniqueInput
    create: XOR<QuoteAcceptanceCreateWithoutQuoteInput, QuoteAcceptanceUncheckedCreateWithoutQuoteInput>
  }

  export type VariationCreateWithoutQuoteInput = {
    id?: string
    number: number
    title: string
    description?: string | null
    status?: $Enums.VariationStatus
    sentAt?: Date | string | null
    approvedAt?: Date | string | null
    vatMode?: $Enums.VatMode
    vatRateBps?: number
    createdByUserId?: string | null
    updatedByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    publicLinks?: VariationPublicLinkCreateNestedManyWithoutVariationInput
    items?: VariationItemCreateNestedManyWithoutVariationInput
    approval?: VariationApprovalCreateNestedOneWithoutVariationInput
    pdfs?: VariationPdfCreateNestedManyWithoutVariationInput
  }

  export type VariationUncheckedCreateWithoutQuoteInput = {
    id?: string
    number: number
    title: string
    description?: string | null
    status?: $Enums.VariationStatus
    sentAt?: Date | string | null
    approvedAt?: Date | string | null
    vatMode?: $Enums.VatMode
    vatRateBps?: number
    createdByUserId?: string | null
    updatedByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    publicLinks?: VariationPublicLinkUncheckedCreateNestedManyWithoutVariationInput
    items?: VariationItemUncheckedCreateNestedManyWithoutVariationInput
    approval?: VariationApprovalUncheckedCreateNestedOneWithoutVariationInput
    pdfs?: VariationPdfUncheckedCreateNestedManyWithoutVariationInput
  }

  export type VariationCreateOrConnectWithoutQuoteInput = {
    where: VariationWhereUniqueInput
    create: XOR<VariationCreateWithoutQuoteInput, VariationUncheckedCreateWithoutQuoteInput>
  }

  export type VariationCreateManyQuoteInputEnvelope = {
    data: VariationCreateManyQuoteInput | VariationCreateManyQuoteInput[]
    skipDuplicates?: boolean
  }

  export type QuoteVersionCreateWithoutQuoteInput = {
    id?: string
    version: number
    status: $Enums.QuoteStatus
    vatMode: $Enums.VatMode
    vatRateBps: number
    depositType: $Enums.DepositType
    depositAmountPence?: number | null
    depositPercentBps?: number | null
    showQtyToClient: boolean
    showUnitRatesToClient: boolean
    title: string
    referenceNo?: string | null
    projectAddress?: string | null
    scopeOverviewJson?: NullableJsonNullValueInput | InputJsonValue
    termsJson?: NullableJsonNullValueInput | InputJsonValue
    paymentScheduleJson?: NullableJsonNullValueInput | InputJsonValue
    subtotalPence?: number | null
    vatPence?: number | null
    totalPence?: number | null
    sentAt?: Date | string | null
    createdByUserId?: string | null
    createdAt?: Date | string
    items?: QuoteVersionItemCreateNestedManyWithoutQuoteVersionInput
  }

  export type QuoteVersionUncheckedCreateWithoutQuoteInput = {
    id?: string
    version: number
    status: $Enums.QuoteStatus
    vatMode: $Enums.VatMode
    vatRateBps: number
    depositType: $Enums.DepositType
    depositAmountPence?: number | null
    depositPercentBps?: number | null
    showQtyToClient: boolean
    showUnitRatesToClient: boolean
    title: string
    referenceNo?: string | null
    projectAddress?: string | null
    scopeOverviewJson?: NullableJsonNullValueInput | InputJsonValue
    termsJson?: NullableJsonNullValueInput | InputJsonValue
    paymentScheduleJson?: NullableJsonNullValueInput | InputJsonValue
    subtotalPence?: number | null
    vatPence?: number | null
    totalPence?: number | null
    sentAt?: Date | string | null
    createdByUserId?: string | null
    createdAt?: Date | string
    items?: QuoteVersionItemUncheckedCreateNestedManyWithoutQuoteVersionInput
  }

  export type QuoteVersionCreateOrConnectWithoutQuoteInput = {
    where: QuoteVersionWhereUniqueInput
    create: XOR<QuoteVersionCreateWithoutQuoteInput, QuoteVersionUncheckedCreateWithoutQuoteInput>
  }

  export type QuoteVersionCreateManyQuoteInputEnvelope = {
    data: QuoteVersionCreateManyQuoteInput | QuoteVersionCreateManyQuoteInput[]
    skipDuplicates?: boolean
  }

  export type ClientUpsertWithoutQuotesInput = {
    update: XOR<ClientUpdateWithoutQuotesInput, ClientUncheckedUpdateWithoutQuotesInput>
    create: XOR<ClientCreateWithoutQuotesInput, ClientUncheckedCreateWithoutQuotesInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutQuotesInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutQuotesInput, ClientUncheckedUpdateWithoutQuotesInput>
  }

  export type ClientUpdateWithoutQuotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postcode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientUncheckedUpdateWithoutQuotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    postcode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuoteItemUpsertWithWhereUniqueWithoutQuoteInput = {
    where: QuoteItemWhereUniqueInput
    update: XOR<QuoteItemUpdateWithoutQuoteInput, QuoteItemUncheckedUpdateWithoutQuoteInput>
    create: XOR<QuoteItemCreateWithoutQuoteInput, QuoteItemUncheckedCreateWithoutQuoteInput>
  }

  export type QuoteItemUpdateWithWhereUniqueWithoutQuoteInput = {
    where: QuoteItemWhereUniqueInput
    data: XOR<QuoteItemUpdateWithoutQuoteInput, QuoteItemUncheckedUpdateWithoutQuoteInput>
  }

  export type QuoteItemUpdateManyWithWhereWithoutQuoteInput = {
    where: QuoteItemScalarWhereInput
    data: XOR<QuoteItemUpdateManyMutationInput, QuoteItemUncheckedUpdateManyWithoutQuoteInput>
  }

  export type QuoteItemScalarWhereInput = {
    AND?: QuoteItemScalarWhereInput | QuoteItemScalarWhereInput[]
    OR?: QuoteItemScalarWhereInput[]
    NOT?: QuoteItemScalarWhereInput | QuoteItemScalarWhereInput[]
    id?: StringFilter<"QuoteItem"> | string
    orgId?: StringFilter<"QuoteItem"> | string
    quoteId?: StringFilter<"QuoteItem"> | string
    parentId?: StringNullableFilter<"QuoteItem"> | string | null
    rowType?: EnumItemRowTypeFilter<"QuoteItem"> | $Enums.ItemRowType
    title?: StringFilter<"QuoteItem"> | string
    description?: StringNullableFilter<"QuoteItem"> | string | null
    sortOrder?: IntFilter<"QuoteItem"> | number
    roomTag?: StringNullableFilter<"QuoteItem"> | string | null
    tradeTag?: StringNullableFilter<"QuoteItem"> | string | null
    phaseTag?: StringNullableFilter<"QuoteItem"> | string | null
    calcType?: EnumCalcTypeFilter<"QuoteItem"> | $Enums.CalcType
    qty?: DecimalNullableFilter<"QuoteItem"> | Decimal | DecimalJsLike | number | string | null
    unit?: StringNullableFilter<"QuoteItem"> | string | null
    unitPricePence?: IntNullableFilter<"QuoteItem"> | number | null
    hours?: DecimalNullableFilter<"QuoteItem"> | Decimal | DecimalJsLike | number | string | null
    hourlyRatePence?: IntNullableFilter<"QuoteItem"> | number | null
    sellPricePence?: IntNullableFilter<"QuoteItem"> | number | null
    isAllowance?: BoolFilter<"QuoteItem"> | boolean
    costPence?: IntNullableFilter<"QuoteItem"> | number | null
    markupPercentBps?: IntNullableFilter<"QuoteItem"> | number | null
    createdByUserId?: StringNullableFilter<"QuoteItem"> | string | null
    updatedByUserId?: StringNullableFilter<"QuoteItem"> | string | null
    createdAt?: DateTimeFilter<"QuoteItem"> | Date | string
    updatedAt?: DateTimeFilter<"QuoteItem"> | Date | string
  }

  export type QuotePublicLinkUpsertWithWhereUniqueWithoutQuoteInput = {
    where: QuotePublicLinkWhereUniqueInput
    update: XOR<QuotePublicLinkUpdateWithoutQuoteInput, QuotePublicLinkUncheckedUpdateWithoutQuoteInput>
    create: XOR<QuotePublicLinkCreateWithoutQuoteInput, QuotePublicLinkUncheckedCreateWithoutQuoteInput>
  }

  export type QuotePublicLinkUpdateWithWhereUniqueWithoutQuoteInput = {
    where: QuotePublicLinkWhereUniqueInput
    data: XOR<QuotePublicLinkUpdateWithoutQuoteInput, QuotePublicLinkUncheckedUpdateWithoutQuoteInput>
  }

  export type QuotePublicLinkUpdateManyWithWhereWithoutQuoteInput = {
    where: QuotePublicLinkScalarWhereInput
    data: XOR<QuotePublicLinkUpdateManyMutationInput, QuotePublicLinkUncheckedUpdateManyWithoutQuoteInput>
  }

  export type QuotePublicLinkScalarWhereInput = {
    AND?: QuotePublicLinkScalarWhereInput | QuotePublicLinkScalarWhereInput[]
    OR?: QuotePublicLinkScalarWhereInput[]
    NOT?: QuotePublicLinkScalarWhereInput | QuotePublicLinkScalarWhereInput[]
    id?: StringFilter<"QuotePublicLink"> | string
    orgId?: StringFilter<"QuotePublicLink"> | string
    quoteId?: StringFilter<"QuotePublicLink"> | string
    tokenHash?: StringFilter<"QuotePublicLink"> | string
    tokenPrefix?: StringNullableFilter<"QuotePublicLink"> | string | null
    isActive?: BoolFilter<"QuotePublicLink"> | boolean
    expiresAt?: DateTimeNullableFilter<"QuotePublicLink"> | Date | string | null
    revokedAt?: DateTimeNullableFilter<"QuotePublicLink"> | Date | string | null
    firstViewedAt?: DateTimeNullableFilter<"QuotePublicLink"> | Date | string | null
    lastViewedAt?: DateTimeNullableFilter<"QuotePublicLink"> | Date | string | null
    viewCount?: IntFilter<"QuotePublicLink"> | number
    createdByUserId?: StringNullableFilter<"QuotePublicLink"> | string | null
    createdAt?: DateTimeFilter<"QuotePublicLink"> | Date | string
    updatedAt?: DateTimeFilter<"QuotePublicLink"> | Date | string
  }

  export type QuotePdfUpsertWithWhereUniqueWithoutQuoteInput = {
    where: QuotePdfWhereUniqueInput
    update: XOR<QuotePdfUpdateWithoutQuoteInput, QuotePdfUncheckedUpdateWithoutQuoteInput>
    create: XOR<QuotePdfCreateWithoutQuoteInput, QuotePdfUncheckedCreateWithoutQuoteInput>
  }

  export type QuotePdfUpdateWithWhereUniqueWithoutQuoteInput = {
    where: QuotePdfWhereUniqueInput
    data: XOR<QuotePdfUpdateWithoutQuoteInput, QuotePdfUncheckedUpdateWithoutQuoteInput>
  }

  export type QuotePdfUpdateManyWithWhereWithoutQuoteInput = {
    where: QuotePdfScalarWhereInput
    data: XOR<QuotePdfUpdateManyMutationInput, QuotePdfUncheckedUpdateManyWithoutQuoteInput>
  }

  export type QuotePdfScalarWhereInput = {
    AND?: QuotePdfScalarWhereInput | QuotePdfScalarWhereInput[]
    OR?: QuotePdfScalarWhereInput[]
    NOT?: QuotePdfScalarWhereInput | QuotePdfScalarWhereInput[]
    id?: StringFilter<"QuotePdf"> | string
    orgId?: StringFilter<"QuotePdf"> | string
    quoteId?: StringFilter<"QuotePdf"> | string
    version?: IntFilter<"QuotePdf"> | number
    fileUrl?: StringFilter<"QuotePdf"> | string
    createdAt?: DateTimeFilter<"QuotePdf"> | Date | string
  }

  export type QuoteAcceptanceUpsertWithoutQuoteInput = {
    update: XOR<QuoteAcceptanceUpdateWithoutQuoteInput, QuoteAcceptanceUncheckedUpdateWithoutQuoteInput>
    create: XOR<QuoteAcceptanceCreateWithoutQuoteInput, QuoteAcceptanceUncheckedCreateWithoutQuoteInput>
    where?: QuoteAcceptanceWhereInput
  }

  export type QuoteAcceptanceUpdateToOneWithWhereWithoutQuoteInput = {
    where?: QuoteAcceptanceWhereInput
    data: XOR<QuoteAcceptanceUpdateWithoutQuoteInput, QuoteAcceptanceUncheckedUpdateWithoutQuoteInput>
  }

  export type QuoteAcceptanceUpdateWithoutQuoteInput = {
    id?: StringFieldUpdateOperationsInput | string
    acceptedName?: StringFieldUpdateOperationsInput | string
    acceptedEmail?: NullableStringFieldUpdateOperationsInput | string | null
    acceptedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuoteAcceptanceUncheckedUpdateWithoutQuoteInput = {
    id?: StringFieldUpdateOperationsInput | string
    acceptedName?: StringFieldUpdateOperationsInput | string
    acceptedEmail?: NullableStringFieldUpdateOperationsInput | string | null
    acceptedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VariationUpsertWithWhereUniqueWithoutQuoteInput = {
    where: VariationWhereUniqueInput
    update: XOR<VariationUpdateWithoutQuoteInput, VariationUncheckedUpdateWithoutQuoteInput>
    create: XOR<VariationCreateWithoutQuoteInput, VariationUncheckedCreateWithoutQuoteInput>
  }

  export type VariationUpdateWithWhereUniqueWithoutQuoteInput = {
    where: VariationWhereUniqueInput
    data: XOR<VariationUpdateWithoutQuoteInput, VariationUncheckedUpdateWithoutQuoteInput>
  }

  export type VariationUpdateManyWithWhereWithoutQuoteInput = {
    where: VariationScalarWhereInput
    data: XOR<VariationUpdateManyMutationInput, VariationUncheckedUpdateManyWithoutQuoteInput>
  }

  export type VariationScalarWhereInput = {
    AND?: VariationScalarWhereInput | VariationScalarWhereInput[]
    OR?: VariationScalarWhereInput[]
    NOT?: VariationScalarWhereInput | VariationScalarWhereInput[]
    id?: StringFilter<"Variation"> | string
    orgId?: StringFilter<"Variation"> | string
    quoteId?: StringFilter<"Variation"> | string
    number?: IntFilter<"Variation"> | number
    title?: StringFilter<"Variation"> | string
    description?: StringNullableFilter<"Variation"> | string | null
    status?: EnumVariationStatusFilter<"Variation"> | $Enums.VariationStatus
    sentAt?: DateTimeNullableFilter<"Variation"> | Date | string | null
    approvedAt?: DateTimeNullableFilter<"Variation"> | Date | string | null
    vatMode?: EnumVatModeFilter<"Variation"> | $Enums.VatMode
    vatRateBps?: IntFilter<"Variation"> | number
    createdByUserId?: StringNullableFilter<"Variation"> | string | null
    updatedByUserId?: StringNullableFilter<"Variation"> | string | null
    createdAt?: DateTimeFilter<"Variation"> | Date | string
    updatedAt?: DateTimeFilter<"Variation"> | Date | string
  }

  export type QuoteVersionUpsertWithWhereUniqueWithoutQuoteInput = {
    where: QuoteVersionWhereUniqueInput
    update: XOR<QuoteVersionUpdateWithoutQuoteInput, QuoteVersionUncheckedUpdateWithoutQuoteInput>
    create: XOR<QuoteVersionCreateWithoutQuoteInput, QuoteVersionUncheckedCreateWithoutQuoteInput>
  }

  export type QuoteVersionUpdateWithWhereUniqueWithoutQuoteInput = {
    where: QuoteVersionWhereUniqueInput
    data: XOR<QuoteVersionUpdateWithoutQuoteInput, QuoteVersionUncheckedUpdateWithoutQuoteInput>
  }

  export type QuoteVersionUpdateManyWithWhereWithoutQuoteInput = {
    where: QuoteVersionScalarWhereInput
    data: XOR<QuoteVersionUpdateManyMutationInput, QuoteVersionUncheckedUpdateManyWithoutQuoteInput>
  }

  export type QuoteVersionScalarWhereInput = {
    AND?: QuoteVersionScalarWhereInput | QuoteVersionScalarWhereInput[]
    OR?: QuoteVersionScalarWhereInput[]
    NOT?: QuoteVersionScalarWhereInput | QuoteVersionScalarWhereInput[]
    id?: StringFilter<"QuoteVersion"> | string
    orgId?: StringFilter<"QuoteVersion"> | string
    quoteId?: StringFilter<"QuoteVersion"> | string
    version?: IntFilter<"QuoteVersion"> | number
    status?: EnumQuoteStatusFilter<"QuoteVersion"> | $Enums.QuoteStatus
    vatMode?: EnumVatModeFilter<"QuoteVersion"> | $Enums.VatMode
    vatRateBps?: IntFilter<"QuoteVersion"> | number
    depositType?: EnumDepositTypeFilter<"QuoteVersion"> | $Enums.DepositType
    depositAmountPence?: IntNullableFilter<"QuoteVersion"> | number | null
    depositPercentBps?: IntNullableFilter<"QuoteVersion"> | number | null
    showQtyToClient?: BoolFilter<"QuoteVersion"> | boolean
    showUnitRatesToClient?: BoolFilter<"QuoteVersion"> | boolean
    title?: StringFilter<"QuoteVersion"> | string
    referenceNo?: StringNullableFilter<"QuoteVersion"> | string | null
    projectAddress?: StringNullableFilter<"QuoteVersion"> | string | null
    scopeOverviewJson?: JsonNullableFilter<"QuoteVersion">
    termsJson?: JsonNullableFilter<"QuoteVersion">
    paymentScheduleJson?: JsonNullableFilter<"QuoteVersion">
    subtotalPence?: IntNullableFilter<"QuoteVersion"> | number | null
    vatPence?: IntNullableFilter<"QuoteVersion"> | number | null
    totalPence?: IntNullableFilter<"QuoteVersion"> | number | null
    sentAt?: DateTimeNullableFilter<"QuoteVersion"> | Date | string | null
    createdByUserId?: StringNullableFilter<"QuoteVersion"> | string | null
    createdAt?: DateTimeFilter<"QuoteVersion"> | Date | string
  }

  export type QuoteCreateWithoutItemsInput = {
    id?: string
    title: string
    referenceNo?: string | null
    projectAddress?: string | null
    status?: $Enums.QuoteStatus
    currentVersion?: number
    sentAt?: Date | string | null
    acceptedAt?: Date | string | null
    vatMode?: $Enums.VatMode
    vatRateBps?: number
    depositType?: $Enums.DepositType
    depositAmountPence?: number | null
    depositPercentBps?: number | null
    paymentScheduleJson?: NullableJsonNullValueInput | InputJsonValue
    showQtyToClient?: boolean
    showUnitRatesToClient?: boolean
    scopeOverviewJson?: NullableJsonNullValueInput | InputJsonValue
    termsJson?: NullableJsonNullValueInput | InputJsonValue
    estimatedStartDate?: Date | string | null
    estimatedDurationWeeks?: number | null
    createdByUserId?: string | null
    updatedByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client?: ClientCreateNestedOneWithoutQuotesInput
    publicLinks?: QuotePublicLinkCreateNestedManyWithoutQuoteInput
    pdfs?: QuotePdfCreateNestedManyWithoutQuoteInput
    acceptance?: QuoteAcceptanceCreateNestedOneWithoutQuoteInput
    variations?: VariationCreateNestedManyWithoutQuoteInput
    versions?: QuoteVersionCreateNestedManyWithoutQuoteInput
  }

  export type QuoteUncheckedCreateWithoutItemsInput = {
    id?: string
    orgId: string
    clientId?: string | null
    title: string
    referenceNo?: string | null
    projectAddress?: string | null
    status?: $Enums.QuoteStatus
    currentVersion?: number
    sentAt?: Date | string | null
    acceptedAt?: Date | string | null
    vatMode?: $Enums.VatMode
    vatRateBps?: number
    depositType?: $Enums.DepositType
    depositAmountPence?: number | null
    depositPercentBps?: number | null
    paymentScheduleJson?: NullableJsonNullValueInput | InputJsonValue
    showQtyToClient?: boolean
    showUnitRatesToClient?: boolean
    scopeOverviewJson?: NullableJsonNullValueInput | InputJsonValue
    termsJson?: NullableJsonNullValueInput | InputJsonValue
    estimatedStartDate?: Date | string | null
    estimatedDurationWeeks?: number | null
    createdByUserId?: string | null
    updatedByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    publicLinks?: QuotePublicLinkUncheckedCreateNestedManyWithoutQuoteInput
    pdfs?: QuotePdfUncheckedCreateNestedManyWithoutQuoteInput
    acceptance?: QuoteAcceptanceUncheckedCreateNestedOneWithoutQuoteInput
    variations?: VariationUncheckedCreateNestedManyWithoutQuoteInput
    versions?: QuoteVersionUncheckedCreateNestedManyWithoutQuoteInput
  }

  export type QuoteCreateOrConnectWithoutItemsInput = {
    where: QuoteWhereUniqueInput
    create: XOR<QuoteCreateWithoutItemsInput, QuoteUncheckedCreateWithoutItemsInput>
  }

  export type QuoteItemCreateWithoutChildrenInput = {
    id?: string
    rowType?: $Enums.ItemRowType
    title: string
    description?: string | null
    sortOrder?: number
    roomTag?: string | null
    tradeTag?: string | null
    phaseTag?: string | null
    calcType?: $Enums.CalcType
    qty?: Decimal | DecimalJsLike | number | string | null
    unit?: string | null
    unitPricePence?: number | null
    hours?: Decimal | DecimalJsLike | number | string | null
    hourlyRatePence?: number | null
    sellPricePence?: number | null
    isAllowance?: boolean
    costPence?: number | null
    markupPercentBps?: number | null
    createdByUserId?: string | null
    updatedByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    quote: QuoteCreateNestedOneWithoutItemsInput
    parent?: QuoteItemCreateNestedOneWithoutChildrenInput
  }

  export type QuoteItemUncheckedCreateWithoutChildrenInput = {
    id?: string
    orgId: string
    quoteId: string
    parentId?: string | null
    rowType?: $Enums.ItemRowType
    title: string
    description?: string | null
    sortOrder?: number
    roomTag?: string | null
    tradeTag?: string | null
    phaseTag?: string | null
    calcType?: $Enums.CalcType
    qty?: Decimal | DecimalJsLike | number | string | null
    unit?: string | null
    unitPricePence?: number | null
    hours?: Decimal | DecimalJsLike | number | string | null
    hourlyRatePence?: number | null
    sellPricePence?: number | null
    isAllowance?: boolean
    costPence?: number | null
    markupPercentBps?: number | null
    createdByUserId?: string | null
    updatedByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuoteItemCreateOrConnectWithoutChildrenInput = {
    where: QuoteItemWhereUniqueInput
    create: XOR<QuoteItemCreateWithoutChildrenInput, QuoteItemUncheckedCreateWithoutChildrenInput>
  }

  export type QuoteItemCreateWithoutParentInput = {
    id?: string
    rowType?: $Enums.ItemRowType
    title: string
    description?: string | null
    sortOrder?: number
    roomTag?: string | null
    tradeTag?: string | null
    phaseTag?: string | null
    calcType?: $Enums.CalcType
    qty?: Decimal | DecimalJsLike | number | string | null
    unit?: string | null
    unitPricePence?: number | null
    hours?: Decimal | DecimalJsLike | number | string | null
    hourlyRatePence?: number | null
    sellPricePence?: number | null
    isAllowance?: boolean
    costPence?: number | null
    markupPercentBps?: number | null
    createdByUserId?: string | null
    updatedByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    quote: QuoteCreateNestedOneWithoutItemsInput
    children?: QuoteItemCreateNestedManyWithoutParentInput
  }

  export type QuoteItemUncheckedCreateWithoutParentInput = {
    id?: string
    quoteId: string
    rowType?: $Enums.ItemRowType
    title: string
    description?: string | null
    sortOrder?: number
    roomTag?: string | null
    tradeTag?: string | null
    phaseTag?: string | null
    calcType?: $Enums.CalcType
    qty?: Decimal | DecimalJsLike | number | string | null
    unit?: string | null
    unitPricePence?: number | null
    hours?: Decimal | DecimalJsLike | number | string | null
    hourlyRatePence?: number | null
    sellPricePence?: number | null
    isAllowance?: boolean
    costPence?: number | null
    markupPercentBps?: number | null
    createdByUserId?: string | null
    updatedByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: QuoteItemUncheckedCreateNestedManyWithoutParentInput
  }

  export type QuoteItemCreateOrConnectWithoutParentInput = {
    where: QuoteItemWhereUniqueInput
    create: XOR<QuoteItemCreateWithoutParentInput, QuoteItemUncheckedCreateWithoutParentInput>
  }

  export type QuoteItemCreateManyParentInputEnvelope = {
    data: QuoteItemCreateManyParentInput | QuoteItemCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type QuoteUpsertWithoutItemsInput = {
    update: XOR<QuoteUpdateWithoutItemsInput, QuoteUncheckedUpdateWithoutItemsInput>
    create: XOR<QuoteCreateWithoutItemsInput, QuoteUncheckedCreateWithoutItemsInput>
    where?: QuoteWhereInput
  }

  export type QuoteUpdateToOneWithWhereWithoutItemsInput = {
    where?: QuoteWhereInput
    data: XOR<QuoteUpdateWithoutItemsInput, QuoteUncheckedUpdateWithoutItemsInput>
  }

  export type QuoteUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    referenceNo?: NullableStringFieldUpdateOperationsInput | string | null
    projectAddress?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQuoteStatusFieldUpdateOperationsInput | $Enums.QuoteStatus
    currentVersion?: IntFieldUpdateOperationsInput | number
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatMode?: EnumVatModeFieldUpdateOperationsInput | $Enums.VatMode
    vatRateBps?: IntFieldUpdateOperationsInput | number
    depositType?: EnumDepositTypeFieldUpdateOperationsInput | $Enums.DepositType
    depositAmountPence?: NullableIntFieldUpdateOperationsInput | number | null
    depositPercentBps?: NullableIntFieldUpdateOperationsInput | number | null
    paymentScheduleJson?: NullableJsonNullValueInput | InputJsonValue
    showQtyToClient?: BoolFieldUpdateOperationsInput | boolean
    showUnitRatesToClient?: BoolFieldUpdateOperationsInput | boolean
    scopeOverviewJson?: NullableJsonNullValueInput | InputJsonValue
    termsJson?: NullableJsonNullValueInput | InputJsonValue
    estimatedStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedDurationWeeks?: NullableIntFieldUpdateOperationsInput | number | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneWithoutQuotesNestedInput
    publicLinks?: QuotePublicLinkUpdateManyWithoutQuoteNestedInput
    pdfs?: QuotePdfUpdateManyWithoutQuoteNestedInput
    acceptance?: QuoteAcceptanceUpdateOneWithoutQuoteNestedInput
    variations?: VariationUpdateManyWithoutQuoteNestedInput
    versions?: QuoteVersionUpdateManyWithoutQuoteNestedInput
  }

  export type QuoteUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    referenceNo?: NullableStringFieldUpdateOperationsInput | string | null
    projectAddress?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQuoteStatusFieldUpdateOperationsInput | $Enums.QuoteStatus
    currentVersion?: IntFieldUpdateOperationsInput | number
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatMode?: EnumVatModeFieldUpdateOperationsInput | $Enums.VatMode
    vatRateBps?: IntFieldUpdateOperationsInput | number
    depositType?: EnumDepositTypeFieldUpdateOperationsInput | $Enums.DepositType
    depositAmountPence?: NullableIntFieldUpdateOperationsInput | number | null
    depositPercentBps?: NullableIntFieldUpdateOperationsInput | number | null
    paymentScheduleJson?: NullableJsonNullValueInput | InputJsonValue
    showQtyToClient?: BoolFieldUpdateOperationsInput | boolean
    showUnitRatesToClient?: BoolFieldUpdateOperationsInput | boolean
    scopeOverviewJson?: NullableJsonNullValueInput | InputJsonValue
    termsJson?: NullableJsonNullValueInput | InputJsonValue
    estimatedStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedDurationWeeks?: NullableIntFieldUpdateOperationsInput | number | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publicLinks?: QuotePublicLinkUncheckedUpdateManyWithoutQuoteNestedInput
    pdfs?: QuotePdfUncheckedUpdateManyWithoutQuoteNestedInput
    acceptance?: QuoteAcceptanceUncheckedUpdateOneWithoutQuoteNestedInput
    variations?: VariationUncheckedUpdateManyWithoutQuoteNestedInput
    versions?: QuoteVersionUncheckedUpdateManyWithoutQuoteNestedInput
  }

  export type QuoteItemUpsertWithoutChildrenInput = {
    update: XOR<QuoteItemUpdateWithoutChildrenInput, QuoteItemUncheckedUpdateWithoutChildrenInput>
    create: XOR<QuoteItemCreateWithoutChildrenInput, QuoteItemUncheckedCreateWithoutChildrenInput>
    where?: QuoteItemWhereInput
  }

  export type QuoteItemUpdateToOneWithWhereWithoutChildrenInput = {
    where?: QuoteItemWhereInput
    data: XOR<QuoteItemUpdateWithoutChildrenInput, QuoteItemUncheckedUpdateWithoutChildrenInput>
  }

  export type QuoteItemUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    rowType?: EnumItemRowTypeFieldUpdateOperationsInput | $Enums.ItemRowType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    roomTag?: NullableStringFieldUpdateOperationsInput | string | null
    tradeTag?: NullableStringFieldUpdateOperationsInput | string | null
    phaseTag?: NullableStringFieldUpdateOperationsInput | string | null
    calcType?: EnumCalcTypeFieldUpdateOperationsInput | $Enums.CalcType
    qty?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    unitPricePence?: NullableIntFieldUpdateOperationsInput | number | null
    hours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    hourlyRatePence?: NullableIntFieldUpdateOperationsInput | number | null
    sellPricePence?: NullableIntFieldUpdateOperationsInput | number | null
    isAllowance?: BoolFieldUpdateOperationsInput | boolean
    costPence?: NullableIntFieldUpdateOperationsInput | number | null
    markupPercentBps?: NullableIntFieldUpdateOperationsInput | number | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quote?: QuoteUpdateOneRequiredWithoutItemsNestedInput
    parent?: QuoteItemUpdateOneWithoutChildrenNestedInput
  }

  export type QuoteItemUncheckedUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    quoteId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    rowType?: EnumItemRowTypeFieldUpdateOperationsInput | $Enums.ItemRowType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    roomTag?: NullableStringFieldUpdateOperationsInput | string | null
    tradeTag?: NullableStringFieldUpdateOperationsInput | string | null
    phaseTag?: NullableStringFieldUpdateOperationsInput | string | null
    calcType?: EnumCalcTypeFieldUpdateOperationsInput | $Enums.CalcType
    qty?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    unitPricePence?: NullableIntFieldUpdateOperationsInput | number | null
    hours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    hourlyRatePence?: NullableIntFieldUpdateOperationsInput | number | null
    sellPricePence?: NullableIntFieldUpdateOperationsInput | number | null
    isAllowance?: BoolFieldUpdateOperationsInput | boolean
    costPence?: NullableIntFieldUpdateOperationsInput | number | null
    markupPercentBps?: NullableIntFieldUpdateOperationsInput | number | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuoteItemUpsertWithWhereUniqueWithoutParentInput = {
    where: QuoteItemWhereUniqueInput
    update: XOR<QuoteItemUpdateWithoutParentInput, QuoteItemUncheckedUpdateWithoutParentInput>
    create: XOR<QuoteItemCreateWithoutParentInput, QuoteItemUncheckedCreateWithoutParentInput>
  }

  export type QuoteItemUpdateWithWhereUniqueWithoutParentInput = {
    where: QuoteItemWhereUniqueInput
    data: XOR<QuoteItemUpdateWithoutParentInput, QuoteItemUncheckedUpdateWithoutParentInput>
  }

  export type QuoteItemUpdateManyWithWhereWithoutParentInput = {
    where: QuoteItemScalarWhereInput
    data: XOR<QuoteItemUpdateManyMutationInput, QuoteItemUncheckedUpdateManyWithoutParentInput>
  }

  export type QuoteCreateWithoutVersionsInput = {
    id?: string
    title: string
    referenceNo?: string | null
    projectAddress?: string | null
    status?: $Enums.QuoteStatus
    currentVersion?: number
    sentAt?: Date | string | null
    acceptedAt?: Date | string | null
    vatMode?: $Enums.VatMode
    vatRateBps?: number
    depositType?: $Enums.DepositType
    depositAmountPence?: number | null
    depositPercentBps?: number | null
    paymentScheduleJson?: NullableJsonNullValueInput | InputJsonValue
    showQtyToClient?: boolean
    showUnitRatesToClient?: boolean
    scopeOverviewJson?: NullableJsonNullValueInput | InputJsonValue
    termsJson?: NullableJsonNullValueInput | InputJsonValue
    estimatedStartDate?: Date | string | null
    estimatedDurationWeeks?: number | null
    createdByUserId?: string | null
    updatedByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client?: ClientCreateNestedOneWithoutQuotesInput
    items?: QuoteItemCreateNestedManyWithoutQuoteInput
    publicLinks?: QuotePublicLinkCreateNestedManyWithoutQuoteInput
    pdfs?: QuotePdfCreateNestedManyWithoutQuoteInput
    acceptance?: QuoteAcceptanceCreateNestedOneWithoutQuoteInput
    variations?: VariationCreateNestedManyWithoutQuoteInput
  }

  export type QuoteUncheckedCreateWithoutVersionsInput = {
    id?: string
    orgId: string
    clientId?: string | null
    title: string
    referenceNo?: string | null
    projectAddress?: string | null
    status?: $Enums.QuoteStatus
    currentVersion?: number
    sentAt?: Date | string | null
    acceptedAt?: Date | string | null
    vatMode?: $Enums.VatMode
    vatRateBps?: number
    depositType?: $Enums.DepositType
    depositAmountPence?: number | null
    depositPercentBps?: number | null
    paymentScheduleJson?: NullableJsonNullValueInput | InputJsonValue
    showQtyToClient?: boolean
    showUnitRatesToClient?: boolean
    scopeOverviewJson?: NullableJsonNullValueInput | InputJsonValue
    termsJson?: NullableJsonNullValueInput | InputJsonValue
    estimatedStartDate?: Date | string | null
    estimatedDurationWeeks?: number | null
    createdByUserId?: string | null
    updatedByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: QuoteItemUncheckedCreateNestedManyWithoutQuoteInput
    publicLinks?: QuotePublicLinkUncheckedCreateNestedManyWithoutQuoteInput
    pdfs?: QuotePdfUncheckedCreateNestedManyWithoutQuoteInput
    acceptance?: QuoteAcceptanceUncheckedCreateNestedOneWithoutQuoteInput
    variations?: VariationUncheckedCreateNestedManyWithoutQuoteInput
  }

  export type QuoteCreateOrConnectWithoutVersionsInput = {
    where: QuoteWhereUniqueInput
    create: XOR<QuoteCreateWithoutVersionsInput, QuoteUncheckedCreateWithoutVersionsInput>
  }

  export type QuoteVersionItemCreateWithoutQuoteVersionInput = {
    id?: string
    sourceQuoteItemId?: string | null
    rowType?: $Enums.ItemRowType
    title: string
    description?: string | null
    sortOrder?: number
    roomTag?: string | null
    tradeTag?: string | null
    phaseTag?: string | null
    calcType?: $Enums.CalcType
    qty?: Decimal | DecimalJsLike | number | string | null
    unit?: string | null
    unitPricePence?: number | null
    hours?: Decimal | DecimalJsLike | number | string | null
    hourlyRatePence?: number | null
    sellPricePence?: number | null
    isAllowance?: boolean
    lineTotalPence?: number | null
    createdAt?: Date | string
    parent?: QuoteVersionItemCreateNestedOneWithoutChildrenInput
    children?: QuoteVersionItemCreateNestedManyWithoutParentInput
  }

  export type QuoteVersionItemUncheckedCreateWithoutQuoteVersionInput = {
    id?: string
    parentId?: string | null
    sourceQuoteItemId?: string | null
    rowType?: $Enums.ItemRowType
    title: string
    description?: string | null
    sortOrder?: number
    roomTag?: string | null
    tradeTag?: string | null
    phaseTag?: string | null
    calcType?: $Enums.CalcType
    qty?: Decimal | DecimalJsLike | number | string | null
    unit?: string | null
    unitPricePence?: number | null
    hours?: Decimal | DecimalJsLike | number | string | null
    hourlyRatePence?: number | null
    sellPricePence?: number | null
    isAllowance?: boolean
    lineTotalPence?: number | null
    createdAt?: Date | string
    children?: QuoteVersionItemUncheckedCreateNestedManyWithoutParentInput
  }

  export type QuoteVersionItemCreateOrConnectWithoutQuoteVersionInput = {
    where: QuoteVersionItemWhereUniqueInput
    create: XOR<QuoteVersionItemCreateWithoutQuoteVersionInput, QuoteVersionItemUncheckedCreateWithoutQuoteVersionInput>
  }

  export type QuoteVersionItemCreateManyQuoteVersionInputEnvelope = {
    data: QuoteVersionItemCreateManyQuoteVersionInput | QuoteVersionItemCreateManyQuoteVersionInput[]
    skipDuplicates?: boolean
  }

  export type QuoteUpsertWithoutVersionsInput = {
    update: XOR<QuoteUpdateWithoutVersionsInput, QuoteUncheckedUpdateWithoutVersionsInput>
    create: XOR<QuoteCreateWithoutVersionsInput, QuoteUncheckedCreateWithoutVersionsInput>
    where?: QuoteWhereInput
  }

  export type QuoteUpdateToOneWithWhereWithoutVersionsInput = {
    where?: QuoteWhereInput
    data: XOR<QuoteUpdateWithoutVersionsInput, QuoteUncheckedUpdateWithoutVersionsInput>
  }

  export type QuoteUpdateWithoutVersionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    referenceNo?: NullableStringFieldUpdateOperationsInput | string | null
    projectAddress?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQuoteStatusFieldUpdateOperationsInput | $Enums.QuoteStatus
    currentVersion?: IntFieldUpdateOperationsInput | number
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatMode?: EnumVatModeFieldUpdateOperationsInput | $Enums.VatMode
    vatRateBps?: IntFieldUpdateOperationsInput | number
    depositType?: EnumDepositTypeFieldUpdateOperationsInput | $Enums.DepositType
    depositAmountPence?: NullableIntFieldUpdateOperationsInput | number | null
    depositPercentBps?: NullableIntFieldUpdateOperationsInput | number | null
    paymentScheduleJson?: NullableJsonNullValueInput | InputJsonValue
    showQtyToClient?: BoolFieldUpdateOperationsInput | boolean
    showUnitRatesToClient?: BoolFieldUpdateOperationsInput | boolean
    scopeOverviewJson?: NullableJsonNullValueInput | InputJsonValue
    termsJson?: NullableJsonNullValueInput | InputJsonValue
    estimatedStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedDurationWeeks?: NullableIntFieldUpdateOperationsInput | number | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneWithoutQuotesNestedInput
    items?: QuoteItemUpdateManyWithoutQuoteNestedInput
    publicLinks?: QuotePublicLinkUpdateManyWithoutQuoteNestedInput
    pdfs?: QuotePdfUpdateManyWithoutQuoteNestedInput
    acceptance?: QuoteAcceptanceUpdateOneWithoutQuoteNestedInput
    variations?: VariationUpdateManyWithoutQuoteNestedInput
  }

  export type QuoteUncheckedUpdateWithoutVersionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    referenceNo?: NullableStringFieldUpdateOperationsInput | string | null
    projectAddress?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQuoteStatusFieldUpdateOperationsInput | $Enums.QuoteStatus
    currentVersion?: IntFieldUpdateOperationsInput | number
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatMode?: EnumVatModeFieldUpdateOperationsInput | $Enums.VatMode
    vatRateBps?: IntFieldUpdateOperationsInput | number
    depositType?: EnumDepositTypeFieldUpdateOperationsInput | $Enums.DepositType
    depositAmountPence?: NullableIntFieldUpdateOperationsInput | number | null
    depositPercentBps?: NullableIntFieldUpdateOperationsInput | number | null
    paymentScheduleJson?: NullableJsonNullValueInput | InputJsonValue
    showQtyToClient?: BoolFieldUpdateOperationsInput | boolean
    showUnitRatesToClient?: BoolFieldUpdateOperationsInput | boolean
    scopeOverviewJson?: NullableJsonNullValueInput | InputJsonValue
    termsJson?: NullableJsonNullValueInput | InputJsonValue
    estimatedStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedDurationWeeks?: NullableIntFieldUpdateOperationsInput | number | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: QuoteItemUncheckedUpdateManyWithoutQuoteNestedInput
    publicLinks?: QuotePublicLinkUncheckedUpdateManyWithoutQuoteNestedInput
    pdfs?: QuotePdfUncheckedUpdateManyWithoutQuoteNestedInput
    acceptance?: QuoteAcceptanceUncheckedUpdateOneWithoutQuoteNestedInput
    variations?: VariationUncheckedUpdateManyWithoutQuoteNestedInput
  }

  export type QuoteVersionItemUpsertWithWhereUniqueWithoutQuoteVersionInput = {
    where: QuoteVersionItemWhereUniqueInput
    update: XOR<QuoteVersionItemUpdateWithoutQuoteVersionInput, QuoteVersionItemUncheckedUpdateWithoutQuoteVersionInput>
    create: XOR<QuoteVersionItemCreateWithoutQuoteVersionInput, QuoteVersionItemUncheckedCreateWithoutQuoteVersionInput>
  }

  export type QuoteVersionItemUpdateWithWhereUniqueWithoutQuoteVersionInput = {
    where: QuoteVersionItemWhereUniqueInput
    data: XOR<QuoteVersionItemUpdateWithoutQuoteVersionInput, QuoteVersionItemUncheckedUpdateWithoutQuoteVersionInput>
  }

  export type QuoteVersionItemUpdateManyWithWhereWithoutQuoteVersionInput = {
    where: QuoteVersionItemScalarWhereInput
    data: XOR<QuoteVersionItemUpdateManyMutationInput, QuoteVersionItemUncheckedUpdateManyWithoutQuoteVersionInput>
  }

  export type QuoteVersionItemScalarWhereInput = {
    AND?: QuoteVersionItemScalarWhereInput | QuoteVersionItemScalarWhereInput[]
    OR?: QuoteVersionItemScalarWhereInput[]
    NOT?: QuoteVersionItemScalarWhereInput | QuoteVersionItemScalarWhereInput[]
    id?: StringFilter<"QuoteVersionItem"> | string
    orgId?: StringFilter<"QuoteVersionItem"> | string
    quoteVersionId?: StringFilter<"QuoteVersionItem"> | string
    parentId?: StringNullableFilter<"QuoteVersionItem"> | string | null
    sourceQuoteItemId?: StringNullableFilter<"QuoteVersionItem"> | string | null
    rowType?: EnumItemRowTypeFilter<"QuoteVersionItem"> | $Enums.ItemRowType
    title?: StringFilter<"QuoteVersionItem"> | string
    description?: StringNullableFilter<"QuoteVersionItem"> | string | null
    sortOrder?: IntFilter<"QuoteVersionItem"> | number
    roomTag?: StringNullableFilter<"QuoteVersionItem"> | string | null
    tradeTag?: StringNullableFilter<"QuoteVersionItem"> | string | null
    phaseTag?: StringNullableFilter<"QuoteVersionItem"> | string | null
    calcType?: EnumCalcTypeFilter<"QuoteVersionItem"> | $Enums.CalcType
    qty?: DecimalNullableFilter<"QuoteVersionItem"> | Decimal | DecimalJsLike | number | string | null
    unit?: StringNullableFilter<"QuoteVersionItem"> | string | null
    unitPricePence?: IntNullableFilter<"QuoteVersionItem"> | number | null
    hours?: DecimalNullableFilter<"QuoteVersionItem"> | Decimal | DecimalJsLike | number | string | null
    hourlyRatePence?: IntNullableFilter<"QuoteVersionItem"> | number | null
    sellPricePence?: IntNullableFilter<"QuoteVersionItem"> | number | null
    isAllowance?: BoolFilter<"QuoteVersionItem"> | boolean
    lineTotalPence?: IntNullableFilter<"QuoteVersionItem"> | number | null
    createdAt?: DateTimeFilter<"QuoteVersionItem"> | Date | string
  }

  export type QuoteVersionCreateWithoutItemsInput = {
    id?: string
    version: number
    status: $Enums.QuoteStatus
    vatMode: $Enums.VatMode
    vatRateBps: number
    depositType: $Enums.DepositType
    depositAmountPence?: number | null
    depositPercentBps?: number | null
    showQtyToClient: boolean
    showUnitRatesToClient: boolean
    title: string
    referenceNo?: string | null
    projectAddress?: string | null
    scopeOverviewJson?: NullableJsonNullValueInput | InputJsonValue
    termsJson?: NullableJsonNullValueInput | InputJsonValue
    paymentScheduleJson?: NullableJsonNullValueInput | InputJsonValue
    subtotalPence?: number | null
    vatPence?: number | null
    totalPence?: number | null
    sentAt?: Date | string | null
    createdByUserId?: string | null
    createdAt?: Date | string
    quote: QuoteCreateNestedOneWithoutVersionsInput
  }

  export type QuoteVersionUncheckedCreateWithoutItemsInput = {
    id?: string
    orgId: string
    quoteId: string
    version: number
    status: $Enums.QuoteStatus
    vatMode: $Enums.VatMode
    vatRateBps: number
    depositType: $Enums.DepositType
    depositAmountPence?: number | null
    depositPercentBps?: number | null
    showQtyToClient: boolean
    showUnitRatesToClient: boolean
    title: string
    referenceNo?: string | null
    projectAddress?: string | null
    scopeOverviewJson?: NullableJsonNullValueInput | InputJsonValue
    termsJson?: NullableJsonNullValueInput | InputJsonValue
    paymentScheduleJson?: NullableJsonNullValueInput | InputJsonValue
    subtotalPence?: number | null
    vatPence?: number | null
    totalPence?: number | null
    sentAt?: Date | string | null
    createdByUserId?: string | null
    createdAt?: Date | string
  }

  export type QuoteVersionCreateOrConnectWithoutItemsInput = {
    where: QuoteVersionWhereUniqueInput
    create: XOR<QuoteVersionCreateWithoutItemsInput, QuoteVersionUncheckedCreateWithoutItemsInput>
  }

  export type QuoteVersionItemCreateWithoutChildrenInput = {
    id?: string
    sourceQuoteItemId?: string | null
    rowType?: $Enums.ItemRowType
    title: string
    description?: string | null
    sortOrder?: number
    roomTag?: string | null
    tradeTag?: string | null
    phaseTag?: string | null
    calcType?: $Enums.CalcType
    qty?: Decimal | DecimalJsLike | number | string | null
    unit?: string | null
    unitPricePence?: number | null
    hours?: Decimal | DecimalJsLike | number | string | null
    hourlyRatePence?: number | null
    sellPricePence?: number | null
    isAllowance?: boolean
    lineTotalPence?: number | null
    createdAt?: Date | string
    quoteVersion: QuoteVersionCreateNestedOneWithoutItemsInput
    parent?: QuoteVersionItemCreateNestedOneWithoutChildrenInput
  }

  export type QuoteVersionItemUncheckedCreateWithoutChildrenInput = {
    id?: string
    orgId: string
    quoteVersionId: string
    parentId?: string | null
    sourceQuoteItemId?: string | null
    rowType?: $Enums.ItemRowType
    title: string
    description?: string | null
    sortOrder?: number
    roomTag?: string | null
    tradeTag?: string | null
    phaseTag?: string | null
    calcType?: $Enums.CalcType
    qty?: Decimal | DecimalJsLike | number | string | null
    unit?: string | null
    unitPricePence?: number | null
    hours?: Decimal | DecimalJsLike | number | string | null
    hourlyRatePence?: number | null
    sellPricePence?: number | null
    isAllowance?: boolean
    lineTotalPence?: number | null
    createdAt?: Date | string
  }

  export type QuoteVersionItemCreateOrConnectWithoutChildrenInput = {
    where: QuoteVersionItemWhereUniqueInput
    create: XOR<QuoteVersionItemCreateWithoutChildrenInput, QuoteVersionItemUncheckedCreateWithoutChildrenInput>
  }

  export type QuoteVersionItemCreateWithoutParentInput = {
    id?: string
    sourceQuoteItemId?: string | null
    rowType?: $Enums.ItemRowType
    title: string
    description?: string | null
    sortOrder?: number
    roomTag?: string | null
    tradeTag?: string | null
    phaseTag?: string | null
    calcType?: $Enums.CalcType
    qty?: Decimal | DecimalJsLike | number | string | null
    unit?: string | null
    unitPricePence?: number | null
    hours?: Decimal | DecimalJsLike | number | string | null
    hourlyRatePence?: number | null
    sellPricePence?: number | null
    isAllowance?: boolean
    lineTotalPence?: number | null
    createdAt?: Date | string
    quoteVersion: QuoteVersionCreateNestedOneWithoutItemsInput
    children?: QuoteVersionItemCreateNestedManyWithoutParentInput
  }

  export type QuoteVersionItemUncheckedCreateWithoutParentInput = {
    id?: string
    quoteVersionId: string
    sourceQuoteItemId?: string | null
    rowType?: $Enums.ItemRowType
    title: string
    description?: string | null
    sortOrder?: number
    roomTag?: string | null
    tradeTag?: string | null
    phaseTag?: string | null
    calcType?: $Enums.CalcType
    qty?: Decimal | DecimalJsLike | number | string | null
    unit?: string | null
    unitPricePence?: number | null
    hours?: Decimal | DecimalJsLike | number | string | null
    hourlyRatePence?: number | null
    sellPricePence?: number | null
    isAllowance?: boolean
    lineTotalPence?: number | null
    createdAt?: Date | string
    children?: QuoteVersionItemUncheckedCreateNestedManyWithoutParentInput
  }

  export type QuoteVersionItemCreateOrConnectWithoutParentInput = {
    where: QuoteVersionItemWhereUniqueInput
    create: XOR<QuoteVersionItemCreateWithoutParentInput, QuoteVersionItemUncheckedCreateWithoutParentInput>
  }

  export type QuoteVersionItemCreateManyParentInputEnvelope = {
    data: QuoteVersionItemCreateManyParentInput | QuoteVersionItemCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type QuoteVersionUpsertWithoutItemsInput = {
    update: XOR<QuoteVersionUpdateWithoutItemsInput, QuoteVersionUncheckedUpdateWithoutItemsInput>
    create: XOR<QuoteVersionCreateWithoutItemsInput, QuoteVersionUncheckedCreateWithoutItemsInput>
    where?: QuoteVersionWhereInput
  }

  export type QuoteVersionUpdateToOneWithWhereWithoutItemsInput = {
    where?: QuoteVersionWhereInput
    data: XOR<QuoteVersionUpdateWithoutItemsInput, QuoteVersionUncheckedUpdateWithoutItemsInput>
  }

  export type QuoteVersionUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumQuoteStatusFieldUpdateOperationsInput | $Enums.QuoteStatus
    vatMode?: EnumVatModeFieldUpdateOperationsInput | $Enums.VatMode
    vatRateBps?: IntFieldUpdateOperationsInput | number
    depositType?: EnumDepositTypeFieldUpdateOperationsInput | $Enums.DepositType
    depositAmountPence?: NullableIntFieldUpdateOperationsInput | number | null
    depositPercentBps?: NullableIntFieldUpdateOperationsInput | number | null
    showQtyToClient?: BoolFieldUpdateOperationsInput | boolean
    showUnitRatesToClient?: BoolFieldUpdateOperationsInput | boolean
    title?: StringFieldUpdateOperationsInput | string
    referenceNo?: NullableStringFieldUpdateOperationsInput | string | null
    projectAddress?: NullableStringFieldUpdateOperationsInput | string | null
    scopeOverviewJson?: NullableJsonNullValueInput | InputJsonValue
    termsJson?: NullableJsonNullValueInput | InputJsonValue
    paymentScheduleJson?: NullableJsonNullValueInput | InputJsonValue
    subtotalPence?: NullableIntFieldUpdateOperationsInput | number | null
    vatPence?: NullableIntFieldUpdateOperationsInput | number | null
    totalPence?: NullableIntFieldUpdateOperationsInput | number | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quote?: QuoteUpdateOneRequiredWithoutVersionsNestedInput
  }

  export type QuoteVersionUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    quoteId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumQuoteStatusFieldUpdateOperationsInput | $Enums.QuoteStatus
    vatMode?: EnumVatModeFieldUpdateOperationsInput | $Enums.VatMode
    vatRateBps?: IntFieldUpdateOperationsInput | number
    depositType?: EnumDepositTypeFieldUpdateOperationsInput | $Enums.DepositType
    depositAmountPence?: NullableIntFieldUpdateOperationsInput | number | null
    depositPercentBps?: NullableIntFieldUpdateOperationsInput | number | null
    showQtyToClient?: BoolFieldUpdateOperationsInput | boolean
    showUnitRatesToClient?: BoolFieldUpdateOperationsInput | boolean
    title?: StringFieldUpdateOperationsInput | string
    referenceNo?: NullableStringFieldUpdateOperationsInput | string | null
    projectAddress?: NullableStringFieldUpdateOperationsInput | string | null
    scopeOverviewJson?: NullableJsonNullValueInput | InputJsonValue
    termsJson?: NullableJsonNullValueInput | InputJsonValue
    paymentScheduleJson?: NullableJsonNullValueInput | InputJsonValue
    subtotalPence?: NullableIntFieldUpdateOperationsInput | number | null
    vatPence?: NullableIntFieldUpdateOperationsInput | number | null
    totalPence?: NullableIntFieldUpdateOperationsInput | number | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuoteVersionItemUpsertWithoutChildrenInput = {
    update: XOR<QuoteVersionItemUpdateWithoutChildrenInput, QuoteVersionItemUncheckedUpdateWithoutChildrenInput>
    create: XOR<QuoteVersionItemCreateWithoutChildrenInput, QuoteVersionItemUncheckedCreateWithoutChildrenInput>
    where?: QuoteVersionItemWhereInput
  }

  export type QuoteVersionItemUpdateToOneWithWhereWithoutChildrenInput = {
    where?: QuoteVersionItemWhereInput
    data: XOR<QuoteVersionItemUpdateWithoutChildrenInput, QuoteVersionItemUncheckedUpdateWithoutChildrenInput>
  }

  export type QuoteVersionItemUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceQuoteItemId?: NullableStringFieldUpdateOperationsInput | string | null
    rowType?: EnumItemRowTypeFieldUpdateOperationsInput | $Enums.ItemRowType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    roomTag?: NullableStringFieldUpdateOperationsInput | string | null
    tradeTag?: NullableStringFieldUpdateOperationsInput | string | null
    phaseTag?: NullableStringFieldUpdateOperationsInput | string | null
    calcType?: EnumCalcTypeFieldUpdateOperationsInput | $Enums.CalcType
    qty?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    unitPricePence?: NullableIntFieldUpdateOperationsInput | number | null
    hours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    hourlyRatePence?: NullableIntFieldUpdateOperationsInput | number | null
    sellPricePence?: NullableIntFieldUpdateOperationsInput | number | null
    isAllowance?: BoolFieldUpdateOperationsInput | boolean
    lineTotalPence?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quoteVersion?: QuoteVersionUpdateOneRequiredWithoutItemsNestedInput
    parent?: QuoteVersionItemUpdateOneWithoutChildrenNestedInput
  }

  export type QuoteVersionItemUncheckedUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    quoteVersionId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceQuoteItemId?: NullableStringFieldUpdateOperationsInput | string | null
    rowType?: EnumItemRowTypeFieldUpdateOperationsInput | $Enums.ItemRowType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    roomTag?: NullableStringFieldUpdateOperationsInput | string | null
    tradeTag?: NullableStringFieldUpdateOperationsInput | string | null
    phaseTag?: NullableStringFieldUpdateOperationsInput | string | null
    calcType?: EnumCalcTypeFieldUpdateOperationsInput | $Enums.CalcType
    qty?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    unitPricePence?: NullableIntFieldUpdateOperationsInput | number | null
    hours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    hourlyRatePence?: NullableIntFieldUpdateOperationsInput | number | null
    sellPricePence?: NullableIntFieldUpdateOperationsInput | number | null
    isAllowance?: BoolFieldUpdateOperationsInput | boolean
    lineTotalPence?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuoteVersionItemUpsertWithWhereUniqueWithoutParentInput = {
    where: QuoteVersionItemWhereUniqueInput
    update: XOR<QuoteVersionItemUpdateWithoutParentInput, QuoteVersionItemUncheckedUpdateWithoutParentInput>
    create: XOR<QuoteVersionItemCreateWithoutParentInput, QuoteVersionItemUncheckedCreateWithoutParentInput>
  }

  export type QuoteVersionItemUpdateWithWhereUniqueWithoutParentInput = {
    where: QuoteVersionItemWhereUniqueInput
    data: XOR<QuoteVersionItemUpdateWithoutParentInput, QuoteVersionItemUncheckedUpdateWithoutParentInput>
  }

  export type QuoteVersionItemUpdateManyWithWhereWithoutParentInput = {
    where: QuoteVersionItemScalarWhereInput
    data: XOR<QuoteVersionItemUpdateManyMutationInput, QuoteVersionItemUncheckedUpdateManyWithoutParentInput>
  }

  export type QuoteCreateWithoutPublicLinksInput = {
    id?: string
    title: string
    referenceNo?: string | null
    projectAddress?: string | null
    status?: $Enums.QuoteStatus
    currentVersion?: number
    sentAt?: Date | string | null
    acceptedAt?: Date | string | null
    vatMode?: $Enums.VatMode
    vatRateBps?: number
    depositType?: $Enums.DepositType
    depositAmountPence?: number | null
    depositPercentBps?: number | null
    paymentScheduleJson?: NullableJsonNullValueInput | InputJsonValue
    showQtyToClient?: boolean
    showUnitRatesToClient?: boolean
    scopeOverviewJson?: NullableJsonNullValueInput | InputJsonValue
    termsJson?: NullableJsonNullValueInput | InputJsonValue
    estimatedStartDate?: Date | string | null
    estimatedDurationWeeks?: number | null
    createdByUserId?: string | null
    updatedByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client?: ClientCreateNestedOneWithoutQuotesInput
    items?: QuoteItemCreateNestedManyWithoutQuoteInput
    pdfs?: QuotePdfCreateNestedManyWithoutQuoteInput
    acceptance?: QuoteAcceptanceCreateNestedOneWithoutQuoteInput
    variations?: VariationCreateNestedManyWithoutQuoteInput
    versions?: QuoteVersionCreateNestedManyWithoutQuoteInput
  }

  export type QuoteUncheckedCreateWithoutPublicLinksInput = {
    id?: string
    orgId: string
    clientId?: string | null
    title: string
    referenceNo?: string | null
    projectAddress?: string | null
    status?: $Enums.QuoteStatus
    currentVersion?: number
    sentAt?: Date | string | null
    acceptedAt?: Date | string | null
    vatMode?: $Enums.VatMode
    vatRateBps?: number
    depositType?: $Enums.DepositType
    depositAmountPence?: number | null
    depositPercentBps?: number | null
    paymentScheduleJson?: NullableJsonNullValueInput | InputJsonValue
    showQtyToClient?: boolean
    showUnitRatesToClient?: boolean
    scopeOverviewJson?: NullableJsonNullValueInput | InputJsonValue
    termsJson?: NullableJsonNullValueInput | InputJsonValue
    estimatedStartDate?: Date | string | null
    estimatedDurationWeeks?: number | null
    createdByUserId?: string | null
    updatedByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: QuoteItemUncheckedCreateNestedManyWithoutQuoteInput
    pdfs?: QuotePdfUncheckedCreateNestedManyWithoutQuoteInput
    acceptance?: QuoteAcceptanceUncheckedCreateNestedOneWithoutQuoteInput
    variations?: VariationUncheckedCreateNestedManyWithoutQuoteInput
    versions?: QuoteVersionUncheckedCreateNestedManyWithoutQuoteInput
  }

  export type QuoteCreateOrConnectWithoutPublicLinksInput = {
    where: QuoteWhereUniqueInput
    create: XOR<QuoteCreateWithoutPublicLinksInput, QuoteUncheckedCreateWithoutPublicLinksInput>
  }

  export type QuoteUpsertWithoutPublicLinksInput = {
    update: XOR<QuoteUpdateWithoutPublicLinksInput, QuoteUncheckedUpdateWithoutPublicLinksInput>
    create: XOR<QuoteCreateWithoutPublicLinksInput, QuoteUncheckedCreateWithoutPublicLinksInput>
    where?: QuoteWhereInput
  }

  export type QuoteUpdateToOneWithWhereWithoutPublicLinksInput = {
    where?: QuoteWhereInput
    data: XOR<QuoteUpdateWithoutPublicLinksInput, QuoteUncheckedUpdateWithoutPublicLinksInput>
  }

  export type QuoteUpdateWithoutPublicLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    referenceNo?: NullableStringFieldUpdateOperationsInput | string | null
    projectAddress?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQuoteStatusFieldUpdateOperationsInput | $Enums.QuoteStatus
    currentVersion?: IntFieldUpdateOperationsInput | number
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatMode?: EnumVatModeFieldUpdateOperationsInput | $Enums.VatMode
    vatRateBps?: IntFieldUpdateOperationsInput | number
    depositType?: EnumDepositTypeFieldUpdateOperationsInput | $Enums.DepositType
    depositAmountPence?: NullableIntFieldUpdateOperationsInput | number | null
    depositPercentBps?: NullableIntFieldUpdateOperationsInput | number | null
    paymentScheduleJson?: NullableJsonNullValueInput | InputJsonValue
    showQtyToClient?: BoolFieldUpdateOperationsInput | boolean
    showUnitRatesToClient?: BoolFieldUpdateOperationsInput | boolean
    scopeOverviewJson?: NullableJsonNullValueInput | InputJsonValue
    termsJson?: NullableJsonNullValueInput | InputJsonValue
    estimatedStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedDurationWeeks?: NullableIntFieldUpdateOperationsInput | number | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneWithoutQuotesNestedInput
    items?: QuoteItemUpdateManyWithoutQuoteNestedInput
    pdfs?: QuotePdfUpdateManyWithoutQuoteNestedInput
    acceptance?: QuoteAcceptanceUpdateOneWithoutQuoteNestedInput
    variations?: VariationUpdateManyWithoutQuoteNestedInput
    versions?: QuoteVersionUpdateManyWithoutQuoteNestedInput
  }

  export type QuoteUncheckedUpdateWithoutPublicLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    referenceNo?: NullableStringFieldUpdateOperationsInput | string | null
    projectAddress?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQuoteStatusFieldUpdateOperationsInput | $Enums.QuoteStatus
    currentVersion?: IntFieldUpdateOperationsInput | number
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatMode?: EnumVatModeFieldUpdateOperationsInput | $Enums.VatMode
    vatRateBps?: IntFieldUpdateOperationsInput | number
    depositType?: EnumDepositTypeFieldUpdateOperationsInput | $Enums.DepositType
    depositAmountPence?: NullableIntFieldUpdateOperationsInput | number | null
    depositPercentBps?: NullableIntFieldUpdateOperationsInput | number | null
    paymentScheduleJson?: NullableJsonNullValueInput | InputJsonValue
    showQtyToClient?: BoolFieldUpdateOperationsInput | boolean
    showUnitRatesToClient?: BoolFieldUpdateOperationsInput | boolean
    scopeOverviewJson?: NullableJsonNullValueInput | InputJsonValue
    termsJson?: NullableJsonNullValueInput | InputJsonValue
    estimatedStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedDurationWeeks?: NullableIntFieldUpdateOperationsInput | number | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: QuoteItemUncheckedUpdateManyWithoutQuoteNestedInput
    pdfs?: QuotePdfUncheckedUpdateManyWithoutQuoteNestedInput
    acceptance?: QuoteAcceptanceUncheckedUpdateOneWithoutQuoteNestedInput
    variations?: VariationUncheckedUpdateManyWithoutQuoteNestedInput
    versions?: QuoteVersionUncheckedUpdateManyWithoutQuoteNestedInput
  }

  export type QuoteCreateWithoutPdfsInput = {
    id?: string
    title: string
    referenceNo?: string | null
    projectAddress?: string | null
    status?: $Enums.QuoteStatus
    currentVersion?: number
    sentAt?: Date | string | null
    acceptedAt?: Date | string | null
    vatMode?: $Enums.VatMode
    vatRateBps?: number
    depositType?: $Enums.DepositType
    depositAmountPence?: number | null
    depositPercentBps?: number | null
    paymentScheduleJson?: NullableJsonNullValueInput | InputJsonValue
    showQtyToClient?: boolean
    showUnitRatesToClient?: boolean
    scopeOverviewJson?: NullableJsonNullValueInput | InputJsonValue
    termsJson?: NullableJsonNullValueInput | InputJsonValue
    estimatedStartDate?: Date | string | null
    estimatedDurationWeeks?: number | null
    createdByUserId?: string | null
    updatedByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client?: ClientCreateNestedOneWithoutQuotesInput
    items?: QuoteItemCreateNestedManyWithoutQuoteInput
    publicLinks?: QuotePublicLinkCreateNestedManyWithoutQuoteInput
    acceptance?: QuoteAcceptanceCreateNestedOneWithoutQuoteInput
    variations?: VariationCreateNestedManyWithoutQuoteInput
    versions?: QuoteVersionCreateNestedManyWithoutQuoteInput
  }

  export type QuoteUncheckedCreateWithoutPdfsInput = {
    id?: string
    orgId: string
    clientId?: string | null
    title: string
    referenceNo?: string | null
    projectAddress?: string | null
    status?: $Enums.QuoteStatus
    currentVersion?: number
    sentAt?: Date | string | null
    acceptedAt?: Date | string | null
    vatMode?: $Enums.VatMode
    vatRateBps?: number
    depositType?: $Enums.DepositType
    depositAmountPence?: number | null
    depositPercentBps?: number | null
    paymentScheduleJson?: NullableJsonNullValueInput | InputJsonValue
    showQtyToClient?: boolean
    showUnitRatesToClient?: boolean
    scopeOverviewJson?: NullableJsonNullValueInput | InputJsonValue
    termsJson?: NullableJsonNullValueInput | InputJsonValue
    estimatedStartDate?: Date | string | null
    estimatedDurationWeeks?: number | null
    createdByUserId?: string | null
    updatedByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: QuoteItemUncheckedCreateNestedManyWithoutQuoteInput
    publicLinks?: QuotePublicLinkUncheckedCreateNestedManyWithoutQuoteInput
    acceptance?: QuoteAcceptanceUncheckedCreateNestedOneWithoutQuoteInput
    variations?: VariationUncheckedCreateNestedManyWithoutQuoteInput
    versions?: QuoteVersionUncheckedCreateNestedManyWithoutQuoteInput
  }

  export type QuoteCreateOrConnectWithoutPdfsInput = {
    where: QuoteWhereUniqueInput
    create: XOR<QuoteCreateWithoutPdfsInput, QuoteUncheckedCreateWithoutPdfsInput>
  }

  export type QuoteUpsertWithoutPdfsInput = {
    update: XOR<QuoteUpdateWithoutPdfsInput, QuoteUncheckedUpdateWithoutPdfsInput>
    create: XOR<QuoteCreateWithoutPdfsInput, QuoteUncheckedCreateWithoutPdfsInput>
    where?: QuoteWhereInput
  }

  export type QuoteUpdateToOneWithWhereWithoutPdfsInput = {
    where?: QuoteWhereInput
    data: XOR<QuoteUpdateWithoutPdfsInput, QuoteUncheckedUpdateWithoutPdfsInput>
  }

  export type QuoteUpdateWithoutPdfsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    referenceNo?: NullableStringFieldUpdateOperationsInput | string | null
    projectAddress?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQuoteStatusFieldUpdateOperationsInput | $Enums.QuoteStatus
    currentVersion?: IntFieldUpdateOperationsInput | number
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatMode?: EnumVatModeFieldUpdateOperationsInput | $Enums.VatMode
    vatRateBps?: IntFieldUpdateOperationsInput | number
    depositType?: EnumDepositTypeFieldUpdateOperationsInput | $Enums.DepositType
    depositAmountPence?: NullableIntFieldUpdateOperationsInput | number | null
    depositPercentBps?: NullableIntFieldUpdateOperationsInput | number | null
    paymentScheduleJson?: NullableJsonNullValueInput | InputJsonValue
    showQtyToClient?: BoolFieldUpdateOperationsInput | boolean
    showUnitRatesToClient?: BoolFieldUpdateOperationsInput | boolean
    scopeOverviewJson?: NullableJsonNullValueInput | InputJsonValue
    termsJson?: NullableJsonNullValueInput | InputJsonValue
    estimatedStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedDurationWeeks?: NullableIntFieldUpdateOperationsInput | number | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneWithoutQuotesNestedInput
    items?: QuoteItemUpdateManyWithoutQuoteNestedInput
    publicLinks?: QuotePublicLinkUpdateManyWithoutQuoteNestedInput
    acceptance?: QuoteAcceptanceUpdateOneWithoutQuoteNestedInput
    variations?: VariationUpdateManyWithoutQuoteNestedInput
    versions?: QuoteVersionUpdateManyWithoutQuoteNestedInput
  }

  export type QuoteUncheckedUpdateWithoutPdfsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    referenceNo?: NullableStringFieldUpdateOperationsInput | string | null
    projectAddress?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQuoteStatusFieldUpdateOperationsInput | $Enums.QuoteStatus
    currentVersion?: IntFieldUpdateOperationsInput | number
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatMode?: EnumVatModeFieldUpdateOperationsInput | $Enums.VatMode
    vatRateBps?: IntFieldUpdateOperationsInput | number
    depositType?: EnumDepositTypeFieldUpdateOperationsInput | $Enums.DepositType
    depositAmountPence?: NullableIntFieldUpdateOperationsInput | number | null
    depositPercentBps?: NullableIntFieldUpdateOperationsInput | number | null
    paymentScheduleJson?: NullableJsonNullValueInput | InputJsonValue
    showQtyToClient?: BoolFieldUpdateOperationsInput | boolean
    showUnitRatesToClient?: BoolFieldUpdateOperationsInput | boolean
    scopeOverviewJson?: NullableJsonNullValueInput | InputJsonValue
    termsJson?: NullableJsonNullValueInput | InputJsonValue
    estimatedStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedDurationWeeks?: NullableIntFieldUpdateOperationsInput | number | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: QuoteItemUncheckedUpdateManyWithoutQuoteNestedInput
    publicLinks?: QuotePublicLinkUncheckedUpdateManyWithoutQuoteNestedInput
    acceptance?: QuoteAcceptanceUncheckedUpdateOneWithoutQuoteNestedInput
    variations?: VariationUncheckedUpdateManyWithoutQuoteNestedInput
    versions?: QuoteVersionUncheckedUpdateManyWithoutQuoteNestedInput
  }

  export type QuoteCreateWithoutAcceptanceInput = {
    id?: string
    title: string
    referenceNo?: string | null
    projectAddress?: string | null
    status?: $Enums.QuoteStatus
    currentVersion?: number
    sentAt?: Date | string | null
    acceptedAt?: Date | string | null
    vatMode?: $Enums.VatMode
    vatRateBps?: number
    depositType?: $Enums.DepositType
    depositAmountPence?: number | null
    depositPercentBps?: number | null
    paymentScheduleJson?: NullableJsonNullValueInput | InputJsonValue
    showQtyToClient?: boolean
    showUnitRatesToClient?: boolean
    scopeOverviewJson?: NullableJsonNullValueInput | InputJsonValue
    termsJson?: NullableJsonNullValueInput | InputJsonValue
    estimatedStartDate?: Date | string | null
    estimatedDurationWeeks?: number | null
    createdByUserId?: string | null
    updatedByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client?: ClientCreateNestedOneWithoutQuotesInput
    items?: QuoteItemCreateNestedManyWithoutQuoteInput
    publicLinks?: QuotePublicLinkCreateNestedManyWithoutQuoteInput
    pdfs?: QuotePdfCreateNestedManyWithoutQuoteInput
    variations?: VariationCreateNestedManyWithoutQuoteInput
    versions?: QuoteVersionCreateNestedManyWithoutQuoteInput
  }

  export type QuoteUncheckedCreateWithoutAcceptanceInput = {
    id?: string
    orgId: string
    clientId?: string | null
    title: string
    referenceNo?: string | null
    projectAddress?: string | null
    status?: $Enums.QuoteStatus
    currentVersion?: number
    sentAt?: Date | string | null
    acceptedAt?: Date | string | null
    vatMode?: $Enums.VatMode
    vatRateBps?: number
    depositType?: $Enums.DepositType
    depositAmountPence?: number | null
    depositPercentBps?: number | null
    paymentScheduleJson?: NullableJsonNullValueInput | InputJsonValue
    showQtyToClient?: boolean
    showUnitRatesToClient?: boolean
    scopeOverviewJson?: NullableJsonNullValueInput | InputJsonValue
    termsJson?: NullableJsonNullValueInput | InputJsonValue
    estimatedStartDate?: Date | string | null
    estimatedDurationWeeks?: number | null
    createdByUserId?: string | null
    updatedByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: QuoteItemUncheckedCreateNestedManyWithoutQuoteInput
    publicLinks?: QuotePublicLinkUncheckedCreateNestedManyWithoutQuoteInput
    pdfs?: QuotePdfUncheckedCreateNestedManyWithoutQuoteInput
    variations?: VariationUncheckedCreateNestedManyWithoutQuoteInput
    versions?: QuoteVersionUncheckedCreateNestedManyWithoutQuoteInput
  }

  export type QuoteCreateOrConnectWithoutAcceptanceInput = {
    where: QuoteWhereUniqueInput
    create: XOR<QuoteCreateWithoutAcceptanceInput, QuoteUncheckedCreateWithoutAcceptanceInput>
  }

  export type QuoteUpsertWithoutAcceptanceInput = {
    update: XOR<QuoteUpdateWithoutAcceptanceInput, QuoteUncheckedUpdateWithoutAcceptanceInput>
    create: XOR<QuoteCreateWithoutAcceptanceInput, QuoteUncheckedCreateWithoutAcceptanceInput>
    where?: QuoteWhereInput
  }

  export type QuoteUpdateToOneWithWhereWithoutAcceptanceInput = {
    where?: QuoteWhereInput
    data: XOR<QuoteUpdateWithoutAcceptanceInput, QuoteUncheckedUpdateWithoutAcceptanceInput>
  }

  export type QuoteUpdateWithoutAcceptanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    referenceNo?: NullableStringFieldUpdateOperationsInput | string | null
    projectAddress?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQuoteStatusFieldUpdateOperationsInput | $Enums.QuoteStatus
    currentVersion?: IntFieldUpdateOperationsInput | number
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatMode?: EnumVatModeFieldUpdateOperationsInput | $Enums.VatMode
    vatRateBps?: IntFieldUpdateOperationsInput | number
    depositType?: EnumDepositTypeFieldUpdateOperationsInput | $Enums.DepositType
    depositAmountPence?: NullableIntFieldUpdateOperationsInput | number | null
    depositPercentBps?: NullableIntFieldUpdateOperationsInput | number | null
    paymentScheduleJson?: NullableJsonNullValueInput | InputJsonValue
    showQtyToClient?: BoolFieldUpdateOperationsInput | boolean
    showUnitRatesToClient?: BoolFieldUpdateOperationsInput | boolean
    scopeOverviewJson?: NullableJsonNullValueInput | InputJsonValue
    termsJson?: NullableJsonNullValueInput | InputJsonValue
    estimatedStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedDurationWeeks?: NullableIntFieldUpdateOperationsInput | number | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneWithoutQuotesNestedInput
    items?: QuoteItemUpdateManyWithoutQuoteNestedInput
    publicLinks?: QuotePublicLinkUpdateManyWithoutQuoteNestedInput
    pdfs?: QuotePdfUpdateManyWithoutQuoteNestedInput
    variations?: VariationUpdateManyWithoutQuoteNestedInput
    versions?: QuoteVersionUpdateManyWithoutQuoteNestedInput
  }

  export type QuoteUncheckedUpdateWithoutAcceptanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    referenceNo?: NullableStringFieldUpdateOperationsInput | string | null
    projectAddress?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQuoteStatusFieldUpdateOperationsInput | $Enums.QuoteStatus
    currentVersion?: IntFieldUpdateOperationsInput | number
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatMode?: EnumVatModeFieldUpdateOperationsInput | $Enums.VatMode
    vatRateBps?: IntFieldUpdateOperationsInput | number
    depositType?: EnumDepositTypeFieldUpdateOperationsInput | $Enums.DepositType
    depositAmountPence?: NullableIntFieldUpdateOperationsInput | number | null
    depositPercentBps?: NullableIntFieldUpdateOperationsInput | number | null
    paymentScheduleJson?: NullableJsonNullValueInput | InputJsonValue
    showQtyToClient?: BoolFieldUpdateOperationsInput | boolean
    showUnitRatesToClient?: BoolFieldUpdateOperationsInput | boolean
    scopeOverviewJson?: NullableJsonNullValueInput | InputJsonValue
    termsJson?: NullableJsonNullValueInput | InputJsonValue
    estimatedStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedDurationWeeks?: NullableIntFieldUpdateOperationsInput | number | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: QuoteItemUncheckedUpdateManyWithoutQuoteNestedInput
    publicLinks?: QuotePublicLinkUncheckedUpdateManyWithoutQuoteNestedInput
    pdfs?: QuotePdfUncheckedUpdateManyWithoutQuoteNestedInput
    variations?: VariationUncheckedUpdateManyWithoutQuoteNestedInput
    versions?: QuoteVersionUncheckedUpdateManyWithoutQuoteNestedInput
  }

  export type TemplateSectionItemCreateWithoutTemplateSectionInput = {
    id?: string
    title: string
    description?: string | null
    sortOrder?: number
    calcType?: $Enums.CalcType
    qty?: Decimal | DecimalJsLike | number | string | null
    unit?: string | null
    unitPricePence?: number | null
    hours?: Decimal | DecimalJsLike | number | string | null
    hourlyRatePence?: number | null
    sellPricePence?: number | null
    isAllowance?: boolean
    roomTag?: string | null
    tradeTag?: string | null
    phaseTag?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TemplateSectionItemUncheckedCreateWithoutTemplateSectionInput = {
    id?: string
    title: string
    description?: string | null
    sortOrder?: number
    calcType?: $Enums.CalcType
    qty?: Decimal | DecimalJsLike | number | string | null
    unit?: string | null
    unitPricePence?: number | null
    hours?: Decimal | DecimalJsLike | number | string | null
    hourlyRatePence?: number | null
    sellPricePence?: number | null
    isAllowance?: boolean
    roomTag?: string | null
    tradeTag?: string | null
    phaseTag?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TemplateSectionItemCreateOrConnectWithoutTemplateSectionInput = {
    where: TemplateSectionItemWhereUniqueInput
    create: XOR<TemplateSectionItemCreateWithoutTemplateSectionInput, TemplateSectionItemUncheckedCreateWithoutTemplateSectionInput>
  }

  export type TemplateSectionItemCreateManyTemplateSectionInputEnvelope = {
    data: TemplateSectionItemCreateManyTemplateSectionInput | TemplateSectionItemCreateManyTemplateSectionInput[]
    skipDuplicates?: boolean
  }

  export type TemplateSectionItemUpsertWithWhereUniqueWithoutTemplateSectionInput = {
    where: TemplateSectionItemWhereUniqueInput
    update: XOR<TemplateSectionItemUpdateWithoutTemplateSectionInput, TemplateSectionItemUncheckedUpdateWithoutTemplateSectionInput>
    create: XOR<TemplateSectionItemCreateWithoutTemplateSectionInput, TemplateSectionItemUncheckedCreateWithoutTemplateSectionInput>
  }

  export type TemplateSectionItemUpdateWithWhereUniqueWithoutTemplateSectionInput = {
    where: TemplateSectionItemWhereUniqueInput
    data: XOR<TemplateSectionItemUpdateWithoutTemplateSectionInput, TemplateSectionItemUncheckedUpdateWithoutTemplateSectionInput>
  }

  export type TemplateSectionItemUpdateManyWithWhereWithoutTemplateSectionInput = {
    where: TemplateSectionItemScalarWhereInput
    data: XOR<TemplateSectionItemUpdateManyMutationInput, TemplateSectionItemUncheckedUpdateManyWithoutTemplateSectionInput>
  }

  export type TemplateSectionItemScalarWhereInput = {
    AND?: TemplateSectionItemScalarWhereInput | TemplateSectionItemScalarWhereInput[]
    OR?: TemplateSectionItemScalarWhereInput[]
    NOT?: TemplateSectionItemScalarWhereInput | TemplateSectionItemScalarWhereInput[]
    id?: StringFilter<"TemplateSectionItem"> | string
    orgId?: StringFilter<"TemplateSectionItem"> | string
    templateSectionId?: StringFilter<"TemplateSectionItem"> | string
    title?: StringFilter<"TemplateSectionItem"> | string
    description?: StringNullableFilter<"TemplateSectionItem"> | string | null
    sortOrder?: IntFilter<"TemplateSectionItem"> | number
    calcType?: EnumCalcTypeFilter<"TemplateSectionItem"> | $Enums.CalcType
    qty?: DecimalNullableFilter<"TemplateSectionItem"> | Decimal | DecimalJsLike | number | string | null
    unit?: StringNullableFilter<"TemplateSectionItem"> | string | null
    unitPricePence?: IntNullableFilter<"TemplateSectionItem"> | number | null
    hours?: DecimalNullableFilter<"TemplateSectionItem"> | Decimal | DecimalJsLike | number | string | null
    hourlyRatePence?: IntNullableFilter<"TemplateSectionItem"> | number | null
    sellPricePence?: IntNullableFilter<"TemplateSectionItem"> | number | null
    isAllowance?: BoolFilter<"TemplateSectionItem"> | boolean
    roomTag?: StringNullableFilter<"TemplateSectionItem"> | string | null
    tradeTag?: StringNullableFilter<"TemplateSectionItem"> | string | null
    phaseTag?: StringNullableFilter<"TemplateSectionItem"> | string | null
    createdAt?: DateTimeFilter<"TemplateSectionItem"> | Date | string
    updatedAt?: DateTimeFilter<"TemplateSectionItem"> | Date | string
  }

  export type TemplateSectionCreateWithoutItemsInput = {
    id?: string
    orgId: string
    name: string
    description?: string | null
    createdByUserId?: string | null
    updatedByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TemplateSectionUncheckedCreateWithoutItemsInput = {
    id?: string
    orgId: string
    name: string
    description?: string | null
    createdByUserId?: string | null
    updatedByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TemplateSectionCreateOrConnectWithoutItemsInput = {
    where: TemplateSectionWhereUniqueInput
    create: XOR<TemplateSectionCreateWithoutItemsInput, TemplateSectionUncheckedCreateWithoutItemsInput>
  }

  export type TemplateSectionUpsertWithoutItemsInput = {
    update: XOR<TemplateSectionUpdateWithoutItemsInput, TemplateSectionUncheckedUpdateWithoutItemsInput>
    create: XOR<TemplateSectionCreateWithoutItemsInput, TemplateSectionUncheckedCreateWithoutItemsInput>
    where?: TemplateSectionWhereInput
  }

  export type TemplateSectionUpdateToOneWithWhereWithoutItemsInput = {
    where?: TemplateSectionWhereInput
    data: XOR<TemplateSectionUpdateWithoutItemsInput, TemplateSectionUncheckedUpdateWithoutItemsInput>
  }

  export type TemplateSectionUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TemplateSectionUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuoteCreateWithoutVariationsInput = {
    id?: string
    title: string
    referenceNo?: string | null
    projectAddress?: string | null
    status?: $Enums.QuoteStatus
    currentVersion?: number
    sentAt?: Date | string | null
    acceptedAt?: Date | string | null
    vatMode?: $Enums.VatMode
    vatRateBps?: number
    depositType?: $Enums.DepositType
    depositAmountPence?: number | null
    depositPercentBps?: number | null
    paymentScheduleJson?: NullableJsonNullValueInput | InputJsonValue
    showQtyToClient?: boolean
    showUnitRatesToClient?: boolean
    scopeOverviewJson?: NullableJsonNullValueInput | InputJsonValue
    termsJson?: NullableJsonNullValueInput | InputJsonValue
    estimatedStartDate?: Date | string | null
    estimatedDurationWeeks?: number | null
    createdByUserId?: string | null
    updatedByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client?: ClientCreateNestedOneWithoutQuotesInput
    items?: QuoteItemCreateNestedManyWithoutQuoteInput
    publicLinks?: QuotePublicLinkCreateNestedManyWithoutQuoteInput
    pdfs?: QuotePdfCreateNestedManyWithoutQuoteInput
    acceptance?: QuoteAcceptanceCreateNestedOneWithoutQuoteInput
    versions?: QuoteVersionCreateNestedManyWithoutQuoteInput
  }

  export type QuoteUncheckedCreateWithoutVariationsInput = {
    id?: string
    orgId: string
    clientId?: string | null
    title: string
    referenceNo?: string | null
    projectAddress?: string | null
    status?: $Enums.QuoteStatus
    currentVersion?: number
    sentAt?: Date | string | null
    acceptedAt?: Date | string | null
    vatMode?: $Enums.VatMode
    vatRateBps?: number
    depositType?: $Enums.DepositType
    depositAmountPence?: number | null
    depositPercentBps?: number | null
    paymentScheduleJson?: NullableJsonNullValueInput | InputJsonValue
    showQtyToClient?: boolean
    showUnitRatesToClient?: boolean
    scopeOverviewJson?: NullableJsonNullValueInput | InputJsonValue
    termsJson?: NullableJsonNullValueInput | InputJsonValue
    estimatedStartDate?: Date | string | null
    estimatedDurationWeeks?: number | null
    createdByUserId?: string | null
    updatedByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: QuoteItemUncheckedCreateNestedManyWithoutQuoteInput
    publicLinks?: QuotePublicLinkUncheckedCreateNestedManyWithoutQuoteInput
    pdfs?: QuotePdfUncheckedCreateNestedManyWithoutQuoteInput
    acceptance?: QuoteAcceptanceUncheckedCreateNestedOneWithoutQuoteInput
    versions?: QuoteVersionUncheckedCreateNestedManyWithoutQuoteInput
  }

  export type QuoteCreateOrConnectWithoutVariationsInput = {
    where: QuoteWhereUniqueInput
    create: XOR<QuoteCreateWithoutVariationsInput, QuoteUncheckedCreateWithoutVariationsInput>
  }

  export type VariationPublicLinkCreateWithoutVariationInput = {
    id?: string
    tokenHash: string
    tokenPrefix?: string | null
    isActive?: boolean
    expiresAt?: Date | string | null
    revokedAt?: Date | string | null
    firstViewedAt?: Date | string | null
    lastViewedAt?: Date | string | null
    viewCount?: number
    createdByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VariationPublicLinkUncheckedCreateWithoutVariationInput = {
    id?: string
    tokenHash: string
    tokenPrefix?: string | null
    isActive?: boolean
    expiresAt?: Date | string | null
    revokedAt?: Date | string | null
    firstViewedAt?: Date | string | null
    lastViewedAt?: Date | string | null
    viewCount?: number
    createdByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VariationPublicLinkCreateOrConnectWithoutVariationInput = {
    where: VariationPublicLinkWhereUniqueInput
    create: XOR<VariationPublicLinkCreateWithoutVariationInput, VariationPublicLinkUncheckedCreateWithoutVariationInput>
  }

  export type VariationPublicLinkCreateManyVariationInputEnvelope = {
    data: VariationPublicLinkCreateManyVariationInput | VariationPublicLinkCreateManyVariationInput[]
    skipDuplicates?: boolean
  }

  export type VariationItemCreateWithoutVariationInput = {
    id?: string
    rowType?: $Enums.ItemRowType
    title: string
    description?: string | null
    sortOrder?: number
    calcType?: $Enums.CalcType
    qty?: Decimal | DecimalJsLike | number | string | null
    unit?: string | null
    unitPricePence?: number | null
    hours?: Decimal | DecimalJsLike | number | string | null
    hourlyRatePence?: number | null
    sellPricePence?: number | null
    isAllowance?: boolean
    roomTag?: string | null
    tradeTag?: string | null
    phaseTag?: string | null
    costPence?: number | null
    markupPercentBps?: number | null
    createdByUserId?: string | null
    updatedByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: VariationItemCreateNestedOneWithoutChildrenInput
    children?: VariationItemCreateNestedManyWithoutParentInput
  }

  export type VariationItemUncheckedCreateWithoutVariationInput = {
    id?: string
    parentId?: string | null
    rowType?: $Enums.ItemRowType
    title: string
    description?: string | null
    sortOrder?: number
    calcType?: $Enums.CalcType
    qty?: Decimal | DecimalJsLike | number | string | null
    unit?: string | null
    unitPricePence?: number | null
    hours?: Decimal | DecimalJsLike | number | string | null
    hourlyRatePence?: number | null
    sellPricePence?: number | null
    isAllowance?: boolean
    roomTag?: string | null
    tradeTag?: string | null
    phaseTag?: string | null
    costPence?: number | null
    markupPercentBps?: number | null
    createdByUserId?: string | null
    updatedByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: VariationItemUncheckedCreateNestedManyWithoutParentInput
  }

  export type VariationItemCreateOrConnectWithoutVariationInput = {
    where: VariationItemWhereUniqueInput
    create: XOR<VariationItemCreateWithoutVariationInput, VariationItemUncheckedCreateWithoutVariationInput>
  }

  export type VariationItemCreateManyVariationInputEnvelope = {
    data: VariationItemCreateManyVariationInput | VariationItemCreateManyVariationInput[]
    skipDuplicates?: boolean
  }

  export type VariationApprovalCreateWithoutVariationInput = {
    id?: string
    approvedName: string
    approvedEmail?: string | null
    approvedAt?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type VariationApprovalUncheckedCreateWithoutVariationInput = {
    id?: string
    approvedName: string
    approvedEmail?: string | null
    approvedAt?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type VariationApprovalCreateOrConnectWithoutVariationInput = {
    where: VariationApprovalWhereUniqueInput
    create: XOR<VariationApprovalCreateWithoutVariationInput, VariationApprovalUncheckedCreateWithoutVariationInput>
  }

  export type VariationPdfCreateWithoutVariationInput = {
    id?: string
    stage: $Enums.VariationPdfStage
    fileUrl: string
    createdAt?: Date | string
  }

  export type VariationPdfUncheckedCreateWithoutVariationInput = {
    id?: string
    stage: $Enums.VariationPdfStage
    fileUrl: string
    createdAt?: Date | string
  }

  export type VariationPdfCreateOrConnectWithoutVariationInput = {
    where: VariationPdfWhereUniqueInput
    create: XOR<VariationPdfCreateWithoutVariationInput, VariationPdfUncheckedCreateWithoutVariationInput>
  }

  export type VariationPdfCreateManyVariationInputEnvelope = {
    data: VariationPdfCreateManyVariationInput | VariationPdfCreateManyVariationInput[]
    skipDuplicates?: boolean
  }

  export type QuoteUpsertWithoutVariationsInput = {
    update: XOR<QuoteUpdateWithoutVariationsInput, QuoteUncheckedUpdateWithoutVariationsInput>
    create: XOR<QuoteCreateWithoutVariationsInput, QuoteUncheckedCreateWithoutVariationsInput>
    where?: QuoteWhereInput
  }

  export type QuoteUpdateToOneWithWhereWithoutVariationsInput = {
    where?: QuoteWhereInput
    data: XOR<QuoteUpdateWithoutVariationsInput, QuoteUncheckedUpdateWithoutVariationsInput>
  }

  export type QuoteUpdateWithoutVariationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    referenceNo?: NullableStringFieldUpdateOperationsInput | string | null
    projectAddress?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQuoteStatusFieldUpdateOperationsInput | $Enums.QuoteStatus
    currentVersion?: IntFieldUpdateOperationsInput | number
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatMode?: EnumVatModeFieldUpdateOperationsInput | $Enums.VatMode
    vatRateBps?: IntFieldUpdateOperationsInput | number
    depositType?: EnumDepositTypeFieldUpdateOperationsInput | $Enums.DepositType
    depositAmountPence?: NullableIntFieldUpdateOperationsInput | number | null
    depositPercentBps?: NullableIntFieldUpdateOperationsInput | number | null
    paymentScheduleJson?: NullableJsonNullValueInput | InputJsonValue
    showQtyToClient?: BoolFieldUpdateOperationsInput | boolean
    showUnitRatesToClient?: BoolFieldUpdateOperationsInput | boolean
    scopeOverviewJson?: NullableJsonNullValueInput | InputJsonValue
    termsJson?: NullableJsonNullValueInput | InputJsonValue
    estimatedStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedDurationWeeks?: NullableIntFieldUpdateOperationsInput | number | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneWithoutQuotesNestedInput
    items?: QuoteItemUpdateManyWithoutQuoteNestedInput
    publicLinks?: QuotePublicLinkUpdateManyWithoutQuoteNestedInput
    pdfs?: QuotePdfUpdateManyWithoutQuoteNestedInput
    acceptance?: QuoteAcceptanceUpdateOneWithoutQuoteNestedInput
    versions?: QuoteVersionUpdateManyWithoutQuoteNestedInput
  }

  export type QuoteUncheckedUpdateWithoutVariationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    referenceNo?: NullableStringFieldUpdateOperationsInput | string | null
    projectAddress?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQuoteStatusFieldUpdateOperationsInput | $Enums.QuoteStatus
    currentVersion?: IntFieldUpdateOperationsInput | number
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatMode?: EnumVatModeFieldUpdateOperationsInput | $Enums.VatMode
    vatRateBps?: IntFieldUpdateOperationsInput | number
    depositType?: EnumDepositTypeFieldUpdateOperationsInput | $Enums.DepositType
    depositAmountPence?: NullableIntFieldUpdateOperationsInput | number | null
    depositPercentBps?: NullableIntFieldUpdateOperationsInput | number | null
    paymentScheduleJson?: NullableJsonNullValueInput | InputJsonValue
    showQtyToClient?: BoolFieldUpdateOperationsInput | boolean
    showUnitRatesToClient?: BoolFieldUpdateOperationsInput | boolean
    scopeOverviewJson?: NullableJsonNullValueInput | InputJsonValue
    termsJson?: NullableJsonNullValueInput | InputJsonValue
    estimatedStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedDurationWeeks?: NullableIntFieldUpdateOperationsInput | number | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: QuoteItemUncheckedUpdateManyWithoutQuoteNestedInput
    publicLinks?: QuotePublicLinkUncheckedUpdateManyWithoutQuoteNestedInput
    pdfs?: QuotePdfUncheckedUpdateManyWithoutQuoteNestedInput
    acceptance?: QuoteAcceptanceUncheckedUpdateOneWithoutQuoteNestedInput
    versions?: QuoteVersionUncheckedUpdateManyWithoutQuoteNestedInput
  }

  export type VariationPublicLinkUpsertWithWhereUniqueWithoutVariationInput = {
    where: VariationPublicLinkWhereUniqueInput
    update: XOR<VariationPublicLinkUpdateWithoutVariationInput, VariationPublicLinkUncheckedUpdateWithoutVariationInput>
    create: XOR<VariationPublicLinkCreateWithoutVariationInput, VariationPublicLinkUncheckedCreateWithoutVariationInput>
  }

  export type VariationPublicLinkUpdateWithWhereUniqueWithoutVariationInput = {
    where: VariationPublicLinkWhereUniqueInput
    data: XOR<VariationPublicLinkUpdateWithoutVariationInput, VariationPublicLinkUncheckedUpdateWithoutVariationInput>
  }

  export type VariationPublicLinkUpdateManyWithWhereWithoutVariationInput = {
    where: VariationPublicLinkScalarWhereInput
    data: XOR<VariationPublicLinkUpdateManyMutationInput, VariationPublicLinkUncheckedUpdateManyWithoutVariationInput>
  }

  export type VariationPublicLinkScalarWhereInput = {
    AND?: VariationPublicLinkScalarWhereInput | VariationPublicLinkScalarWhereInput[]
    OR?: VariationPublicLinkScalarWhereInput[]
    NOT?: VariationPublicLinkScalarWhereInput | VariationPublicLinkScalarWhereInput[]
    id?: StringFilter<"VariationPublicLink"> | string
    orgId?: StringFilter<"VariationPublicLink"> | string
    variationId?: StringFilter<"VariationPublicLink"> | string
    tokenHash?: StringFilter<"VariationPublicLink"> | string
    tokenPrefix?: StringNullableFilter<"VariationPublicLink"> | string | null
    isActive?: BoolFilter<"VariationPublicLink"> | boolean
    expiresAt?: DateTimeNullableFilter<"VariationPublicLink"> | Date | string | null
    revokedAt?: DateTimeNullableFilter<"VariationPublicLink"> | Date | string | null
    firstViewedAt?: DateTimeNullableFilter<"VariationPublicLink"> | Date | string | null
    lastViewedAt?: DateTimeNullableFilter<"VariationPublicLink"> | Date | string | null
    viewCount?: IntFilter<"VariationPublicLink"> | number
    createdByUserId?: StringNullableFilter<"VariationPublicLink"> | string | null
    createdAt?: DateTimeFilter<"VariationPublicLink"> | Date | string
    updatedAt?: DateTimeFilter<"VariationPublicLink"> | Date | string
  }

  export type VariationItemUpsertWithWhereUniqueWithoutVariationInput = {
    where: VariationItemWhereUniqueInput
    update: XOR<VariationItemUpdateWithoutVariationInput, VariationItemUncheckedUpdateWithoutVariationInput>
    create: XOR<VariationItemCreateWithoutVariationInput, VariationItemUncheckedCreateWithoutVariationInput>
  }

  export type VariationItemUpdateWithWhereUniqueWithoutVariationInput = {
    where: VariationItemWhereUniqueInput
    data: XOR<VariationItemUpdateWithoutVariationInput, VariationItemUncheckedUpdateWithoutVariationInput>
  }

  export type VariationItemUpdateManyWithWhereWithoutVariationInput = {
    where: VariationItemScalarWhereInput
    data: XOR<VariationItemUpdateManyMutationInput, VariationItemUncheckedUpdateManyWithoutVariationInput>
  }

  export type VariationItemScalarWhereInput = {
    AND?: VariationItemScalarWhereInput | VariationItemScalarWhereInput[]
    OR?: VariationItemScalarWhereInput[]
    NOT?: VariationItemScalarWhereInput | VariationItemScalarWhereInput[]
    id?: StringFilter<"VariationItem"> | string
    orgId?: StringFilter<"VariationItem"> | string
    variationId?: StringFilter<"VariationItem"> | string
    parentId?: StringNullableFilter<"VariationItem"> | string | null
    rowType?: EnumItemRowTypeFilter<"VariationItem"> | $Enums.ItemRowType
    title?: StringFilter<"VariationItem"> | string
    description?: StringNullableFilter<"VariationItem"> | string | null
    sortOrder?: IntFilter<"VariationItem"> | number
    calcType?: EnumCalcTypeFilter<"VariationItem"> | $Enums.CalcType
    qty?: DecimalNullableFilter<"VariationItem"> | Decimal | DecimalJsLike | number | string | null
    unit?: StringNullableFilter<"VariationItem"> | string | null
    unitPricePence?: IntNullableFilter<"VariationItem"> | number | null
    hours?: DecimalNullableFilter<"VariationItem"> | Decimal | DecimalJsLike | number | string | null
    hourlyRatePence?: IntNullableFilter<"VariationItem"> | number | null
    sellPricePence?: IntNullableFilter<"VariationItem"> | number | null
    isAllowance?: BoolFilter<"VariationItem"> | boolean
    roomTag?: StringNullableFilter<"VariationItem"> | string | null
    tradeTag?: StringNullableFilter<"VariationItem"> | string | null
    phaseTag?: StringNullableFilter<"VariationItem"> | string | null
    costPence?: IntNullableFilter<"VariationItem"> | number | null
    markupPercentBps?: IntNullableFilter<"VariationItem"> | number | null
    createdByUserId?: StringNullableFilter<"VariationItem"> | string | null
    updatedByUserId?: StringNullableFilter<"VariationItem"> | string | null
    createdAt?: DateTimeFilter<"VariationItem"> | Date | string
    updatedAt?: DateTimeFilter<"VariationItem"> | Date | string
  }

  export type VariationApprovalUpsertWithoutVariationInput = {
    update: XOR<VariationApprovalUpdateWithoutVariationInput, VariationApprovalUncheckedUpdateWithoutVariationInput>
    create: XOR<VariationApprovalCreateWithoutVariationInput, VariationApprovalUncheckedCreateWithoutVariationInput>
    where?: VariationApprovalWhereInput
  }

  export type VariationApprovalUpdateToOneWithWhereWithoutVariationInput = {
    where?: VariationApprovalWhereInput
    data: XOR<VariationApprovalUpdateWithoutVariationInput, VariationApprovalUncheckedUpdateWithoutVariationInput>
  }

  export type VariationApprovalUpdateWithoutVariationInput = {
    id?: StringFieldUpdateOperationsInput | string
    approvedName?: StringFieldUpdateOperationsInput | string
    approvedEmail?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VariationApprovalUncheckedUpdateWithoutVariationInput = {
    id?: StringFieldUpdateOperationsInput | string
    approvedName?: StringFieldUpdateOperationsInput | string
    approvedEmail?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VariationPdfUpsertWithWhereUniqueWithoutVariationInput = {
    where: VariationPdfWhereUniqueInput
    update: XOR<VariationPdfUpdateWithoutVariationInput, VariationPdfUncheckedUpdateWithoutVariationInput>
    create: XOR<VariationPdfCreateWithoutVariationInput, VariationPdfUncheckedCreateWithoutVariationInput>
  }

  export type VariationPdfUpdateWithWhereUniqueWithoutVariationInput = {
    where: VariationPdfWhereUniqueInput
    data: XOR<VariationPdfUpdateWithoutVariationInput, VariationPdfUncheckedUpdateWithoutVariationInput>
  }

  export type VariationPdfUpdateManyWithWhereWithoutVariationInput = {
    where: VariationPdfScalarWhereInput
    data: XOR<VariationPdfUpdateManyMutationInput, VariationPdfUncheckedUpdateManyWithoutVariationInput>
  }

  export type VariationPdfScalarWhereInput = {
    AND?: VariationPdfScalarWhereInput | VariationPdfScalarWhereInput[]
    OR?: VariationPdfScalarWhereInput[]
    NOT?: VariationPdfScalarWhereInput | VariationPdfScalarWhereInput[]
    id?: StringFilter<"VariationPdf"> | string
    orgId?: StringFilter<"VariationPdf"> | string
    variationId?: StringFilter<"VariationPdf"> | string
    stage?: EnumVariationPdfStageFilter<"VariationPdf"> | $Enums.VariationPdfStage
    fileUrl?: StringFilter<"VariationPdf"> | string
    createdAt?: DateTimeFilter<"VariationPdf"> | Date | string
  }

  export type VariationCreateWithoutItemsInput = {
    id?: string
    number: number
    title: string
    description?: string | null
    status?: $Enums.VariationStatus
    sentAt?: Date | string | null
    approvedAt?: Date | string | null
    vatMode?: $Enums.VatMode
    vatRateBps?: number
    createdByUserId?: string | null
    updatedByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    quote: QuoteCreateNestedOneWithoutVariationsInput
    publicLinks?: VariationPublicLinkCreateNestedManyWithoutVariationInput
    approval?: VariationApprovalCreateNestedOneWithoutVariationInput
    pdfs?: VariationPdfCreateNestedManyWithoutVariationInput
  }

  export type VariationUncheckedCreateWithoutItemsInput = {
    id?: string
    orgId: string
    quoteId: string
    number: number
    title: string
    description?: string | null
    status?: $Enums.VariationStatus
    sentAt?: Date | string | null
    approvedAt?: Date | string | null
    vatMode?: $Enums.VatMode
    vatRateBps?: number
    createdByUserId?: string | null
    updatedByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    publicLinks?: VariationPublicLinkUncheckedCreateNestedManyWithoutVariationInput
    approval?: VariationApprovalUncheckedCreateNestedOneWithoutVariationInput
    pdfs?: VariationPdfUncheckedCreateNestedManyWithoutVariationInput
  }

  export type VariationCreateOrConnectWithoutItemsInput = {
    where: VariationWhereUniqueInput
    create: XOR<VariationCreateWithoutItemsInput, VariationUncheckedCreateWithoutItemsInput>
  }

  export type VariationItemCreateWithoutChildrenInput = {
    id?: string
    rowType?: $Enums.ItemRowType
    title: string
    description?: string | null
    sortOrder?: number
    calcType?: $Enums.CalcType
    qty?: Decimal | DecimalJsLike | number | string | null
    unit?: string | null
    unitPricePence?: number | null
    hours?: Decimal | DecimalJsLike | number | string | null
    hourlyRatePence?: number | null
    sellPricePence?: number | null
    isAllowance?: boolean
    roomTag?: string | null
    tradeTag?: string | null
    phaseTag?: string | null
    costPence?: number | null
    markupPercentBps?: number | null
    createdByUserId?: string | null
    updatedByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    variation: VariationCreateNestedOneWithoutItemsInput
    parent?: VariationItemCreateNestedOneWithoutChildrenInput
  }

  export type VariationItemUncheckedCreateWithoutChildrenInput = {
    id?: string
    orgId: string
    variationId: string
    parentId?: string | null
    rowType?: $Enums.ItemRowType
    title: string
    description?: string | null
    sortOrder?: number
    calcType?: $Enums.CalcType
    qty?: Decimal | DecimalJsLike | number | string | null
    unit?: string | null
    unitPricePence?: number | null
    hours?: Decimal | DecimalJsLike | number | string | null
    hourlyRatePence?: number | null
    sellPricePence?: number | null
    isAllowance?: boolean
    roomTag?: string | null
    tradeTag?: string | null
    phaseTag?: string | null
    costPence?: number | null
    markupPercentBps?: number | null
    createdByUserId?: string | null
    updatedByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VariationItemCreateOrConnectWithoutChildrenInput = {
    where: VariationItemWhereUniqueInput
    create: XOR<VariationItemCreateWithoutChildrenInput, VariationItemUncheckedCreateWithoutChildrenInput>
  }

  export type VariationItemCreateWithoutParentInput = {
    id?: string
    rowType?: $Enums.ItemRowType
    title: string
    description?: string | null
    sortOrder?: number
    calcType?: $Enums.CalcType
    qty?: Decimal | DecimalJsLike | number | string | null
    unit?: string | null
    unitPricePence?: number | null
    hours?: Decimal | DecimalJsLike | number | string | null
    hourlyRatePence?: number | null
    sellPricePence?: number | null
    isAllowance?: boolean
    roomTag?: string | null
    tradeTag?: string | null
    phaseTag?: string | null
    costPence?: number | null
    markupPercentBps?: number | null
    createdByUserId?: string | null
    updatedByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    variation: VariationCreateNestedOneWithoutItemsInput
    children?: VariationItemCreateNestedManyWithoutParentInput
  }

  export type VariationItemUncheckedCreateWithoutParentInput = {
    id?: string
    variationId: string
    rowType?: $Enums.ItemRowType
    title: string
    description?: string | null
    sortOrder?: number
    calcType?: $Enums.CalcType
    qty?: Decimal | DecimalJsLike | number | string | null
    unit?: string | null
    unitPricePence?: number | null
    hours?: Decimal | DecimalJsLike | number | string | null
    hourlyRatePence?: number | null
    sellPricePence?: number | null
    isAllowance?: boolean
    roomTag?: string | null
    tradeTag?: string | null
    phaseTag?: string | null
    costPence?: number | null
    markupPercentBps?: number | null
    createdByUserId?: string | null
    updatedByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: VariationItemUncheckedCreateNestedManyWithoutParentInput
  }

  export type VariationItemCreateOrConnectWithoutParentInput = {
    where: VariationItemWhereUniqueInput
    create: XOR<VariationItemCreateWithoutParentInput, VariationItemUncheckedCreateWithoutParentInput>
  }

  export type VariationItemCreateManyParentInputEnvelope = {
    data: VariationItemCreateManyParentInput | VariationItemCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type VariationUpsertWithoutItemsInput = {
    update: XOR<VariationUpdateWithoutItemsInput, VariationUncheckedUpdateWithoutItemsInput>
    create: XOR<VariationCreateWithoutItemsInput, VariationUncheckedCreateWithoutItemsInput>
    where?: VariationWhereInput
  }

  export type VariationUpdateToOneWithWhereWithoutItemsInput = {
    where?: VariationWhereInput
    data: XOR<VariationUpdateWithoutItemsInput, VariationUncheckedUpdateWithoutItemsInput>
  }

  export type VariationUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVariationStatusFieldUpdateOperationsInput | $Enums.VariationStatus
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatMode?: EnumVatModeFieldUpdateOperationsInput | $Enums.VatMode
    vatRateBps?: IntFieldUpdateOperationsInput | number
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quote?: QuoteUpdateOneRequiredWithoutVariationsNestedInput
    publicLinks?: VariationPublicLinkUpdateManyWithoutVariationNestedInput
    approval?: VariationApprovalUpdateOneWithoutVariationNestedInput
    pdfs?: VariationPdfUpdateManyWithoutVariationNestedInput
  }

  export type VariationUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    quoteId?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVariationStatusFieldUpdateOperationsInput | $Enums.VariationStatus
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatMode?: EnumVatModeFieldUpdateOperationsInput | $Enums.VatMode
    vatRateBps?: IntFieldUpdateOperationsInput | number
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publicLinks?: VariationPublicLinkUncheckedUpdateManyWithoutVariationNestedInput
    approval?: VariationApprovalUncheckedUpdateOneWithoutVariationNestedInput
    pdfs?: VariationPdfUncheckedUpdateManyWithoutVariationNestedInput
  }

  export type VariationItemUpsertWithoutChildrenInput = {
    update: XOR<VariationItemUpdateWithoutChildrenInput, VariationItemUncheckedUpdateWithoutChildrenInput>
    create: XOR<VariationItemCreateWithoutChildrenInput, VariationItemUncheckedCreateWithoutChildrenInput>
    where?: VariationItemWhereInput
  }

  export type VariationItemUpdateToOneWithWhereWithoutChildrenInput = {
    where?: VariationItemWhereInput
    data: XOR<VariationItemUpdateWithoutChildrenInput, VariationItemUncheckedUpdateWithoutChildrenInput>
  }

  export type VariationItemUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    rowType?: EnumItemRowTypeFieldUpdateOperationsInput | $Enums.ItemRowType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    calcType?: EnumCalcTypeFieldUpdateOperationsInput | $Enums.CalcType
    qty?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    unitPricePence?: NullableIntFieldUpdateOperationsInput | number | null
    hours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    hourlyRatePence?: NullableIntFieldUpdateOperationsInput | number | null
    sellPricePence?: NullableIntFieldUpdateOperationsInput | number | null
    isAllowance?: BoolFieldUpdateOperationsInput | boolean
    roomTag?: NullableStringFieldUpdateOperationsInput | string | null
    tradeTag?: NullableStringFieldUpdateOperationsInput | string | null
    phaseTag?: NullableStringFieldUpdateOperationsInput | string | null
    costPence?: NullableIntFieldUpdateOperationsInput | number | null
    markupPercentBps?: NullableIntFieldUpdateOperationsInput | number | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    variation?: VariationUpdateOneRequiredWithoutItemsNestedInput
    parent?: VariationItemUpdateOneWithoutChildrenNestedInput
  }

  export type VariationItemUncheckedUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    variationId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    rowType?: EnumItemRowTypeFieldUpdateOperationsInput | $Enums.ItemRowType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    calcType?: EnumCalcTypeFieldUpdateOperationsInput | $Enums.CalcType
    qty?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    unitPricePence?: NullableIntFieldUpdateOperationsInput | number | null
    hours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    hourlyRatePence?: NullableIntFieldUpdateOperationsInput | number | null
    sellPricePence?: NullableIntFieldUpdateOperationsInput | number | null
    isAllowance?: BoolFieldUpdateOperationsInput | boolean
    roomTag?: NullableStringFieldUpdateOperationsInput | string | null
    tradeTag?: NullableStringFieldUpdateOperationsInput | string | null
    phaseTag?: NullableStringFieldUpdateOperationsInput | string | null
    costPence?: NullableIntFieldUpdateOperationsInput | number | null
    markupPercentBps?: NullableIntFieldUpdateOperationsInput | number | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VariationItemUpsertWithWhereUniqueWithoutParentInput = {
    where: VariationItemWhereUniqueInput
    update: XOR<VariationItemUpdateWithoutParentInput, VariationItemUncheckedUpdateWithoutParentInput>
    create: XOR<VariationItemCreateWithoutParentInput, VariationItemUncheckedCreateWithoutParentInput>
  }

  export type VariationItemUpdateWithWhereUniqueWithoutParentInput = {
    where: VariationItemWhereUniqueInput
    data: XOR<VariationItemUpdateWithoutParentInput, VariationItemUncheckedUpdateWithoutParentInput>
  }

  export type VariationItemUpdateManyWithWhereWithoutParentInput = {
    where: VariationItemScalarWhereInput
    data: XOR<VariationItemUpdateManyMutationInput, VariationItemUncheckedUpdateManyWithoutParentInput>
  }

  export type VariationCreateWithoutApprovalInput = {
    id?: string
    number: number
    title: string
    description?: string | null
    status?: $Enums.VariationStatus
    sentAt?: Date | string | null
    approvedAt?: Date | string | null
    vatMode?: $Enums.VatMode
    vatRateBps?: number
    createdByUserId?: string | null
    updatedByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    quote: QuoteCreateNestedOneWithoutVariationsInput
    publicLinks?: VariationPublicLinkCreateNestedManyWithoutVariationInput
    items?: VariationItemCreateNestedManyWithoutVariationInput
    pdfs?: VariationPdfCreateNestedManyWithoutVariationInput
  }

  export type VariationUncheckedCreateWithoutApprovalInput = {
    id?: string
    orgId: string
    quoteId: string
    number: number
    title: string
    description?: string | null
    status?: $Enums.VariationStatus
    sentAt?: Date | string | null
    approvedAt?: Date | string | null
    vatMode?: $Enums.VatMode
    vatRateBps?: number
    createdByUserId?: string | null
    updatedByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    publicLinks?: VariationPublicLinkUncheckedCreateNestedManyWithoutVariationInput
    items?: VariationItemUncheckedCreateNestedManyWithoutVariationInput
    pdfs?: VariationPdfUncheckedCreateNestedManyWithoutVariationInput
  }

  export type VariationCreateOrConnectWithoutApprovalInput = {
    where: VariationWhereUniqueInput
    create: XOR<VariationCreateWithoutApprovalInput, VariationUncheckedCreateWithoutApprovalInput>
  }

  export type VariationUpsertWithoutApprovalInput = {
    update: XOR<VariationUpdateWithoutApprovalInput, VariationUncheckedUpdateWithoutApprovalInput>
    create: XOR<VariationCreateWithoutApprovalInput, VariationUncheckedCreateWithoutApprovalInput>
    where?: VariationWhereInput
  }

  export type VariationUpdateToOneWithWhereWithoutApprovalInput = {
    where?: VariationWhereInput
    data: XOR<VariationUpdateWithoutApprovalInput, VariationUncheckedUpdateWithoutApprovalInput>
  }

  export type VariationUpdateWithoutApprovalInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVariationStatusFieldUpdateOperationsInput | $Enums.VariationStatus
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatMode?: EnumVatModeFieldUpdateOperationsInput | $Enums.VatMode
    vatRateBps?: IntFieldUpdateOperationsInput | number
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quote?: QuoteUpdateOneRequiredWithoutVariationsNestedInput
    publicLinks?: VariationPublicLinkUpdateManyWithoutVariationNestedInput
    items?: VariationItemUpdateManyWithoutVariationNestedInput
    pdfs?: VariationPdfUpdateManyWithoutVariationNestedInput
  }

  export type VariationUncheckedUpdateWithoutApprovalInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    quoteId?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVariationStatusFieldUpdateOperationsInput | $Enums.VariationStatus
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatMode?: EnumVatModeFieldUpdateOperationsInput | $Enums.VatMode
    vatRateBps?: IntFieldUpdateOperationsInput | number
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publicLinks?: VariationPublicLinkUncheckedUpdateManyWithoutVariationNestedInput
    items?: VariationItemUncheckedUpdateManyWithoutVariationNestedInput
    pdfs?: VariationPdfUncheckedUpdateManyWithoutVariationNestedInput
  }

  export type VariationCreateWithoutPublicLinksInput = {
    id?: string
    number: number
    title: string
    description?: string | null
    status?: $Enums.VariationStatus
    sentAt?: Date | string | null
    approvedAt?: Date | string | null
    vatMode?: $Enums.VatMode
    vatRateBps?: number
    createdByUserId?: string | null
    updatedByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    quote: QuoteCreateNestedOneWithoutVariationsInput
    items?: VariationItemCreateNestedManyWithoutVariationInput
    approval?: VariationApprovalCreateNestedOneWithoutVariationInput
    pdfs?: VariationPdfCreateNestedManyWithoutVariationInput
  }

  export type VariationUncheckedCreateWithoutPublicLinksInput = {
    id?: string
    orgId: string
    quoteId: string
    number: number
    title: string
    description?: string | null
    status?: $Enums.VariationStatus
    sentAt?: Date | string | null
    approvedAt?: Date | string | null
    vatMode?: $Enums.VatMode
    vatRateBps?: number
    createdByUserId?: string | null
    updatedByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: VariationItemUncheckedCreateNestedManyWithoutVariationInput
    approval?: VariationApprovalUncheckedCreateNestedOneWithoutVariationInput
    pdfs?: VariationPdfUncheckedCreateNestedManyWithoutVariationInput
  }

  export type VariationCreateOrConnectWithoutPublicLinksInput = {
    where: VariationWhereUniqueInput
    create: XOR<VariationCreateWithoutPublicLinksInput, VariationUncheckedCreateWithoutPublicLinksInput>
  }

  export type VariationUpsertWithoutPublicLinksInput = {
    update: XOR<VariationUpdateWithoutPublicLinksInput, VariationUncheckedUpdateWithoutPublicLinksInput>
    create: XOR<VariationCreateWithoutPublicLinksInput, VariationUncheckedCreateWithoutPublicLinksInput>
    where?: VariationWhereInput
  }

  export type VariationUpdateToOneWithWhereWithoutPublicLinksInput = {
    where?: VariationWhereInput
    data: XOR<VariationUpdateWithoutPublicLinksInput, VariationUncheckedUpdateWithoutPublicLinksInput>
  }

  export type VariationUpdateWithoutPublicLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVariationStatusFieldUpdateOperationsInput | $Enums.VariationStatus
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatMode?: EnumVatModeFieldUpdateOperationsInput | $Enums.VatMode
    vatRateBps?: IntFieldUpdateOperationsInput | number
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quote?: QuoteUpdateOneRequiredWithoutVariationsNestedInput
    items?: VariationItemUpdateManyWithoutVariationNestedInput
    approval?: VariationApprovalUpdateOneWithoutVariationNestedInput
    pdfs?: VariationPdfUpdateManyWithoutVariationNestedInput
  }

  export type VariationUncheckedUpdateWithoutPublicLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    quoteId?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVariationStatusFieldUpdateOperationsInput | $Enums.VariationStatus
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatMode?: EnumVatModeFieldUpdateOperationsInput | $Enums.VatMode
    vatRateBps?: IntFieldUpdateOperationsInput | number
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: VariationItemUncheckedUpdateManyWithoutVariationNestedInput
    approval?: VariationApprovalUncheckedUpdateOneWithoutVariationNestedInput
    pdfs?: VariationPdfUncheckedUpdateManyWithoutVariationNestedInput
  }

  export type VariationCreateWithoutPdfsInput = {
    id?: string
    number: number
    title: string
    description?: string | null
    status?: $Enums.VariationStatus
    sentAt?: Date | string | null
    approvedAt?: Date | string | null
    vatMode?: $Enums.VatMode
    vatRateBps?: number
    createdByUserId?: string | null
    updatedByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    quote: QuoteCreateNestedOneWithoutVariationsInput
    publicLinks?: VariationPublicLinkCreateNestedManyWithoutVariationInput
    items?: VariationItemCreateNestedManyWithoutVariationInput
    approval?: VariationApprovalCreateNestedOneWithoutVariationInput
  }

  export type VariationUncheckedCreateWithoutPdfsInput = {
    id?: string
    orgId: string
    quoteId: string
    number: number
    title: string
    description?: string | null
    status?: $Enums.VariationStatus
    sentAt?: Date | string | null
    approvedAt?: Date | string | null
    vatMode?: $Enums.VatMode
    vatRateBps?: number
    createdByUserId?: string | null
    updatedByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    publicLinks?: VariationPublicLinkUncheckedCreateNestedManyWithoutVariationInput
    items?: VariationItemUncheckedCreateNestedManyWithoutVariationInput
    approval?: VariationApprovalUncheckedCreateNestedOneWithoutVariationInput
  }

  export type VariationCreateOrConnectWithoutPdfsInput = {
    where: VariationWhereUniqueInput
    create: XOR<VariationCreateWithoutPdfsInput, VariationUncheckedCreateWithoutPdfsInput>
  }

  export type VariationUpsertWithoutPdfsInput = {
    update: XOR<VariationUpdateWithoutPdfsInput, VariationUncheckedUpdateWithoutPdfsInput>
    create: XOR<VariationCreateWithoutPdfsInput, VariationUncheckedCreateWithoutPdfsInput>
    where?: VariationWhereInput
  }

  export type VariationUpdateToOneWithWhereWithoutPdfsInput = {
    where?: VariationWhereInput
    data: XOR<VariationUpdateWithoutPdfsInput, VariationUncheckedUpdateWithoutPdfsInput>
  }

  export type VariationUpdateWithoutPdfsInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVariationStatusFieldUpdateOperationsInput | $Enums.VariationStatus
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatMode?: EnumVatModeFieldUpdateOperationsInput | $Enums.VatMode
    vatRateBps?: IntFieldUpdateOperationsInput | number
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quote?: QuoteUpdateOneRequiredWithoutVariationsNestedInput
    publicLinks?: VariationPublicLinkUpdateManyWithoutVariationNestedInput
    items?: VariationItemUpdateManyWithoutVariationNestedInput
    approval?: VariationApprovalUpdateOneWithoutVariationNestedInput
  }

  export type VariationUncheckedUpdateWithoutPdfsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orgId?: StringFieldUpdateOperationsInput | string
    quoteId?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVariationStatusFieldUpdateOperationsInput | $Enums.VariationStatus
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatMode?: EnumVatModeFieldUpdateOperationsInput | $Enums.VatMode
    vatRateBps?: IntFieldUpdateOperationsInput | number
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publicLinks?: VariationPublicLinkUncheckedUpdateManyWithoutVariationNestedInput
    items?: VariationItemUncheckedUpdateManyWithoutVariationNestedInput
    approval?: VariationApprovalUncheckedUpdateOneWithoutVariationNestedInput
  }

  export type QuoteCreateManyClientInput = {
    id?: string
    title: string
    referenceNo?: string | null
    projectAddress?: string | null
    status?: $Enums.QuoteStatus
    currentVersion?: number
    sentAt?: Date | string | null
    acceptedAt?: Date | string | null
    vatMode?: $Enums.VatMode
    vatRateBps?: number
    depositType?: $Enums.DepositType
    depositAmountPence?: number | null
    depositPercentBps?: number | null
    paymentScheduleJson?: NullableJsonNullValueInput | InputJsonValue
    showQtyToClient?: boolean
    showUnitRatesToClient?: boolean
    scopeOverviewJson?: NullableJsonNullValueInput | InputJsonValue
    termsJson?: NullableJsonNullValueInput | InputJsonValue
    estimatedStartDate?: Date | string | null
    estimatedDurationWeeks?: number | null
    createdByUserId?: string | null
    updatedByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuoteUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    referenceNo?: NullableStringFieldUpdateOperationsInput | string | null
    projectAddress?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQuoteStatusFieldUpdateOperationsInput | $Enums.QuoteStatus
    currentVersion?: IntFieldUpdateOperationsInput | number
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatMode?: EnumVatModeFieldUpdateOperationsInput | $Enums.VatMode
    vatRateBps?: IntFieldUpdateOperationsInput | number
    depositType?: EnumDepositTypeFieldUpdateOperationsInput | $Enums.DepositType
    depositAmountPence?: NullableIntFieldUpdateOperationsInput | number | null
    depositPercentBps?: NullableIntFieldUpdateOperationsInput | number | null
    paymentScheduleJson?: NullableJsonNullValueInput | InputJsonValue
    showQtyToClient?: BoolFieldUpdateOperationsInput | boolean
    showUnitRatesToClient?: BoolFieldUpdateOperationsInput | boolean
    scopeOverviewJson?: NullableJsonNullValueInput | InputJsonValue
    termsJson?: NullableJsonNullValueInput | InputJsonValue
    estimatedStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedDurationWeeks?: NullableIntFieldUpdateOperationsInput | number | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: QuoteItemUpdateManyWithoutQuoteNestedInput
    publicLinks?: QuotePublicLinkUpdateManyWithoutQuoteNestedInput
    pdfs?: QuotePdfUpdateManyWithoutQuoteNestedInput
    acceptance?: QuoteAcceptanceUpdateOneWithoutQuoteNestedInput
    variations?: VariationUpdateManyWithoutQuoteNestedInput
    versions?: QuoteVersionUpdateManyWithoutQuoteNestedInput
  }

  export type QuoteUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    referenceNo?: NullableStringFieldUpdateOperationsInput | string | null
    projectAddress?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQuoteStatusFieldUpdateOperationsInput | $Enums.QuoteStatus
    currentVersion?: IntFieldUpdateOperationsInput | number
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatMode?: EnumVatModeFieldUpdateOperationsInput | $Enums.VatMode
    vatRateBps?: IntFieldUpdateOperationsInput | number
    depositType?: EnumDepositTypeFieldUpdateOperationsInput | $Enums.DepositType
    depositAmountPence?: NullableIntFieldUpdateOperationsInput | number | null
    depositPercentBps?: NullableIntFieldUpdateOperationsInput | number | null
    paymentScheduleJson?: NullableJsonNullValueInput | InputJsonValue
    showQtyToClient?: BoolFieldUpdateOperationsInput | boolean
    showUnitRatesToClient?: BoolFieldUpdateOperationsInput | boolean
    scopeOverviewJson?: NullableJsonNullValueInput | InputJsonValue
    termsJson?: NullableJsonNullValueInput | InputJsonValue
    estimatedStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedDurationWeeks?: NullableIntFieldUpdateOperationsInput | number | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: QuoteItemUncheckedUpdateManyWithoutQuoteNestedInput
    publicLinks?: QuotePublicLinkUncheckedUpdateManyWithoutQuoteNestedInput
    pdfs?: QuotePdfUncheckedUpdateManyWithoutQuoteNestedInput
    acceptance?: QuoteAcceptanceUncheckedUpdateOneWithoutQuoteNestedInput
    variations?: VariationUncheckedUpdateManyWithoutQuoteNestedInput
    versions?: QuoteVersionUncheckedUpdateManyWithoutQuoteNestedInput
  }

  export type QuoteUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    referenceNo?: NullableStringFieldUpdateOperationsInput | string | null
    projectAddress?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQuoteStatusFieldUpdateOperationsInput | $Enums.QuoteStatus
    currentVersion?: IntFieldUpdateOperationsInput | number
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatMode?: EnumVatModeFieldUpdateOperationsInput | $Enums.VatMode
    vatRateBps?: IntFieldUpdateOperationsInput | number
    depositType?: EnumDepositTypeFieldUpdateOperationsInput | $Enums.DepositType
    depositAmountPence?: NullableIntFieldUpdateOperationsInput | number | null
    depositPercentBps?: NullableIntFieldUpdateOperationsInput | number | null
    paymentScheduleJson?: NullableJsonNullValueInput | InputJsonValue
    showQtyToClient?: BoolFieldUpdateOperationsInput | boolean
    showUnitRatesToClient?: BoolFieldUpdateOperationsInput | boolean
    scopeOverviewJson?: NullableJsonNullValueInput | InputJsonValue
    termsJson?: NullableJsonNullValueInput | InputJsonValue
    estimatedStartDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estimatedDurationWeeks?: NullableIntFieldUpdateOperationsInput | number | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuoteItemCreateManyQuoteInput = {
    id?: string
    parentId?: string | null
    rowType?: $Enums.ItemRowType
    title: string
    description?: string | null
    sortOrder?: number
    roomTag?: string | null
    tradeTag?: string | null
    phaseTag?: string | null
    calcType?: $Enums.CalcType
    qty?: Decimal | DecimalJsLike | number | string | null
    unit?: string | null
    unitPricePence?: number | null
    hours?: Decimal | DecimalJsLike | number | string | null
    hourlyRatePence?: number | null
    sellPricePence?: number | null
    isAllowance?: boolean
    costPence?: number | null
    markupPercentBps?: number | null
    createdByUserId?: string | null
    updatedByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuotePublicLinkCreateManyQuoteInput = {
    id?: string
    tokenHash: string
    tokenPrefix?: string | null
    isActive?: boolean
    expiresAt?: Date | string | null
    revokedAt?: Date | string | null
    firstViewedAt?: Date | string | null
    lastViewedAt?: Date | string | null
    viewCount?: number
    createdByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuotePdfCreateManyQuoteInput = {
    id?: string
    version: number
    fileUrl: string
    createdAt?: Date | string
  }

  export type VariationCreateManyQuoteInput = {
    id?: string
    number: number
    title: string
    description?: string | null
    status?: $Enums.VariationStatus
    sentAt?: Date | string | null
    approvedAt?: Date | string | null
    vatMode?: $Enums.VatMode
    vatRateBps?: number
    createdByUserId?: string | null
    updatedByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuoteVersionCreateManyQuoteInput = {
    id?: string
    version: number
    status: $Enums.QuoteStatus
    vatMode: $Enums.VatMode
    vatRateBps: number
    depositType: $Enums.DepositType
    depositAmountPence?: number | null
    depositPercentBps?: number | null
    showQtyToClient: boolean
    showUnitRatesToClient: boolean
    title: string
    referenceNo?: string | null
    projectAddress?: string | null
    scopeOverviewJson?: NullableJsonNullValueInput | InputJsonValue
    termsJson?: NullableJsonNullValueInput | InputJsonValue
    paymentScheduleJson?: NullableJsonNullValueInput | InputJsonValue
    subtotalPence?: number | null
    vatPence?: number | null
    totalPence?: number | null
    sentAt?: Date | string | null
    createdByUserId?: string | null
    createdAt?: Date | string
  }

  export type QuoteItemUpdateWithoutQuoteInput = {
    id?: StringFieldUpdateOperationsInput | string
    rowType?: EnumItemRowTypeFieldUpdateOperationsInput | $Enums.ItemRowType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    roomTag?: NullableStringFieldUpdateOperationsInput | string | null
    tradeTag?: NullableStringFieldUpdateOperationsInput | string | null
    phaseTag?: NullableStringFieldUpdateOperationsInput | string | null
    calcType?: EnumCalcTypeFieldUpdateOperationsInput | $Enums.CalcType
    qty?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    unitPricePence?: NullableIntFieldUpdateOperationsInput | number | null
    hours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    hourlyRatePence?: NullableIntFieldUpdateOperationsInput | number | null
    sellPricePence?: NullableIntFieldUpdateOperationsInput | number | null
    isAllowance?: BoolFieldUpdateOperationsInput | boolean
    costPence?: NullableIntFieldUpdateOperationsInput | number | null
    markupPercentBps?: NullableIntFieldUpdateOperationsInput | number | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: QuoteItemUpdateOneWithoutChildrenNestedInput
    children?: QuoteItemUpdateManyWithoutParentNestedInput
  }

  export type QuoteItemUncheckedUpdateWithoutQuoteInput = {
    id?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    rowType?: EnumItemRowTypeFieldUpdateOperationsInput | $Enums.ItemRowType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    roomTag?: NullableStringFieldUpdateOperationsInput | string | null
    tradeTag?: NullableStringFieldUpdateOperationsInput | string | null
    phaseTag?: NullableStringFieldUpdateOperationsInput | string | null
    calcType?: EnumCalcTypeFieldUpdateOperationsInput | $Enums.CalcType
    qty?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    unitPricePence?: NullableIntFieldUpdateOperationsInput | number | null
    hours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    hourlyRatePence?: NullableIntFieldUpdateOperationsInput | number | null
    sellPricePence?: NullableIntFieldUpdateOperationsInput | number | null
    isAllowance?: BoolFieldUpdateOperationsInput | boolean
    costPence?: NullableIntFieldUpdateOperationsInput | number | null
    markupPercentBps?: NullableIntFieldUpdateOperationsInput | number | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: QuoteItemUncheckedUpdateManyWithoutParentNestedInput
  }

  export type QuoteItemUncheckedUpdateManyWithoutQuoteInput = {
    id?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    rowType?: EnumItemRowTypeFieldUpdateOperationsInput | $Enums.ItemRowType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    roomTag?: NullableStringFieldUpdateOperationsInput | string | null
    tradeTag?: NullableStringFieldUpdateOperationsInput | string | null
    phaseTag?: NullableStringFieldUpdateOperationsInput | string | null
    calcType?: EnumCalcTypeFieldUpdateOperationsInput | $Enums.CalcType
    qty?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    unitPricePence?: NullableIntFieldUpdateOperationsInput | number | null
    hours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    hourlyRatePence?: NullableIntFieldUpdateOperationsInput | number | null
    sellPricePence?: NullableIntFieldUpdateOperationsInput | number | null
    isAllowance?: BoolFieldUpdateOperationsInput | boolean
    costPence?: NullableIntFieldUpdateOperationsInput | number | null
    markupPercentBps?: NullableIntFieldUpdateOperationsInput | number | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuotePublicLinkUpdateWithoutQuoteInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    tokenPrefix?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firstViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuotePublicLinkUncheckedUpdateWithoutQuoteInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    tokenPrefix?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firstViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuotePublicLinkUncheckedUpdateManyWithoutQuoteInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    tokenPrefix?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firstViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuotePdfUpdateWithoutQuoteInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    fileUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuotePdfUncheckedUpdateWithoutQuoteInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    fileUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuotePdfUncheckedUpdateManyWithoutQuoteInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    fileUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VariationUpdateWithoutQuoteInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVariationStatusFieldUpdateOperationsInput | $Enums.VariationStatus
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatMode?: EnumVatModeFieldUpdateOperationsInput | $Enums.VatMode
    vatRateBps?: IntFieldUpdateOperationsInput | number
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publicLinks?: VariationPublicLinkUpdateManyWithoutVariationNestedInput
    items?: VariationItemUpdateManyWithoutVariationNestedInput
    approval?: VariationApprovalUpdateOneWithoutVariationNestedInput
    pdfs?: VariationPdfUpdateManyWithoutVariationNestedInput
  }

  export type VariationUncheckedUpdateWithoutQuoteInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVariationStatusFieldUpdateOperationsInput | $Enums.VariationStatus
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatMode?: EnumVatModeFieldUpdateOperationsInput | $Enums.VatMode
    vatRateBps?: IntFieldUpdateOperationsInput | number
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publicLinks?: VariationPublicLinkUncheckedUpdateManyWithoutVariationNestedInput
    items?: VariationItemUncheckedUpdateManyWithoutVariationNestedInput
    approval?: VariationApprovalUncheckedUpdateOneWithoutVariationNestedInput
    pdfs?: VariationPdfUncheckedUpdateManyWithoutVariationNestedInput
  }

  export type VariationUncheckedUpdateManyWithoutQuoteInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVariationStatusFieldUpdateOperationsInput | $Enums.VariationStatus
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    vatMode?: EnumVatModeFieldUpdateOperationsInput | $Enums.VatMode
    vatRateBps?: IntFieldUpdateOperationsInput | number
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuoteVersionUpdateWithoutQuoteInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumQuoteStatusFieldUpdateOperationsInput | $Enums.QuoteStatus
    vatMode?: EnumVatModeFieldUpdateOperationsInput | $Enums.VatMode
    vatRateBps?: IntFieldUpdateOperationsInput | number
    depositType?: EnumDepositTypeFieldUpdateOperationsInput | $Enums.DepositType
    depositAmountPence?: NullableIntFieldUpdateOperationsInput | number | null
    depositPercentBps?: NullableIntFieldUpdateOperationsInput | number | null
    showQtyToClient?: BoolFieldUpdateOperationsInput | boolean
    showUnitRatesToClient?: BoolFieldUpdateOperationsInput | boolean
    title?: StringFieldUpdateOperationsInput | string
    referenceNo?: NullableStringFieldUpdateOperationsInput | string | null
    projectAddress?: NullableStringFieldUpdateOperationsInput | string | null
    scopeOverviewJson?: NullableJsonNullValueInput | InputJsonValue
    termsJson?: NullableJsonNullValueInput | InputJsonValue
    paymentScheduleJson?: NullableJsonNullValueInput | InputJsonValue
    subtotalPence?: NullableIntFieldUpdateOperationsInput | number | null
    vatPence?: NullableIntFieldUpdateOperationsInput | number | null
    totalPence?: NullableIntFieldUpdateOperationsInput | number | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: QuoteVersionItemUpdateManyWithoutQuoteVersionNestedInput
  }

  export type QuoteVersionUncheckedUpdateWithoutQuoteInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumQuoteStatusFieldUpdateOperationsInput | $Enums.QuoteStatus
    vatMode?: EnumVatModeFieldUpdateOperationsInput | $Enums.VatMode
    vatRateBps?: IntFieldUpdateOperationsInput | number
    depositType?: EnumDepositTypeFieldUpdateOperationsInput | $Enums.DepositType
    depositAmountPence?: NullableIntFieldUpdateOperationsInput | number | null
    depositPercentBps?: NullableIntFieldUpdateOperationsInput | number | null
    showQtyToClient?: BoolFieldUpdateOperationsInput | boolean
    showUnitRatesToClient?: BoolFieldUpdateOperationsInput | boolean
    title?: StringFieldUpdateOperationsInput | string
    referenceNo?: NullableStringFieldUpdateOperationsInput | string | null
    projectAddress?: NullableStringFieldUpdateOperationsInput | string | null
    scopeOverviewJson?: NullableJsonNullValueInput | InputJsonValue
    termsJson?: NullableJsonNullValueInput | InputJsonValue
    paymentScheduleJson?: NullableJsonNullValueInput | InputJsonValue
    subtotalPence?: NullableIntFieldUpdateOperationsInput | number | null
    vatPence?: NullableIntFieldUpdateOperationsInput | number | null
    totalPence?: NullableIntFieldUpdateOperationsInput | number | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: QuoteVersionItemUncheckedUpdateManyWithoutQuoteVersionNestedInput
  }

  export type QuoteVersionUncheckedUpdateManyWithoutQuoteInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    status?: EnumQuoteStatusFieldUpdateOperationsInput | $Enums.QuoteStatus
    vatMode?: EnumVatModeFieldUpdateOperationsInput | $Enums.VatMode
    vatRateBps?: IntFieldUpdateOperationsInput | number
    depositType?: EnumDepositTypeFieldUpdateOperationsInput | $Enums.DepositType
    depositAmountPence?: NullableIntFieldUpdateOperationsInput | number | null
    depositPercentBps?: NullableIntFieldUpdateOperationsInput | number | null
    showQtyToClient?: BoolFieldUpdateOperationsInput | boolean
    showUnitRatesToClient?: BoolFieldUpdateOperationsInput | boolean
    title?: StringFieldUpdateOperationsInput | string
    referenceNo?: NullableStringFieldUpdateOperationsInput | string | null
    projectAddress?: NullableStringFieldUpdateOperationsInput | string | null
    scopeOverviewJson?: NullableJsonNullValueInput | InputJsonValue
    termsJson?: NullableJsonNullValueInput | InputJsonValue
    paymentScheduleJson?: NullableJsonNullValueInput | InputJsonValue
    subtotalPence?: NullableIntFieldUpdateOperationsInput | number | null
    vatPence?: NullableIntFieldUpdateOperationsInput | number | null
    totalPence?: NullableIntFieldUpdateOperationsInput | number | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuoteItemCreateManyParentInput = {
    id?: string
    quoteId: string
    rowType?: $Enums.ItemRowType
    title: string
    description?: string | null
    sortOrder?: number
    roomTag?: string | null
    tradeTag?: string | null
    phaseTag?: string | null
    calcType?: $Enums.CalcType
    qty?: Decimal | DecimalJsLike | number | string | null
    unit?: string | null
    unitPricePence?: number | null
    hours?: Decimal | DecimalJsLike | number | string | null
    hourlyRatePence?: number | null
    sellPricePence?: number | null
    isAllowance?: boolean
    costPence?: number | null
    markupPercentBps?: number | null
    createdByUserId?: string | null
    updatedByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuoteItemUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    rowType?: EnumItemRowTypeFieldUpdateOperationsInput | $Enums.ItemRowType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    roomTag?: NullableStringFieldUpdateOperationsInput | string | null
    tradeTag?: NullableStringFieldUpdateOperationsInput | string | null
    phaseTag?: NullableStringFieldUpdateOperationsInput | string | null
    calcType?: EnumCalcTypeFieldUpdateOperationsInput | $Enums.CalcType
    qty?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    unitPricePence?: NullableIntFieldUpdateOperationsInput | number | null
    hours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    hourlyRatePence?: NullableIntFieldUpdateOperationsInput | number | null
    sellPricePence?: NullableIntFieldUpdateOperationsInput | number | null
    isAllowance?: BoolFieldUpdateOperationsInput | boolean
    costPence?: NullableIntFieldUpdateOperationsInput | number | null
    markupPercentBps?: NullableIntFieldUpdateOperationsInput | number | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quote?: QuoteUpdateOneRequiredWithoutItemsNestedInput
    children?: QuoteItemUpdateManyWithoutParentNestedInput
  }

  export type QuoteItemUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    quoteId?: StringFieldUpdateOperationsInput | string
    rowType?: EnumItemRowTypeFieldUpdateOperationsInput | $Enums.ItemRowType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    roomTag?: NullableStringFieldUpdateOperationsInput | string | null
    tradeTag?: NullableStringFieldUpdateOperationsInput | string | null
    phaseTag?: NullableStringFieldUpdateOperationsInput | string | null
    calcType?: EnumCalcTypeFieldUpdateOperationsInput | $Enums.CalcType
    qty?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    unitPricePence?: NullableIntFieldUpdateOperationsInput | number | null
    hours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    hourlyRatePence?: NullableIntFieldUpdateOperationsInput | number | null
    sellPricePence?: NullableIntFieldUpdateOperationsInput | number | null
    isAllowance?: BoolFieldUpdateOperationsInput | boolean
    costPence?: NullableIntFieldUpdateOperationsInput | number | null
    markupPercentBps?: NullableIntFieldUpdateOperationsInput | number | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: QuoteItemUncheckedUpdateManyWithoutParentNestedInput
  }

  export type QuoteItemUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    quoteId?: StringFieldUpdateOperationsInput | string
    rowType?: EnumItemRowTypeFieldUpdateOperationsInput | $Enums.ItemRowType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    roomTag?: NullableStringFieldUpdateOperationsInput | string | null
    tradeTag?: NullableStringFieldUpdateOperationsInput | string | null
    phaseTag?: NullableStringFieldUpdateOperationsInput | string | null
    calcType?: EnumCalcTypeFieldUpdateOperationsInput | $Enums.CalcType
    qty?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    unitPricePence?: NullableIntFieldUpdateOperationsInput | number | null
    hours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    hourlyRatePence?: NullableIntFieldUpdateOperationsInput | number | null
    sellPricePence?: NullableIntFieldUpdateOperationsInput | number | null
    isAllowance?: BoolFieldUpdateOperationsInput | boolean
    costPence?: NullableIntFieldUpdateOperationsInput | number | null
    markupPercentBps?: NullableIntFieldUpdateOperationsInput | number | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuoteVersionItemCreateManyQuoteVersionInput = {
    id?: string
    parentId?: string | null
    sourceQuoteItemId?: string | null
    rowType?: $Enums.ItemRowType
    title: string
    description?: string | null
    sortOrder?: number
    roomTag?: string | null
    tradeTag?: string | null
    phaseTag?: string | null
    calcType?: $Enums.CalcType
    qty?: Decimal | DecimalJsLike | number | string | null
    unit?: string | null
    unitPricePence?: number | null
    hours?: Decimal | DecimalJsLike | number | string | null
    hourlyRatePence?: number | null
    sellPricePence?: number | null
    isAllowance?: boolean
    lineTotalPence?: number | null
    createdAt?: Date | string
  }

  export type QuoteVersionItemUpdateWithoutQuoteVersionInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceQuoteItemId?: NullableStringFieldUpdateOperationsInput | string | null
    rowType?: EnumItemRowTypeFieldUpdateOperationsInput | $Enums.ItemRowType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    roomTag?: NullableStringFieldUpdateOperationsInput | string | null
    tradeTag?: NullableStringFieldUpdateOperationsInput | string | null
    phaseTag?: NullableStringFieldUpdateOperationsInput | string | null
    calcType?: EnumCalcTypeFieldUpdateOperationsInput | $Enums.CalcType
    qty?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    unitPricePence?: NullableIntFieldUpdateOperationsInput | number | null
    hours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    hourlyRatePence?: NullableIntFieldUpdateOperationsInput | number | null
    sellPricePence?: NullableIntFieldUpdateOperationsInput | number | null
    isAllowance?: BoolFieldUpdateOperationsInput | boolean
    lineTotalPence?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: QuoteVersionItemUpdateOneWithoutChildrenNestedInput
    children?: QuoteVersionItemUpdateManyWithoutParentNestedInput
  }

  export type QuoteVersionItemUncheckedUpdateWithoutQuoteVersionInput = {
    id?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceQuoteItemId?: NullableStringFieldUpdateOperationsInput | string | null
    rowType?: EnumItemRowTypeFieldUpdateOperationsInput | $Enums.ItemRowType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    roomTag?: NullableStringFieldUpdateOperationsInput | string | null
    tradeTag?: NullableStringFieldUpdateOperationsInput | string | null
    phaseTag?: NullableStringFieldUpdateOperationsInput | string | null
    calcType?: EnumCalcTypeFieldUpdateOperationsInput | $Enums.CalcType
    qty?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    unitPricePence?: NullableIntFieldUpdateOperationsInput | number | null
    hours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    hourlyRatePence?: NullableIntFieldUpdateOperationsInput | number | null
    sellPricePence?: NullableIntFieldUpdateOperationsInput | number | null
    isAllowance?: BoolFieldUpdateOperationsInput | boolean
    lineTotalPence?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: QuoteVersionItemUncheckedUpdateManyWithoutParentNestedInput
  }

  export type QuoteVersionItemUncheckedUpdateManyWithoutQuoteVersionInput = {
    id?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    sourceQuoteItemId?: NullableStringFieldUpdateOperationsInput | string | null
    rowType?: EnumItemRowTypeFieldUpdateOperationsInput | $Enums.ItemRowType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    roomTag?: NullableStringFieldUpdateOperationsInput | string | null
    tradeTag?: NullableStringFieldUpdateOperationsInput | string | null
    phaseTag?: NullableStringFieldUpdateOperationsInput | string | null
    calcType?: EnumCalcTypeFieldUpdateOperationsInput | $Enums.CalcType
    qty?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    unitPricePence?: NullableIntFieldUpdateOperationsInput | number | null
    hours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    hourlyRatePence?: NullableIntFieldUpdateOperationsInput | number | null
    sellPricePence?: NullableIntFieldUpdateOperationsInput | number | null
    isAllowance?: BoolFieldUpdateOperationsInput | boolean
    lineTotalPence?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuoteVersionItemCreateManyParentInput = {
    id?: string
    quoteVersionId: string
    sourceQuoteItemId?: string | null
    rowType?: $Enums.ItemRowType
    title: string
    description?: string | null
    sortOrder?: number
    roomTag?: string | null
    tradeTag?: string | null
    phaseTag?: string | null
    calcType?: $Enums.CalcType
    qty?: Decimal | DecimalJsLike | number | string | null
    unit?: string | null
    unitPricePence?: number | null
    hours?: Decimal | DecimalJsLike | number | string | null
    hourlyRatePence?: number | null
    sellPricePence?: number | null
    isAllowance?: boolean
    lineTotalPence?: number | null
    createdAt?: Date | string
  }

  export type QuoteVersionItemUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceQuoteItemId?: NullableStringFieldUpdateOperationsInput | string | null
    rowType?: EnumItemRowTypeFieldUpdateOperationsInput | $Enums.ItemRowType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    roomTag?: NullableStringFieldUpdateOperationsInput | string | null
    tradeTag?: NullableStringFieldUpdateOperationsInput | string | null
    phaseTag?: NullableStringFieldUpdateOperationsInput | string | null
    calcType?: EnumCalcTypeFieldUpdateOperationsInput | $Enums.CalcType
    qty?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    unitPricePence?: NullableIntFieldUpdateOperationsInput | number | null
    hours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    hourlyRatePence?: NullableIntFieldUpdateOperationsInput | number | null
    sellPricePence?: NullableIntFieldUpdateOperationsInput | number | null
    isAllowance?: BoolFieldUpdateOperationsInput | boolean
    lineTotalPence?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quoteVersion?: QuoteVersionUpdateOneRequiredWithoutItemsNestedInput
    children?: QuoteVersionItemUpdateManyWithoutParentNestedInput
  }

  export type QuoteVersionItemUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    quoteVersionId?: StringFieldUpdateOperationsInput | string
    sourceQuoteItemId?: NullableStringFieldUpdateOperationsInput | string | null
    rowType?: EnumItemRowTypeFieldUpdateOperationsInput | $Enums.ItemRowType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    roomTag?: NullableStringFieldUpdateOperationsInput | string | null
    tradeTag?: NullableStringFieldUpdateOperationsInput | string | null
    phaseTag?: NullableStringFieldUpdateOperationsInput | string | null
    calcType?: EnumCalcTypeFieldUpdateOperationsInput | $Enums.CalcType
    qty?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    unitPricePence?: NullableIntFieldUpdateOperationsInput | number | null
    hours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    hourlyRatePence?: NullableIntFieldUpdateOperationsInput | number | null
    sellPricePence?: NullableIntFieldUpdateOperationsInput | number | null
    isAllowance?: BoolFieldUpdateOperationsInput | boolean
    lineTotalPence?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: QuoteVersionItemUncheckedUpdateManyWithoutParentNestedInput
  }

  export type QuoteVersionItemUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    quoteVersionId?: StringFieldUpdateOperationsInput | string
    sourceQuoteItemId?: NullableStringFieldUpdateOperationsInput | string | null
    rowType?: EnumItemRowTypeFieldUpdateOperationsInput | $Enums.ItemRowType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    roomTag?: NullableStringFieldUpdateOperationsInput | string | null
    tradeTag?: NullableStringFieldUpdateOperationsInput | string | null
    phaseTag?: NullableStringFieldUpdateOperationsInput | string | null
    calcType?: EnumCalcTypeFieldUpdateOperationsInput | $Enums.CalcType
    qty?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    unitPricePence?: NullableIntFieldUpdateOperationsInput | number | null
    hours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    hourlyRatePence?: NullableIntFieldUpdateOperationsInput | number | null
    sellPricePence?: NullableIntFieldUpdateOperationsInput | number | null
    isAllowance?: BoolFieldUpdateOperationsInput | boolean
    lineTotalPence?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TemplateSectionItemCreateManyTemplateSectionInput = {
    id?: string
    title: string
    description?: string | null
    sortOrder?: number
    calcType?: $Enums.CalcType
    qty?: Decimal | DecimalJsLike | number | string | null
    unit?: string | null
    unitPricePence?: number | null
    hours?: Decimal | DecimalJsLike | number | string | null
    hourlyRatePence?: number | null
    sellPricePence?: number | null
    isAllowance?: boolean
    roomTag?: string | null
    tradeTag?: string | null
    phaseTag?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TemplateSectionItemUpdateWithoutTemplateSectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    calcType?: EnumCalcTypeFieldUpdateOperationsInput | $Enums.CalcType
    qty?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    unitPricePence?: NullableIntFieldUpdateOperationsInput | number | null
    hours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    hourlyRatePence?: NullableIntFieldUpdateOperationsInput | number | null
    sellPricePence?: NullableIntFieldUpdateOperationsInput | number | null
    isAllowance?: BoolFieldUpdateOperationsInput | boolean
    roomTag?: NullableStringFieldUpdateOperationsInput | string | null
    tradeTag?: NullableStringFieldUpdateOperationsInput | string | null
    phaseTag?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TemplateSectionItemUncheckedUpdateWithoutTemplateSectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    calcType?: EnumCalcTypeFieldUpdateOperationsInput | $Enums.CalcType
    qty?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    unitPricePence?: NullableIntFieldUpdateOperationsInput | number | null
    hours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    hourlyRatePence?: NullableIntFieldUpdateOperationsInput | number | null
    sellPricePence?: NullableIntFieldUpdateOperationsInput | number | null
    isAllowance?: BoolFieldUpdateOperationsInput | boolean
    roomTag?: NullableStringFieldUpdateOperationsInput | string | null
    tradeTag?: NullableStringFieldUpdateOperationsInput | string | null
    phaseTag?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TemplateSectionItemUncheckedUpdateManyWithoutTemplateSectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    calcType?: EnumCalcTypeFieldUpdateOperationsInput | $Enums.CalcType
    qty?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    unitPricePence?: NullableIntFieldUpdateOperationsInput | number | null
    hours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    hourlyRatePence?: NullableIntFieldUpdateOperationsInput | number | null
    sellPricePence?: NullableIntFieldUpdateOperationsInput | number | null
    isAllowance?: BoolFieldUpdateOperationsInput | boolean
    roomTag?: NullableStringFieldUpdateOperationsInput | string | null
    tradeTag?: NullableStringFieldUpdateOperationsInput | string | null
    phaseTag?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VariationPublicLinkCreateManyVariationInput = {
    id?: string
    tokenHash: string
    tokenPrefix?: string | null
    isActive?: boolean
    expiresAt?: Date | string | null
    revokedAt?: Date | string | null
    firstViewedAt?: Date | string | null
    lastViewedAt?: Date | string | null
    viewCount?: number
    createdByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VariationItemCreateManyVariationInput = {
    id?: string
    parentId?: string | null
    rowType?: $Enums.ItemRowType
    title: string
    description?: string | null
    sortOrder?: number
    calcType?: $Enums.CalcType
    qty?: Decimal | DecimalJsLike | number | string | null
    unit?: string | null
    unitPricePence?: number | null
    hours?: Decimal | DecimalJsLike | number | string | null
    hourlyRatePence?: number | null
    sellPricePence?: number | null
    isAllowance?: boolean
    roomTag?: string | null
    tradeTag?: string | null
    phaseTag?: string | null
    costPence?: number | null
    markupPercentBps?: number | null
    createdByUserId?: string | null
    updatedByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VariationPdfCreateManyVariationInput = {
    id?: string
    stage: $Enums.VariationPdfStage
    fileUrl: string
    createdAt?: Date | string
  }

  export type VariationPublicLinkUpdateWithoutVariationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    tokenPrefix?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firstViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VariationPublicLinkUncheckedUpdateWithoutVariationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    tokenPrefix?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firstViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VariationPublicLinkUncheckedUpdateManyWithoutVariationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    tokenPrefix?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firstViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VariationItemUpdateWithoutVariationInput = {
    id?: StringFieldUpdateOperationsInput | string
    rowType?: EnumItemRowTypeFieldUpdateOperationsInput | $Enums.ItemRowType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    calcType?: EnumCalcTypeFieldUpdateOperationsInput | $Enums.CalcType
    qty?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    unitPricePence?: NullableIntFieldUpdateOperationsInput | number | null
    hours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    hourlyRatePence?: NullableIntFieldUpdateOperationsInput | number | null
    sellPricePence?: NullableIntFieldUpdateOperationsInput | number | null
    isAllowance?: BoolFieldUpdateOperationsInput | boolean
    roomTag?: NullableStringFieldUpdateOperationsInput | string | null
    tradeTag?: NullableStringFieldUpdateOperationsInput | string | null
    phaseTag?: NullableStringFieldUpdateOperationsInput | string | null
    costPence?: NullableIntFieldUpdateOperationsInput | number | null
    markupPercentBps?: NullableIntFieldUpdateOperationsInput | number | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: VariationItemUpdateOneWithoutChildrenNestedInput
    children?: VariationItemUpdateManyWithoutParentNestedInput
  }

  export type VariationItemUncheckedUpdateWithoutVariationInput = {
    id?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    rowType?: EnumItemRowTypeFieldUpdateOperationsInput | $Enums.ItemRowType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    calcType?: EnumCalcTypeFieldUpdateOperationsInput | $Enums.CalcType
    qty?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    unitPricePence?: NullableIntFieldUpdateOperationsInput | number | null
    hours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    hourlyRatePence?: NullableIntFieldUpdateOperationsInput | number | null
    sellPricePence?: NullableIntFieldUpdateOperationsInput | number | null
    isAllowance?: BoolFieldUpdateOperationsInput | boolean
    roomTag?: NullableStringFieldUpdateOperationsInput | string | null
    tradeTag?: NullableStringFieldUpdateOperationsInput | string | null
    phaseTag?: NullableStringFieldUpdateOperationsInput | string | null
    costPence?: NullableIntFieldUpdateOperationsInput | number | null
    markupPercentBps?: NullableIntFieldUpdateOperationsInput | number | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: VariationItemUncheckedUpdateManyWithoutParentNestedInput
  }

  export type VariationItemUncheckedUpdateManyWithoutVariationInput = {
    id?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    rowType?: EnumItemRowTypeFieldUpdateOperationsInput | $Enums.ItemRowType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    calcType?: EnumCalcTypeFieldUpdateOperationsInput | $Enums.CalcType
    qty?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    unitPricePence?: NullableIntFieldUpdateOperationsInput | number | null
    hours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    hourlyRatePence?: NullableIntFieldUpdateOperationsInput | number | null
    sellPricePence?: NullableIntFieldUpdateOperationsInput | number | null
    isAllowance?: BoolFieldUpdateOperationsInput | boolean
    roomTag?: NullableStringFieldUpdateOperationsInput | string | null
    tradeTag?: NullableStringFieldUpdateOperationsInput | string | null
    phaseTag?: NullableStringFieldUpdateOperationsInput | string | null
    costPence?: NullableIntFieldUpdateOperationsInput | number | null
    markupPercentBps?: NullableIntFieldUpdateOperationsInput | number | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VariationPdfUpdateWithoutVariationInput = {
    id?: StringFieldUpdateOperationsInput | string
    stage?: EnumVariationPdfStageFieldUpdateOperationsInput | $Enums.VariationPdfStage
    fileUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VariationPdfUncheckedUpdateWithoutVariationInput = {
    id?: StringFieldUpdateOperationsInput | string
    stage?: EnumVariationPdfStageFieldUpdateOperationsInput | $Enums.VariationPdfStage
    fileUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VariationPdfUncheckedUpdateManyWithoutVariationInput = {
    id?: StringFieldUpdateOperationsInput | string
    stage?: EnumVariationPdfStageFieldUpdateOperationsInput | $Enums.VariationPdfStage
    fileUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VariationItemCreateManyParentInput = {
    id?: string
    variationId: string
    rowType?: $Enums.ItemRowType
    title: string
    description?: string | null
    sortOrder?: number
    calcType?: $Enums.CalcType
    qty?: Decimal | DecimalJsLike | number | string | null
    unit?: string | null
    unitPricePence?: number | null
    hours?: Decimal | DecimalJsLike | number | string | null
    hourlyRatePence?: number | null
    sellPricePence?: number | null
    isAllowance?: boolean
    roomTag?: string | null
    tradeTag?: string | null
    phaseTag?: string | null
    costPence?: number | null
    markupPercentBps?: number | null
    createdByUserId?: string | null
    updatedByUserId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VariationItemUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    rowType?: EnumItemRowTypeFieldUpdateOperationsInput | $Enums.ItemRowType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    calcType?: EnumCalcTypeFieldUpdateOperationsInput | $Enums.CalcType
    qty?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    unitPricePence?: NullableIntFieldUpdateOperationsInput | number | null
    hours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    hourlyRatePence?: NullableIntFieldUpdateOperationsInput | number | null
    sellPricePence?: NullableIntFieldUpdateOperationsInput | number | null
    isAllowance?: BoolFieldUpdateOperationsInput | boolean
    roomTag?: NullableStringFieldUpdateOperationsInput | string | null
    tradeTag?: NullableStringFieldUpdateOperationsInput | string | null
    phaseTag?: NullableStringFieldUpdateOperationsInput | string | null
    costPence?: NullableIntFieldUpdateOperationsInput | number | null
    markupPercentBps?: NullableIntFieldUpdateOperationsInput | number | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    variation?: VariationUpdateOneRequiredWithoutItemsNestedInput
    children?: VariationItemUpdateManyWithoutParentNestedInput
  }

  export type VariationItemUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    variationId?: StringFieldUpdateOperationsInput | string
    rowType?: EnumItemRowTypeFieldUpdateOperationsInput | $Enums.ItemRowType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    calcType?: EnumCalcTypeFieldUpdateOperationsInput | $Enums.CalcType
    qty?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    unitPricePence?: NullableIntFieldUpdateOperationsInput | number | null
    hours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    hourlyRatePence?: NullableIntFieldUpdateOperationsInput | number | null
    sellPricePence?: NullableIntFieldUpdateOperationsInput | number | null
    isAllowance?: BoolFieldUpdateOperationsInput | boolean
    roomTag?: NullableStringFieldUpdateOperationsInput | string | null
    tradeTag?: NullableStringFieldUpdateOperationsInput | string | null
    phaseTag?: NullableStringFieldUpdateOperationsInput | string | null
    costPence?: NullableIntFieldUpdateOperationsInput | number | null
    markupPercentBps?: NullableIntFieldUpdateOperationsInput | number | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: VariationItemUncheckedUpdateManyWithoutParentNestedInput
  }

  export type VariationItemUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    variationId?: StringFieldUpdateOperationsInput | string
    rowType?: EnumItemRowTypeFieldUpdateOperationsInput | $Enums.ItemRowType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    calcType?: EnumCalcTypeFieldUpdateOperationsInput | $Enums.CalcType
    qty?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    unitPricePence?: NullableIntFieldUpdateOperationsInput | number | null
    hours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    hourlyRatePence?: NullableIntFieldUpdateOperationsInput | number | null
    sellPricePence?: NullableIntFieldUpdateOperationsInput | number | null
    isAllowance?: BoolFieldUpdateOperationsInput | boolean
    roomTag?: NullableStringFieldUpdateOperationsInput | string | null
    tradeTag?: NullableStringFieldUpdateOperationsInput | string | null
    phaseTag?: NullableStringFieldUpdateOperationsInput | string | null
    costPence?: NullableIntFieldUpdateOperationsInput | number | null
    markupPercentBps?: NullableIntFieldUpdateOperationsInput | number | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    updatedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}